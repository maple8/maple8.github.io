<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅析加密、签名和数字证书</title>
      <link href="/maple/2023/06/29/%E6%B5%85%E6%9E%90%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
      <url>/maple/2023/06/29/%E6%B5%85%E6%9E%90%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析加密、数字签名和数字证书"><a href="#浅析加密、数字签名和数字证书" class="headerlink" title="浅析加密、数字签名和数字证书"></a>浅析加密、数字签名和数字证书</h1><blockquote><p><strong>Q:</strong></p><ol><li>非对称加密中公私钥都可以加密，那么什么时候用公钥”加密”，什么时候用私钥“加密” ？</li><li>什么是数字签名，数字签名的作用是什么？</li><li>为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？</li><li>什么是数字证书，数字证书解决了什么问题？</li></ol></blockquote><h2 id="什么是加密"><a href="#什么是加密" class="headerlink" title="什么是加密"></a>什么是加密</h2><p>加密就是<strong>对明文数据按某种特殊算法进行处理，使其成为不可读的一段代码，通常称为“密文”。</strong> 密文通过”密钥”解密后还原出原来的明文，通过这样的途径可以达到保护数据不被非法人窃取、阅读的目的。</p><p>考虑以下哪些属于加密方法：</p><ul><li><strong>AES</strong></li><li><strong>DES</strong></li><li><strong>RSA</strong></li><li>SM4</li><li>SHA</li><li>MD5</li><li>BASE64</li></ul><p>这几种都是日常开发中常用的<strong>数据编码技术</strong>，但是<strong>只有 AES、RSA、SM4 才能算是加密算法</strong>。</p><p>为什么呢？</p><p><strong>一个区分的简单方法就是****看编码后的数据是否能还原，能还原的才是加密算法。</strong></p><p>MD5 实际上是对数据进行<strong>有损压缩</strong>，无论数据有多长，1KB、1Mb 还是 1G，都会<strong>生成****固定 128 位的散列值（实际开发中会为以32位的十六进制字符串进行显示）</strong>，并且 MD5 理论上是不可能对编码后的数据进行还原的，即<strong>不可逆</strong>。MD5 因其具有不可逆性、单向恒定性[幂等性]（相同的数据多次计算值不变）被广泛应用于文件完整性验证、口令加密以及接下来会讲到的数字签名中。</p><p>SHA和MD5算法类似，SHA (Security Hash Algorithm) 安全哈希算法也是一种信息摘要生成算法。</p><p>使用非对称加密时的签名，使用私钥对摘要进行签名，这个过程称为数字签名 – 数字签名是专门针对使用非对称加密的场景。</p><p>如果不使用非对称加密，直接使用MD5和SHA1来实现签名和验签操作也是OK的。</p><p>至于 BASE64 是否算做加密方法，仁者见仁。在这里不下结论，因为 BASE64 编码不需要密钥，且编码后的字符串任何人都可以解码出原串，所以一般不认为是加密方法。<strong>BASE64 常用来做转码（重编码）</strong>，如: 把二进制字节序列转化为Base64字符序列。BASE64是一种编码格式。</p><p>Base64是网络上最常见的用于传输8Bit<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fromModule=lemma_inlink">字节码</a>的编码方式之一，Base64就是一种基于64个可打印字符来表示<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457?fromModule=lemma_inlink">二进制</a>数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3<em>8 = 4</em>6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3（代码Demo已验证）。</p><p>关于这个编码的规则：</p><ol><li>把3个字节变成4个字节。</li><li>每76个字符加一个换行符。</li><li>最后的结束符也要处理。</li></ol><p>Base64编码是从二进制到字符的过程，可用于在<a href="https://baike.baidu.com/item/HTTP?fromModule=lemma_inlink">HTTP</a>环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p><p>加密算法得出的加密字符串使用的是ASCII码字符集，ASCII码字符集有128个字符，其中96个为可见字符，剩下的为不可见字符。所以在使用加密算法进行加密的时候得到的加密字符串中可能会出现不可见的字符，这样会导致调用方无法正确的解析密文。因此在使用加密算法加密数据之后通常都会使用BASE64进行编码，确保密文的组成字符都是可见字符。</p><h3 id="BASE64转换表"><a href="#BASE64转换表" class="headerlink" title="BASE64转换表"></a>BASE64转换表</h3><table><thead><tr><th><strong>索引</strong></th><th><strong>对应字符</strong></th><th><strong>索引</strong></th><th><strong>对应字符</strong></th><th><strong>索引</strong></th><th><strong>对应字符</strong></th><th><strong>索引</strong></th><th><strong>对应字符</strong></th></tr></thead><tbody><tr><td>0</td><td><strong>A</strong></td><td>17</td><td><strong>R</strong></td><td>34</td><td><strong>i</strong></td><td>51</td><td><strong>z</strong></td></tr><tr><td>1</td><td><strong>B</strong></td><td>18</td><td><strong>S</strong></td><td>35</td><td><strong>j</strong></td><td>52</td><td><strong>0</strong></td></tr><tr><td>2</td><td><strong>C</strong></td><td>19</td><td><strong>T</strong></td><td>36</td><td><strong>k</strong></td><td>53</td><td><strong>1</strong></td></tr><tr><td>3</td><td><strong>D</strong></td><td>20</td><td><strong>U</strong></td><td>37</td><td><strong>l</strong></td><td>54</td><td><strong>2</strong></td></tr><tr><td>4</td><td><strong>E</strong></td><td>21</td><td><strong>V</strong></td><td>38</td><td><strong>m</strong></td><td>55</td><td><strong>3</strong></td></tr><tr><td>5</td><td><strong>F</strong></td><td>22</td><td><strong>W</strong></td><td>39</td><td><strong>n</strong></td><td>56</td><td><strong>4</strong></td></tr><tr><td>6</td><td><strong>G</strong></td><td>23</td><td><strong>X</strong></td><td>40</td><td><strong>o</strong></td><td>57</td><td><strong>5</strong></td></tr><tr><td>7</td><td><strong>H</strong></td><td>24</td><td><strong>Y</strong></td><td>41</td><td><strong>p</strong></td><td>58</td><td><strong>6</strong></td></tr><tr><td>8</td><td><strong>I</strong></td><td>25</td><td><strong>Z</strong></td><td>42</td><td><strong>q</strong></td><td>59</td><td><strong>7</strong></td></tr><tr><td>9</td><td><strong>J</strong></td><td>26</td><td><strong>a</strong></td><td>43</td><td><strong>r</strong></td><td>60</td><td><strong>8</strong></td></tr><tr><td>10</td><td><strong>K</strong></td><td>27</td><td><strong>b</strong></td><td>44</td><td><strong>s</strong></td><td>61</td><td><strong>9</strong></td></tr><tr><td>11</td><td><strong>L</strong></td><td>28</td><td><strong>c</strong></td><td>45</td><td><strong>t</strong></td><td>62</td><td><strong>+</strong></td></tr><tr><td>12</td><td><strong>M</strong></td><td>29</td><td><strong>d</strong></td><td>46</td><td><strong>u</strong></td><td>63</td><td><strong>/</strong></td></tr><tr><td>13</td><td><strong>N</strong></td><td>30</td><td><strong>e</strong></td><td>47</td><td><strong>v</strong></td><td></td><td></td></tr><tr><td>14</td><td><strong>O</strong></td><td>31</td><td><strong>f</strong></td><td>48</td><td><strong>w</strong></td><td></td><td></td></tr><tr><td>15</td><td><strong>P</strong></td><td>32</td><td><strong>g</strong></td><td>49</td><td><strong>x</strong></td><td></td><td></td></tr><tr><td>16</td><td><strong>Q</strong></td><td>33</td><td><strong>h</strong></td><td>50</td><td><strong>y</strong></td><td></td><td></td></tr></tbody></table><h3 id="加密算法的分类"><a href="#加密算法的分类" class="headerlink" title="加密算法的分类"></a>加密算法的分类</h3><p>加密算法按照加解密使用的密钥是否相同，可分为：</p><ul><li><p><strong>对称加密（Symmetric Cryptography）</strong></p></li><li><ul><li><strong>秘钥相同</strong></li><li><strong>AES，DES</strong></li></ul></li></ul><p><strong>AES和DES算法的主要区别</strong></p><p>AES与DES之间的主要区别在于加密过程。在DES中，将明文分为两半，然后再进行进一步处理；而在AES中，整个块不进行除法，整个块一起处理以生成密文。相对而言，AES比DES快得多，与DES相比，AES能够在几秒钟内加密大型文件。</p><p>由于DES中使用的共享密钥的比特大小较小，因此它被认为不如AES安全。DES被认为更容易受到暴力攻击，而到目前为止，尚未遇到任何严重攻击的AES。</p><p>在灵活性的基础上评估算法的实现，AES比DES更具灵活性，因为它允许包括128、192、256位在内的各种长度的文本，而DES允许对64位固定文本进行加密。</p><p>DES回合处理中使用的功能是扩展，置换和替换，具有回合键的XOR操作，而AES回合中使用的功能是子字节，移位行，混合列和添加回合键。AES实际上在硬件和软件实现上都是高效的，而DES最初只在硬件上有效。</p><p><strong>DES算法缺点：</strong></p><p>分组比较短、密钥太短、密码生命周期短、运算速度较慢。</p><p><strong>DES算法优点：</strong></p><p>DES算法具有极高安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。</p><p><strong>AES算法缺点：</strong></p><p>目前尚未存在对AES 算法完整版的成功攻击，但已经提出对其简化算法的攻击。</p><p><strong>AES算法优点：</strong></p><p>1、运算速度快，对内存的需求非常低，适合于受限环境。</p><p>2、分组长度和密钥长度设计灵活， AES标准支持可变分组长度，分组长度可设定为32比特的任意倍数，最小值为128比特，最大值为256比特。</p><p>3、 AES的密钥长度比DES大，它也可设定为32比特的任意倍数，最小值为128比特，最大值为256比特，所以用穷举法是不可能破解的。</p><p>4、具有很好的抵抗差分密码分析及线性密码分析的能力。</p><p><strong>总而言之，AES和DES算法之间的区别就是加密过程，这两种算法都有自己的优缺点，相对来说，AES比DES安全性高，运算速度快。</strong></p><ul><li><p><strong>非对称加密（Asymmetric Cryptography）</strong></p></li><li><ul><li><strong>秘钥不同</strong></li><li><strong>RSA</strong></li></ul></li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指加密和解密时使用同一个密钥。</p><img src="image-20230629194658600.png" alt="image-20230629194658600" style="zoom: 33%;"><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密是指加密和解密使用不同的密钥，这两个密钥分别叫做「公钥」、「私钥」。</p><p>公钥是可以公开给所有人的，而私钥需要自己保密的。公钥加密的数据只能用私钥解密。</p><img src="image-20230629194750698.png" alt="image-20230629194750698" style="zoom:33%;"><p>同理，私钥“加密”的数据只能用公钥“解密”：</p><img src="image-20230629194830702.png" alt="image-20230629194830702" style="zoom:33%;"><p>大家注意到没， <strong>私钥“加密”</strong> 这里打了引号，为什么呢？</p><p>因为私钥不是用来加密的，准确的说法应该是 <font color="red"><strong>「私钥签名，公钥验签」</strong></font>。</p><p>这个问题很多同学都存在误解，认为公私钥都可以用于加密。实际上不是的，至于为什么，后面会解释的。</p><p>这么看来，非对称加密的公私钥就有两种玩法了，如下两种场景:</p><ul><li><strong>加密场景</strong><ul><li><font color="green">公钥加密 –&gt; 私钥解密</font></li></ul></li><li><strong>数字签名场景</strong><ul><li><font color="green">私钥签名（也就是加密操作，只是称呼不一样） –&gt; 公钥验签（也就是解密操作，称呼不一样）</font></li></ul></li></ul><p>接下来引入一个小故事继续后续内容。</p><p><strong>故事开始</strong></p><p><strong>第一回合</strong></p><p>Bob 想约 Alice 出来玩，于是给 Alice 发了一封邮件：</p><img src="image-20230629195514420.png" alt="image-20230629195514420" style="zoom:33%;"><p>但我们都知道网络是不可信的，并且由于消息在网络中是明文传输的，所以黑客可以轻易的截获、篡改甚至冒充 Bob。来，我们看看黑客 Eve 是怎么干的：</p><img src="image-20230629195550962.png" alt="image-20230629195550962" style="zoom:33%;"><p>瞧，Eve 轻易的拿到了邮件内容 （<strong>窃听</strong>），并且修改了邮件内容 （<strong>篡改</strong>），甚至说他可以随时冒充 Bob 给 Alice 发送邮件 （伪装）。如果上图中 Eve 伪造的内容被 Alice 接收到了，那么后果可想而知。现实世界中，我们每天都在通过网络进行聊天、转账、浏览不存在网站。如果都是这样明文传输数据，显然毫无安全感。</p><p><strong>第二回合</strong></p><p>既然我们不能明文传输，那么 Bob 和 Alice 提前商量好密钥，使用对称加密对邮件内容加密不就好了~</p><img src="image-20230629195626990.png" alt="image-20230629195626990" style="zoom:33%;"><p>现在 Bob 发送的邮件都使用和 Alice 提前商量好的密钥加密后再传输。由于没有密钥，Eve 就算截获到数据也无法获取邮件的内容，也没法篡改和冒充 Bob。因为篡改后的数据必须使用密钥再次加密 Alice 才能正确解密。那么只要 Bob 和 Alice 能够保证密钥不泄露，整个通信就是安全的。如果密钥泄露，被中间人截获，那么就等同于明文通信。所以我们不能把安全性寄托在人上面[这也是开发中需要规避的问题，相当于不要依赖调用方的入参不发生错误]。并且这里也存在一个问题，如果两个人不能线下见面， 如何在网上安全的交换密钥呢？</p><p>这似乎是无解的，因为交换密钥的时候我们必须明文通信，不然对方根本看不懂。但是明文交换即意味着可能泄露。但是别忘了我们的密码学工具箱里还有一个好东西 — 「非对称加密」。</p><p>Bob 和 Alice 各自生成一对公私钥，因为公钥本来就是公开的，可以被任何人获取，所以可以通过网络明文交换公钥。然后使用公钥加密邮件内容后发送给对方，接收者使用自己的私钥即可解密。完美~</p><p><strong>第三回合</strong></p><p>来看看，在非对称加密体系下，Bob 如何给 Alice 发消息的。</p><p>首先 Alice 需要先生成一对公私钥，私钥只能 Alice 自己知道，公钥是可以让任何人都知道的，因此可将公钥直接发送给 Bob，就算被截获也无所谓。</p><img src="image-20230629195714586.png" alt="image-20230629195714586" style="zoom:33%;"><p>Bob 使用 Alice 的公钥加密邮件内容，加密后的内容只能由 Alice 的私钥解密，所以就算 Eve 截获也是徒劳。反之，如果 Alice 想给 Bob 回信，就需要用 Bob 的公钥加密后发送。这就解决了密钥交换问题，也保证了邮件内容不会泄露。也就是说现在可以防窃听。</p><p><strong>如何证明 Bob 是 Bob</strong></p><p>不知道你注意到没有，这里也存在另外一个问题：Eve 也可以使用 Alice 的公钥冒充 Bob 给 Alice 发邮件啊，因为 Alice 的公钥本来就是公开的，任何人都可以获得。由于 Eve 也可以获得 Alice 公钥，所以没法防止 Eve 伪装和篡改，并且对于 Alice 而言，她无法分辨出邮件到底是 Eve 发的还是 Bob。所以这个问题的本质就是 「Alice 如何确认邮件来自于 Bob」。</p><p>那么在生活中，我们如何做这件事呢？</p><p>那就是让 Bob 在纸上签名并且按手印，因为指纹和字迹是 Bob 独有的，其它人很难伪造。所以我们需要在计算机中引入类似的机制：即只有 Bob 自己能够产生的独一无二的标志，并且其它人能够验证这个标志确实是属于 Bob的。</p><p>这就是我们今天要讲的主题—<font color="red">「<strong>数字签名</strong>」</font>。</p><p>还记得什么是 Bob 独有的吗？</p><p>对，就是 Bob 自己的私钥，Bob 用自己的私钥对邮件内容计算一个「签名」，将「签名」和邮件内容一起发送出去，接受者 Alice 可以使用 Bob 的公钥验证这个签名是否正确，这就叫「验签」。如果不是 Bob 的私钥计算的签名，那么 Alice 用 Bob 公钥验签将会出错。</p><img src="image-20230629195851532.png" alt="image-20230629195851532" style="zoom:33%;"><p>可以看到， Eve 试图使用自己的私钥计算签名然后发送给 Alice， 但是 Alice 使用 Bob的公钥进行验签时将会出错！</p><p>那么 Eve 可能篡改内容并冒充 Bob 的签名吗？不可能！因为内容发生改变时，对应的签名也需要重新计算，而签名的生成依赖于私钥，只要 Bob 的私钥不泄露，签名就不会被冒充。啊啥？你说万一私钥泄露了怎么办？那就当我没说…</p><p>所以<strong>使用数字签名，我们能够鉴别消息的发送者</strong>，也就是说黑客无法伪装发送者进行发送数据，也无法篡改。</p><blockquote><p><strong>注意：</strong></p><p>可以看出我们这里数据是明文传输的，存在窃听风险。这是我们为了阐述数字签名机制是如何运转的，故意将保证信息机密性的机制省略了。<strong>如果想要保证数据的机密性，我们常见的做法是，通信双方通过非对称加密安全交换对称加密的密钥，后续通信过程的数据都使用对称加密保证数据机密性。</strong>并且「签名」的作用本身也不是用来保证数据的机密性，而是用于验证数据来源的防止数据被篡改的，也就是确认发送者的身份。</p></blockquote><p>一般而言，我们不会直接对数据本身直接计算数字签名，为什么呢？</p><p>因为数字签名属于非对称加密，非对称加密依赖于复杂的数学运算，包括大数乘法、大数模等等，耗时比较久。如果数据量大的时候计算数字签名将会比较耗时，所以一般做法是先将原数据进行 Hash 运算，得到的 Hash 值就叫做「摘要」。</p><p>「摘要」就像人的指纹一样，可以代表一个人，只要内容发生了改变，计算出来的摘要也应该变化。</p><p>「摘要」最好是不可逆转的，一般使用开头提到的 MD5 作为 Hash 函数，MD5 输出的结果固定位 128 位。</p><blockquote><p><strong>为什么「摘要」最好是不可逆转的？</strong></p><p>因为既然 Alice 可以用 Bob 公钥解开签名，那么理论上其它人，比如 Eve 也可以使用 Bob 公钥解开签名拿到数据。所以我们最好对数据的「摘要」进行签名，这样，Eve 就算解开签名，拿到的也是「摘要」，如果摘要是不可逆转的，也就是无法从摘要反推出原文，也就达到了保密的作用。</p></blockquote><p>发送者使用私钥对「摘要」计算数字签名。那么接收者如何验证呢？</p><img src="image-20230629195948011.png" alt="image-20230629195948011" style="zoom:33%;"><ol><li>接受者 Alice 收到后，取下数字签名，同时用 Bob 的公钥解密，得到「摘要1」，<strong>证明确实是 Bob 发的</strong>。*( 画外音：如果使用 Bob 的公钥验证签名出错，那么签名一定不是 Bob 的私钥生成的）*</li><li>再对邮件内容使用相同的散列函数计算「摘要2」，与上面得到的「摘要1」进行对比，<strong>两者一致就说明信息未被篡改。</strong>这样两步分别证明发送者身份和保证数据未被篡改。</li></ol><p><strong>这就够了吗？</strong></p><p>Bob 和 Alice 现在可以依赖于对称加密进行保密通信，也可以依赖于数字签名验证消息是否是对方发送的。<strong>但是这一切的根基是建立在 Alice 持有的公钥确实是 Bob的，反之亦然。</strong></p><p>什么意思呢？</p><p>试想，<strong>Eve 如果将自己的公钥冒充 Bob 发送给 Alice，然后 Alice 保存了下来，那以后凡是 Bob 发送的消息，反而会验证签名失败，被当做冒充者。</strong>那你可能会问，为什么 Eve 可以将自己的公钥发送给 Alice，而 Alice 毫不知情呢？</p><img src="image-20230629200026445.png" alt="image-20230629200026445" style="zoom:33%;"><p>看！我们又回到了最初的起点，只不过这次被篡改的是公钥，之前是消息本身。因为 Bob 的公钥是直接通过网络发送给 Alice的，所以 Eve 才可以在这一步做手脚，进行篡改，将自己的公钥冒充 Bob 发送给 Alice，也就是发送公钥这一步没有做到：</p><ul><li><strong>防篡改</strong></li><li><strong>防冒充</strong></li></ul><p>防篡改怎么和防冒充怎么实现的呢？我们前面讲了，就是靠数字签名！ 但是数字签名需要接受者持有发送者公钥，才能进行验签。<strong>而我们现在处理的是分发公钥这一步，所以…死锁了。这像是先有鸡还是先有蛋的问题。</strong></p><p>现在的问题就是「Bob 无法证明它自己是 Bob」。</p><p>这个是不是似曾相识，以前去办事的时候经常被要求出具「我妈是我妈」这类证明。但是我们自己说“我妈就是我妈”，人家根本不会信呀，需要一个可信第三方出具证明，比如派出所。</p><p>那么「Alice 如何才能确认 Bob 发送给自己的公钥确实是 Bob 的，而没有被篡改？」在只有 Alice 和 Bob 两人的情况下是没法验证的。所以，我们这里也需要一个第三方帮 Bob证明 「Bob 的公钥就是 Bob 的公钥」，有点绕口令那感觉了~</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>为了解决这个问题，就引入了「数字证书」，什么叫数字证书呢？</p><p>百度百科：</p><p>数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。</p><p>因此数字证书又称为数字标识。数字证书对网络用户在交流中的信息和数据等以加密或解密的形式保证了信息和数据的完整性和安全性。</p><p>看了这个描述，是不是感觉还是云里雾里，还是我用大白话来说吧~</p><p><strong>只要你理解了前面的数字签名，就能理解这里的数字证书，因为我把数字证书叫做「<strong><strong>公钥的数字签名</strong></strong>」。</strong></p><p>为什么呢？我们引入数字证书的目的是为了保证公钥不被篡改，即使被篡改了也能识别出来。</p><p>而防篡改的方法就是数字签名，但是这个签名不能我们自己做，原因说过了，因为我们的公钥还没分发出去，别人无法验证。所以只能找可信的第三方来帮我们签名，即证书颁布机构（CA），CA 会将：证书的颁布机构、有效期、公钥、持有者(subject)等信息用 CA 的私钥进行签名。并且将签名结果和这些信息放在一起，这就叫做「数字证书」。</p><p>这样，Bob 就可以去 CA 申请一个证书，然后将自己的证书发给 Alice，那么 Alice 如何验证这个证书确实是 Bob的呢？</p><p>当然是使用 CA 的公钥进行验签。</p><p><strong>注意：</strong></p><p>CA 的公钥也是需要使用证书来分发的，所以 Alice 的电脑必须安装 CA 的证书，证书里包含了 CA 的公钥。</p><p>收到 Bob 发过来的数字证书后，Alice 使用 CA 的公钥进行验证，验证通过即证明这确实是 Bob 证书，也就可以使用证书中包含的 Bob 的公钥，按照之前讨论的流程进行通信。</p><p>那么 Eve 是否可以在中途篡改 Bob 的证书呢？</p><p>答案：不行，因为证书的信息使用 CA 的私钥进行签名，只要 Eve 修改了任何一个 Bit 都会导致最后签名验证不通过。</p><p>那 Eve 可不可以修改证书信息后自己重新计算一次证书的数字签名呢？</p><p>也不行，因为证书的数字签名计算依赖于 CA 的私钥，Eve 是拿不到 CA 的私钥的。</p><p>如果拿到了，说明什么？整个世界都是不可信的。</p><p><strong>数字证书长啥样</strong></p><p>这是我电脑中的自带的证书：</p><img src="image-20230629200113061.png" alt="image-20230629200113061" style="zoom:33%;"><p>可以看到，包含了证书持有人的公钥和证书的签名。另外，证书颁发机构是有层级关系的，下级 CA 的证书是需要由上级 CA 签名的。</p><p>换句话说一定存在根证书颁发机构，那么他们的证书是由谁签名的呢？</p><p>答案是自签，自己给自己认证。</p><p>这是我电脑中的一个自签的根证书颁发机构：</p><img src="image-20230629200156426.png" alt="image-20230629200156426" style="zoom:33%;"><p>为什么根证书可以自签，谁来保证安全？</p><p>你把钱存在银行，你会担心吗？我们基于对国家的信任，才信任银行，这就是信任链的基础！我们思考问题应该是分层的，如果不认可一个统一的基础，一直套娃下去，那么问题就无解。</p><p>那还有个问题，如何保证根证书的可靠性？</p><p>这是操作系统和浏览器预装的，由微软、苹果等操作系统厂商来选择根证书。</p><p><strong>证书不可信？</strong></p><p>那么什么情况下浏览器会提示 “证书不可信” 呢？</p><p>根据我们上面的分析，下面是可能的原因：</p><ul><li>证书不是权威 CA 颁发</li></ul><p>有些企业为了贪图便宜使用盗版的证书，没有经过 CA 认证。也就是无法使用浏览器内置 CA 公钥进行验证。</p><ul><li>证书过期</li></ul><p>上面说了，证书里有一项就是有效期，一般就是一年或者两年的时间。如果证书过期，那么浏览器就会提示“证书不可信”</p><ul><li>证书部署错误</li></ul><p>可能是服务器证书部署出错，比如证书与域名不匹配，因为证书里有一项是持有人信息的。</p><p>好了，饶了一大圈，Bob 终于可以安全的向 Alice 发出前往红树林的邀请了~</p><blockquote><p><strong>QA</strong></p><p>现在我们来回答文章开头提出的一些问题：</p><ol><li><p>非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？</p></li><li><ol><li>加密场景，那么肯定希望只有我才能解密，别人只能加密。即<strong>公钥加密，私钥解密。</strong></li><li>签名场景，既然是签名，就希望只能我才能签名，别人只能验证。即<strong>私钥签名，公钥验签</strong></li></ol></li><li><p>什么是数字签名，数字签名的作用是什么？</p></li><li><ol><li>数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。</li><li>可以起到防篡改、防伪装、防否认的作用。</li></ol></li><li><p>为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？</p></li><li><ol><li>数据可能比较大，签名是使用非对称加密算法，比较耗时。</li><li>防止第三方使用公钥解开签名后，拿到原始数据。</li></ol></li><li><p>什么是数字证书，数字证书存在解决了什么问题？</p></li><li><ol><li>数字证书就是由 CA 机构使用自己私钥，对证书申请者的公钥进行签名认证。</li><li>数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。</li></ol></li></ol></blockquote><hr><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书</a></p><p><a href="https://zhuanlan.zhihu.com/p/469646140">什么是数字签名</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密、签名、数字证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅对接第三方API</title>
      <link href="/maple/2023/06/28/%E4%BC%98%E9%9B%85%E5%AF%B9%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9API/"/>
      <url>/maple/2023/06/28/%E4%BC%98%E9%9B%85%E5%AF%B9%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9API/</url>
      
        <content type="html"><![CDATA[<h1 id="优雅对接第三方API"><a href="#优雅对接第三方API" class="headerlink" title="优雅对接第三方API"></a>优雅对接第三方API</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常的开发中，我们难免会遇见需要和第三方系统进行交互的需求，此时如何设计优雅地对第三方暴露的API就很重要了，不然就可以能会出现接口被刷、数据泄露等安全问题。</p><blockquote><p><strong>非技术对接需要注意的点：</strong></p><ul><li><p>​    与第三方平台对接的时候，一定要积极和谐友善沟通，要是自己沟通不融洽，对自己的开发进度以及整体团队的对接进度就得往后延期了。</p></li><li><p>​    沟通方向要在同个频道，不然可能带来的影响就是：自己写完api文档之后，发给对方之后，发现写得完全就不在方向上，这就很尴尬了。</p></li></ul></blockquote><p><strong>技术对接需要注意的点：</strong></p><p><strong>1. 网络协议方面</strong></p><p>尽量规范对方使用https协议，因为https是http协议的升级版本，可通过对网络浏览器和网络服务器中间传输的数据进行加密，安全性方面还是比http协议高很多的，从谷歌规范来说，也是使用https协议的。</p><p><strong>2.接口请求方面</strong></p><p>接口请求类型看具体业务场景规定好，以及入参的数据类型要规定好，这里如果使用POST请求的时候，基本是规定数据传参格式为：<code>application/json</code> , Json格式的入参可以支持参数值拓展，对于之后的业务迭代还是友好的。</p><p><strong>3.接口签名校验</strong></p><p>对接口的参数进行加密，然后被调用系统可以使用双方规定好的解密方式校验接口的参数是否有效，这样能够大有利的避免许多不必要的麻烦，假如人家知道你的明文参数，拿着这样的数据压测你的接口的话，对系统是能造成极大伤害的，服务器连接数一直在被消耗着。</p><p>在加密解密方面，有对称加密以及非对称加密两种方式。从对比上来说，非对称加密总体安全性比较高，但是效率相对对称加密要低一些。</p><p><strong>4.日志记录</strong></p><p>对于我们接口接收到的数据，以及解析之后的参数值，都要用日志记录下来，以防在线上服务器出问题的时候，我们找不到对应的入参数据去排查线上问题。</p><p><strong>5.幂等校验</strong></p><p>在日常的系统api调用中，会可能由于网络波动等原因，同一个数据会调用多几次接口，我们要在实现具体业务操作之前，加一个幂等校验，例如可以对该数据中的唯一值做记录，要是先查到，就不继续实现具体业务操作，而是返回响应成功（注意：这里幂等校验要查找到该数据已经有成功调用过了，就直接返回响应成功，而不是响应失败等其他提示信息）。</p><p><strong>常见的幂等校验实现方式：</strong></p><ul><li>分布式锁实现并发的幂等校验</li><li>数据库层select实现前置幂等校验</li><li>基于缓存+MD5实现可控时间窗口的幂等校验</li></ul><p><strong>6.重试机制</strong></p><p>比如在电商系统中，由于大促等促销活动有可能随时产生非常大的并发，要这时候要是第三方系统刚好调用我们系统的api接口，我们的服务器刚好短暂宕机，那这可能会造成大量的数据丢失。这中间是涉及到钱的，要真的发生了，可能狗头不保，直接GG。为了保住狗头，还是需要让对方去做接口的重试机制，要是接口响应不成功，可以规定之后一定的频率回调我们的接口，比如每隔3分钟重新发起一次调用，直到累积到10次都不成功，就认为，要是最后一次也是调用不成功的话，基本是要把调用不成功的接口信息落库，存到mysql、redis、或者es等数据源，等事后人工干预。</p><p><strong>7.防伪机制</strong></p><p>为了更安全的系统对接，我们还可以让调用我们接口的第三方，提供多一个接口，去校验一段时间内回传给我们的数据，他们那边是否存在。如果有数据不存在，就要开始排查是不是哪里出问题了~</p><p><strong>8.安全机制</strong></p><p>到了对接的业务上线之后，接口加密的数据有可能是会被不明第三方抓包以及破译的，这时候更加需要从其他方面去提升安全等级，例如：定期更换密钥。除了防住黑的一方，也有白的一方需要防范，白是谁，当然是指我们这些本身开发这块业务的开发者，这个怎么防范，只能提高自己本身的职业素质了</p><hr><h2 id="Java-后端开发常用的-10-种第三方服务"><a href="#Java-后端开发常用的-10-种第三方服务" class="headerlink" title="Java 后端开发常用的 10 种第三方服务"></a><a href="https://www.cnblogs.com/qing-gee/p/13651693.html">Java 后端开发常用的 10 种第三方服务</a></h2><p>严格意义上说，所有软件的第三方服务都可以自己开发，不过从零到一是需要时间和金钱成本的。就像我们研发芯片，投入了巨大的成本，但仍然没有取得理想的成绩，有些事情并不是一朝一夕，投机取巧就能完成的。</p><p>Java 后端开发通常会涉及到很多第三方服务，那么都有哪些成熟的方案可供直接上手使用呢？</p><img src="image-20230628155349797.png" alt="image-20230628155349797" style="zoom:67%;"><p><strong>1）IaaS</strong></p><p>IaaS 的英文全称是 Infrastructure as a Service，即基础设施服务，指把 IT 基础设施作为一种服务通过网络对外提供，并根据用户对资源的实际使用量或占用量进行计费的一种服务模式。IaaS 可根据需求快速纵向扩缩，用户无需购买和管理自己的实体服务器和其他数据中心基础结构，从而避免了相应的开支和复杂操作。</p><p>用户通过 IaaS 可以完成的典型事项包括：</p><ul><li>测试和开发。</li><li>网站托管。</li><li>存储、备份和恢复。</li><li>Web 应用。</li><li>高性能计算。</li><li>大数据分析。</li></ul><p>基本上所有的云服务商都提供了 IaaS 服务，国内最强大的云服务商当属阿里云。</p><p><strong>2）PaaS</strong></p><p>PaaS 的英文全称是 Platform as a Service，只需要提交代码到指定运行环境，代码打包、部署、IP 绑定都由平台完成。与 IaaS 相比，用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。</p><p><strong>3）SaaS</strong></p><p>SaaS 的英文全称是 Software as a Service，用户在这种模式下，不需要经过传统的安装步骤就可以通过网络使用软件。SaaS 最大的特色在于软件本身并没有被下载到用户的硬盘，而是存储在提供商的云端或者服务器。</p><p>怎么区分 IaaS、PaaS 和 SaaS 呢？来看下面这张图。</p><img src="image-20230628155501417.png" alt="image-20230628155501417" style="zoom:67%;"><p>如果我们开发了一个网站，按照传统的方式，我们需要买专业的服务器（连接网络），并在上面安装服务器软件，然后再把编写好的网站部署上去。</p><p>如果采用 IaaS 服务的话，就不需要自己购买服务器了，直接在租用的云服务器上安装服务器软件并且部署网站即可。</p><p>如果采用 PaaS 服务的话，不需要购买服务器，也不需要安装服务器软件，只需要部署网站即可。</p><p>如果采用 SaaS 服务的话，网站也不需要自己开发了，直接使用服务商开发好的网站，后期的升级、维护都交由服务商来负责。</p><p>阮一峰的网络日志上这样解释三者之间的关系。假如你想做披萨生意，有三种方案。</p><p>方案一，IaaS。</p><p>他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。</p><p>方案二，PaaS。</p><p>除了基础设施，他人还提供披萨饼皮。你只需要把自己的配料洒在饼皮上，至于是牛肉味的还是奥尔良鸡翅味的，你来决定。</p><p>方案三，SaaS。</p><p>他人直接做好了披萨，你拿到手就是一个成品。你要做的就是把披萨卖出去，最好印上自己的 Logo。</p><p><strong>4）域名</strong></p><p>有了可以提供服务的应用后，还需要一个能够让人记得住的域名，最好越简单越好。拿维基百科来说，wikipedia.org 是一个域名，和 IP 地址 208.80.152.2 相对应，用户可以直接访问 wikipedia.org 来代替 IP 地址，域名系统（DNS）会将域名转化成便于机器识别的 IP 地址。</p><p><strong>5）CDN</strong></p><p>CDN 的全称是 Content Delivery Network，即<strong>内容分发网络</strong>，一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。比较有名的 CDN 服务商有：</p><ul><li>Cloudflare，提供的免费版解决方案足以保护小网站免受 DDoS 之灾，也可以隐藏网站的真实 IP 地址。在海外有着极好的响应速度，国内好像不咋滴。</li><li>腾讯云，资源储备遍布全球 50+ 国家与地区，全网带宽 120Tbps+。国内 1100+ 加速节点，覆盖移动、联通、电信及十几家中小型运营商。</li><li>阿里云，全球 2800+ 节点，130T 带宽能力，六大洲覆盖，国内主流运营商支持。</li><li>七牛云，全球 2000 节点，20+ 运营商覆盖，访问提速 80%，应用场景包括音视频点播、大文件下载、Web 加速服务等。</li><li>又拍云，全球 1100+ 节点，10Tbps 带宽储备，国内主流运营商支持。</li></ul><p><strong>6）邮件发送</strong></p><p>基本上每个应用都离不开邮件发送，最常用的邮件服务器就是腾讯邮箱和网易邮箱。常用的电子邮件协议包括 SMTP、POP3 和 IMAP，不过，邮件的创建和发送只需要用到 SMTP 协议就可以了。</p><p>Java 官方提供了对电子邮件协议封装的 Java 类库，就是 JavaMail，但并没有包含在标准的 JDK 中，GitHub 地址如下：</p><p><a href="https://javaee.github.io/javamail/">https://javaee.github.io/javamail/</a></p><p>记得之前接到过这样一个需求，要求发送的邮件不能到垃圾邮箱里，还挺难做的。因为邮件服务器，比如说腾讯和网易，都做了邮件的过滤器，会识别一些邮件，自动放到垃圾邮箱里。</p><p><strong>7）短信发送</strong></p><p>使用短信发送验证码几乎是每个应用必不可少的一部分，仿佛手机号码就代表了一个人，所以丢手机是一件非常危险的事情——需要立即挂失。短信是需要运营商支持的，所以基本上都需要依赖第三方代理。市面上有很多短信网关代理，阿里云通信是比较常用的一个，以前叫阿里大于。</p><img src="image-20230628155554996.png" alt="image-20230628155554996" style="zoom:67%;"><p>阿里云通信的价格是每条短信 0.036 元，市面上还有一些其他的服务商，有些价格更低，但稳定性我个人没有测评过。我的技术交流群里就潜藏了不少做短信的商户人员。应用接入阿里云通信并不复杂，我之前在 CSDN 上分享过一个博客，很详细，图文并茂，还带源码实例，需要的小伙伴可以去围观下。</p><p><a href="https://qingmiaogu.blog.csdn.net/article/details/78751698">https://qingmiaogu.blog.csdn.net/article/details/78751698</a></p><p><strong>8）消息推送</strong></p><p>消息推送（Push）指运营人员通过自己的产品或第三方工具对用户移动设备进行的主动消息推送。用户可以在移动设备锁定屏幕和通知栏看到 push 消息通知，通知栏点击可唤起 APP 并去往相应页面。</p><p>移动应用上，推送已经成为一个标配功能。</p><p>iOS 在系统层面与苹果 APNs（Apple Push Notification service）服务器建立连接，应用通过观察者模式向 iOS 系统注册关注的消息，系统收到 APNs Server 消息后转发到相应的应用程序。</p><p>Android 的 C2DM（Android Cloud to Device Messaging）采取与 iOS 类似的机制，都是由系统层面来支持消息推送，但是由于 Google 的服务在国内不能稳定的访问，此方案对于国内用户来说基本是无法使用的。</p><p>鉴于 Android 平台 C2DM 推送的不可用性，国内涌现出大量的第三方推送服务提供商，目前应用最为广泛的第三方推送服务提供商包括个推、极光、友盟、小米、华为、BAT 等，我之前用个推做过一个小程序的推送 Demo，API 调用起来很简单，感觉还挺好用的。</p><p><strong>9）开放平台</strong></p><p>通过开放平台，可以使用 OAuth 等协议获取用户在第三方平台上的信息以实现第三方平台登录。比如用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p><p>国内的微博、微信、QQ 是最常见的第三方登录方式，阿里系的产品可以通过支付宝授权登录，还有一些网站绑定了 GitHub 登录。</p><p>阮一峰的网络日志上有一篇 GitHub OAuth 第三方登录示例教程：</p><p><a href="https://www.ruanyifeng.com/blog/2019/04/github-oauth.html">https://www.ruanyifeng.com/blog/2019/04/github-oauth.html</a></p><p><strong>10）支付接口</strong></p><p>目前，接入最多的支付接口就是支付宝和微信。</p><p>支付宝提供了当面付、APP 支付、手机网站支付、电脑网站支付等支付接口。</p><p>提供的文档很齐全，还有 Java、PHP、.NET 等版本的 Demo。</p><p><a href="https://opendocs.alipay.com/open/270">https://opendocs.alipay.com/open/270</a></p><p>微信支付的话，我推荐使用开源工具库 WxJava：</p><p><a href="https://github.com/Wechat-Group/WxJava">https://github.com/Wechat-Group/WxJava</a></p><p>我们公司的网站就用的这个，支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的后端开发，很齐全。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对接第三方API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/maple/2023/06/27/Threadlocal/"/>
      <url>/maple/2023/06/27/Threadlocal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钩子方法</title>
      <link href="/maple/2023/06/27/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/"/>
      <url>/maple/2023/06/27/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h1><blockquote><p>此处的钩子方法和Runtime类中的钩子线程是两种概念：Runtime.getRuntime( ).addShutdownHook( )</p><p>请参考：<a href="/maple/2023/05/09/Java%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/">JVM钩子</a></p></blockquote><p>钩子方法源于设计模式中<strong>模板方法（Template Method）模式</strong>，模板方法模式的概念为：<strong>在一个方法中定义一个算法骨架，而将一些具体步骤延迟到子类中实现。</strong></p><p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤实现。其方法主要分为两大类：模版方法 和 基本方法，而基本方法又分为：抽象方法（Abstract Method），具体方法（Concrete Method），钩子方法（Hook Method）。</p><p>模板方法模式中的四种方法基本定义（<strong>前提：在抽象类中定义</strong>）：</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>​        定义了一个方法，其中定义了整个逻辑的基本骨架。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​    由抽象类声明，由具体子类实现，并以abstract关键字进行标识。</p><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>​        由抽象类声明并且实现，子类并不做实现和覆盖操作。其实质就是普遍适用的方法，不需要子类来实现。</p><h3 id="钩子方法-1"><a href="#钩子方法-1" class="headerlink" title="钩子方法"></a>钩子方法</h3><p>​        由抽象类声明并且实现，子类也可以选择重写加以扩展。</p><p>通常抽象类会给出一个空实现的钩子方法，也就是没有实现内容的扩展。它和具体方法在代码层面上没有区别，不过是一种意识的区别；它和抽象方法在子类中都需要实现的层面上也没有区别，不同的是抽象方法必须由子类实现，而钩子方法在子类中可以不实现。也就是说钩子方法为开发者在实现某一个抽象类的时候提供了可选项，相当于预先提供了一个默认配置。提供了更大的灵活性，有些抽象类的子类有很多，如果将方法定义成抽象方法，所有的子类都必须要实现，但该方法又不是所有子类都有的行为，如果只在对应的子类中进行具体实现，其他子类进行空实现，这样是可以的，但是无谓的工作量太多。此时就可以考虑使用钩子方法，在需要的子类中进行实现，不需要实现的子类中直接忽略。</p><p>示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类，定义模板方法和基本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体方法,声明并实现，继承此抽象类不需实现此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concreteMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;这是一个具体方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，abstract关键字标识，只声明，不实现，继承此抽象类的子类必须实现此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钩子方法，声明并实现（空实现或者定义相关内容皆可），继承此抽象类的子类可扩展实现或者不实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，整个算法的骨架|场景:如解析所有的配置项,不同类型的配置项的解析方法不同,但是解析的流程是相同的,此时就可以将解析配置</span></span><br><span class="line"><span class="comment">     * 抽象成一个类,将解析流程定义成一个模板方法,其中具体的解析方法由各个子类实现.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        abstractMethod();</span><br><span class="line">        concreteMethod();</span><br><span class="line">        hookMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bond</span><span class="params">(AbstractClass abstractClass)</span> &#123;</span><br><span class="line">        abstractClass.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChildClass</span> <span class="variable">childClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">        childClass.bond(<span class="keyword">new</span> <span class="title class_">AbstractClass</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子类实现父类抽象类中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中的default方法，也是一种钩子方法的思想。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钩子方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok</title>
      <link href="/maple/2023/06/26/Lombok/"/>
      <url>/maple/2023/06/26/Lombok/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lombok简介"><a href="#1-Lombok简介" class="headerlink" title="1. Lombok简介"></a>1. Lombok简介</h2><blockquote><p>官方介绍： Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><p>官网地址：<a href="https://projectlombok.org/">Project Lombok</a></p></blockquote><p>意思：Lombok是一个java库，它可以自动插入编辑器和构建工具中，以提升java性能。不需要另外编写getter或equals方法，使用一个注解，你的类就有一个功能齐全的生成器，自动记录变量，等等。</p><p>简而言之：<strong>Lombok能以简单的注解形式来简化java代码，提高开发人员的效率。</strong></p><h2 id="2-Lombok使用"><a href="#2-Lombok使用" class="headerlink" title="2. Lombok使用"></a>2. Lombok使用</h2><p>使用Lombok需要的开发环境为：<code>Java + Maven + IntelliJ IDEA 或 Eclipse(安装Lombok Plugin)</code></p><h3 id="2-1-添加maven依赖"><a href="#2-1-添加maven依赖" class="headerlink" title="2.1 添加maven依赖"></a>2.1 添加maven依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.4&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-安装插件"><a href="#2-2-安装插件" class="headerlink" title="2.2 安装插件"></a>2.2 安装插件</h3><p>使用Lombok需要插件的配合，使用开发工具为IDEA。打开IDEA的设置，点击<code>Plugins</code>，点击<code>Browse repositories</code>，在弹出的窗口中搜索<code>lombok</code>，然后安装即可。如图：</p><p><img src="r&ynotemdtimestamp=1687769940680-20230626171037196.png" alt="lombok1"></p><h3 id="2-3-解决编译时出错问题"><a href="#2-3-解决编译时出错问题" class="headerlink" title="2.3 解决编译时出错问题"></a>2.3 解决编译时出错问题</h3><p>编译时出错，可能是没有<code>enable</code>注解处理器。<code>Annotation Processors</code>-&gt;<code>Enable annotation processing</code>。设置完成之后程序可正常运行。如图：</p><p><img src="r&ynotemdtimestamp=1687769940680-20230626171037110.png" alt="lombok2"></p><h3 id="2-4-代码示例"><a href="#2-4-代码示例" class="headerlink" title="2.4 代码示例"></a>2.4 代码示例</h3><p>下面举两个栗子，看看使用lombok和不使用的区别。</p><h4 id="2-4-1-创建一个用户类"><a href="#2-4-1-创建一个用户类" class="headerlink" title="2.4.1 创建一个用户类"></a>2.4.1 创建一个用户类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">            <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id, user.id) &amp;&amp;</span><br><span class="line">            Objects.equals(username, user.username) &amp;&amp;</span><br><span class="line">            Objects.equals(age, user.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, username, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-使用Lombok"><a href="#2-4-2-使用Lombok" class="headerlink" title="2.4.2 使用Lombok"></a>2.4.2 使用Lombok</h4><ul><li>@Data注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译得到<code>.class</code>文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="built_in">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                label47: &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">this$id</span> <span class="operator">=</span> <span class="built_in">this</span>.getId();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">other$id</span> <span class="operator">=</span> other.getId();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>$id == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (other$id == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span> label47;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>$id.equals(other$id)) &#123;</span><br><span class="line">                        <span class="keyword">break</span> label47;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">this$username</span> <span class="operator">=</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">other$username</span> <span class="operator">=</span> other.getUsername();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>$username == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$username != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>$username.equals(other$username)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">this$age</span> <span class="operator">=</span> <span class="built_in">this</span>.getAge();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">other$age</span> <span class="operator">=</span> other.getAge();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>$age == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$age != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>$age.equals(other$age)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">canEqual</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> User;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">$id</span> <span class="operator">=</span> <span class="built_in">this</span>.getId();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> result * <span class="number">59</span> + ($id == <span class="literal">null</span> ? <span class="number">43</span> : $id.hashCode());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">$username</span> <span class="operator">=</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">        result = result * <span class="number">59</span> + ($username == <span class="literal">null</span> ? <span class="number">43</span> : $username.hashCode());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">$age</span> <span class="operator">=</span> <span class="built_in">this</span>.getAge();</span><br><span class="line">        result = result * <span class="number">59</span> + ($age == <span class="literal">null</span> ? <span class="number">43</span> : $age.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(id=&quot;</span> + <span class="built_in">this</span>.getId() + <span class="string">&quot;, username=&quot;</span> + <span class="built_in">this</span>.getUsername() + <span class="string">&quot;, age=&quot;</span> + <span class="built_in">this</span>.getAge() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明<code>@Data</code>注解在类上，会为类的所有属性自动生成<code>无参构造器</code>、<code>setter/getter</code> 、<code>equals</code> 、<code>canEqual</code> 、<code>hashCode</code> 、<code>toString</code> 方法。</p><blockquote><p><strong>注意</strong>：如果类中有<code>final</code>修饰的属性，则不会为该属性生成<code>setter</code>方法，其他的方法都会有。因为使用<code>final</code>修饰的属性就是一个不可变属性，所以没有<code>setter</code>方法也是很合理的。</p></blockquote><h4 id="2-4-3-自动生成日志变量"><a href="#2-4-3-自动生成日志变量" class="headerlink" title="2.4.3 自动生成日志变量"></a>2.4.3 自动生成日志变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Maple!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后的<code>.class</code> 文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="comment">// @Slf4j注解生成的Logger日志对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo1_Controller</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/test&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Maple!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译可以看到<code>@Slf4j</code>注解生成了log日志变量（严格意义来说是常量），无需去声明一个log就可以在类中使用log记录日志。</p><h4 id="2-5-常用注解"><a href="#2-5-常用注解" class="headerlink" title="2.5 常用注解"></a>2.5 常用注解</h4><p>常用的几个注解：</p><ul><li><p><strong>@Setter</strong>注解：在类或属性上，注解在类上时表示为所有属性生成setter方法，注解在属性上时只为该属性生成setter方法；</p></li><li><p><strong>@Getter</strong> 注解： 同上，区别在于生成的是getter方法；</p></li><li><p><strong>@ToString</strong> 注解：在类上，添加toString()方法；</p></li><li><p><strong>@EqualsAndHashCode</strong>注解：在类上，生成hashCode()、canEqual()方法和equals()方法；</p></li><li><p><strong>@NoArgsConstructor</strong> 注解：在类上，生成无参的构造方法|无参构造器是默认生成的,即使没有添加任何注解；</p></li><li><p><strong>@RequiredArgsConstructor</strong> 注解：在类上，为类中需要特殊处理的属性生成构造方法，只包含这些属性的专属构造器。比如<code>final</code>和被<code>@NonNull</code>注解的属性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后的结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@NonNull</span></span><br><span class="line">      <span class="keyword">private</span> String username;</span><br><span class="line">      <span class="keyword">private</span> Integer age;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="meta">@NonNull</span> String username)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;username is marked non-null but is null&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.username = username;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，@RequiredArgsConstructor注解并没有为final修饰的属性创建一个专属的构造器，但是为@nonNull注解修饰的属性创建了专属的构造器。</p></li></ul><blockquote><p>可能是由于lombok的版本更新，去除了为final修饰的属性创建专属构造器的功能。</p></blockquote><ul><li><p><strong>@AllArgsConstructor</strong> 注解：在类上，生成包含类中所有属性的有参构造方法,同时会覆盖默认的空参构造器；</p></li><li><p><strong>@Data</strong> 注解：在类上，生成无参构造器、setter( )/getter( )、equals( )、canEqual( )、hashCode( )、toString( )方法，如为final属性，则不会为该属性生成setter方法；</p></li><li><p><strong>@Slf4j</strong> 注解：在类上，自动生成log变量，严格意义来说是常量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UserController.class);</span><br></pre></td></tr></table></figure><p>springboot-1.5.10.Release版本的lombok下使用@Slf4j在编译之后生成的<code>.class</code>文件中生成的日志对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Accessors(chain = true)</strong> 使用链式设置属性，set方法返回的是this对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//使用@Accessors(chain = true)</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">userChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    userChain.setId(<span class="string">&quot;1&quot;</span>).setName(<span class="string">&quot;chain&quot;</span>).setAge(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@UtilityClass:工具类</strong>：使用该注解的类表明是一个工具类,会为类生成私有构造,并将所有的方法都设置为static.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Lombok工作原理"><a href="#3-Lombok工作原理" class="headerlink" title="3. Lombok工作原理"></a>3. Lombok工作原理</h2><p>在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？</p><p>核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。</p><ol><li><p>运行时解析 运行时能够解析的注解，必须将<code>@Retention</code>设置为<code>RUNTIME</code>，这样就可以通过反射拿到该注解。<code>java.lang.reflect</code>反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。</p></li><li><p>编译时解析 编译时解析有两种机制，分别简单描述下：</p><ol><li><p>Annotation Processing Tool</p><p>apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：</p><ul><li>api都在com.sun.mirror非标准包下；</li><li>没有集成到javac中，需要额外运行；</li></ul></li><li><p>Pluggable Annotation Processing API</p><p>JSR 269自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，javac执行的过程如下：</p><p><img src="r&ynotemdtimestamp=1687769940680.png" alt="lombok4"></p></li></ol></li></ol><p>Lombok本质上就是一个实现了“JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p><ol><li>javac对源代码进行分析，生成了一棵抽象语法树（AST）；</li><li>运行过程中调用实现了“JSR 269 API”的Lombok程序；</li><li>此时Lombok就对第一步骤得到的AST进行处理，找到<code>@Data</code>注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter()和setter()方法定义的相应树节点；</li><li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）；</li></ol><p>通过读Lombok源码，发现对应注解的实现都在<code>HandleXXX</code>中，如<code>@Getter</code>注解的实现在<code>HandleGetter.handle()</code>。还有一些其它类库使用这种方式实现，比如Google Auto、Dagger等等。</p><h2 id="4-Lombok的优缺点"><a href="#4-Lombok的优缺点" class="headerlink" title="4. Lombok的优缺点"></a>4. Lombok的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提升了一定的开发效率；</li><li>让代码变得简洁，不用过多的去关注方法实现；</li><li>属性修改时，也简化了维护这些属性所生成的getter/setter方法等；</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>不支持多种参数构造器的重载，即不能灵活地创建只包含部分属性的构造器；</li><li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度；</li></ol><hr><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/ThinkWon/article/details/101392808">Lombok简介、使用、工作原理、优缺点</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分销</title>
      <link href="/maple/2023/06/22/%E5%88%86%E9%94%80/"/>
      <url>/maple/2023/06/22/%E5%88%86%E9%94%80/</url>
      
        <content type="html"><![CDATA[<h1 id="分销"><a href="#分销" class="headerlink" title="分销"></a>分销</h1><h2 id="一、什么是分销"><a href="#一、什么是分销" class="headerlink" title="一、什么是分销"></a>一、什么是分销</h2><p>在西方经济学中，分销的含义是建立销售渠道的意思。分销渠道又叫营销渠道，是指某种商品或服务从生产者向消费者转移的过程中，获取这种商品或服务的所有权，帮助所有权转移的所有企业和个人。</p><p>分销，简单的说，就是让更多的人帮助企业卖货，企业通过<strong>裂变</strong>分销，实现分销渠道裂变从而达到销售商品的目的。企业为了销售商品，主要的任务是把自己的商品销售出去来获取更多的利润。</p><p><img src="T45POTbFsftANN.png" alt="分销系统分解与产品设计"></p><p>传统的销售渠道就是公司招聘销售员，由销售员进行推销产品，另外也会通过互联网进行一些宣传，总而言之一切都是为了把货卖出去。而分销模式是通过分销员向自己身边的朋友以及家人宣传和推广商品并且成交订单，分销员就可以获得一定比例的返佣。</p><img src="T45POU8HUa2wdE.png" alt="分销系统分解与产品设计" style="zoom:70%;"><p>分销的三级代理模式：</p><img src="T45POV3960RFUY.png" alt="分销系统分解与产品设计" style="zoom:70%;"><h2 id="二、分销模式的应用"><a href="#二、分销模式的应用" class="headerlink" title="二、分销模式的应用"></a>二、分销模式的应用</h2><p>分销模式主要是商家在销售商品或服务时，通过其用户的粉丝效应或者朋友交际圈来扩大销售覆盖人群最终实现商品的销售，在电商、保险、信用卡、社区团购较为常见。我们平常在进行商品下单的时候，常需要我们填些推荐码时，或者通过专属的分享链接进行下单，例如我们常见的有淘宝联盟、直播电商平台中主播挂的购物链接等等，这都是属于分销模式。</p><p>分销模式最主要的特点为：<strong>下级的收益按一定比例作为上级的收入，通过该种形式而成为分销体系中的一员，其对于平台的粘性以及积极主动性会更高一些，通过良好的机制能让整个销售团队实现内循环、内增长。</strong></p><h2 id="三、分销模式优点"><a href="#三、分销模式优点" class="headerlink" title="三、分销模式优点"></a>三、分销模式优点</h2><p>分销模式在各行各业都能广泛应用且该模式经久不衰，其主要原因是对于分销模式中各方（品牌方、分销者、终端用户）都有益处。</p><p><strong>1）品牌方</strong></p><p>对于品牌方来说，分销模式在降低成本的同时还能提高营收。随着近年来互联网红利逐渐消退，获客成本逐年升高，在某些行业比如教育或者金融行业的CPS获客成本高达上百甚至上千元。</p><p>而分销模式可利用分销员社交平台的熟人关系链，使得每一个用户都有可能成为品牌方的分销员，在社交关系网的帮助下不断的触达更多的用户，使得用非常低的成本即可完成获客及完单转化。</p><p><strong>2）分销员</strong></p><p>分销员利用自身的社交链通过促成产品的交易实现收入，在其影响力达到一定程度后，可以实现所谓的“躺赚”。也是正因此，分销模式也成为更多人的副业或者家庭主妇的职业选择方向。</p><p><strong>3）终端用户</strong></p><p>当前市场上的商品或服务繁多，用户要想选择一个适合自己的产品，需要花费大量的时间去了解相关的信息，若直接从相熟的人那去购买相关产品，则可以大大减少这其中的决策成本和时间成本，当前带货主播能如此热门也正是因为这个原因。</p><h2 id="四、分销系统的设计"><a href="#四、分销系统的设计" class="headerlink" title="四、分销系统的设计"></a>四、分销系统的设计</h2><p>确定实体及对应的属性：</p><img src="image-20230622120040069.png" alt="image-20230622120040069" style="zoom:67%;"><p>分销模式中有几个重要的产品特点，需要在产品设计中充分考虑：</p><h3 id="1-分销门槛"><a href="#1-分销门槛" class="headerlink" title="1. 分销门槛"></a>1. 分销门槛</h3><p>分销的门槛主要有两种，一种是无条件申请，另一种是需要达到申请条件才能成为分销员。</p><p>对于无条件申请来说，所有人都可以成为分销员，这种方式的优点是：在初期可以快速发展分销员，提高分销裂变的速度；缺点是分销用户筛选不够精准，动力不强。</p><p>对于需要达到一定条件才能申请的模式，类似于需要付费加入或者完成某些特定任务之后才能申请成为分销商。这种方式的优点是：因为用户前期付出了支付成本，会让新用户有动力将付出的钱赚回来，所以一定程度上销售动力会特别强；当然这种方式的缺点是分销员的增长速度相对较慢。</p><h3 id="2-分销关系链"><a href="#2-分销关系链" class="headerlink" title="2. 分销关系链"></a>2. 分销关系链</h3><p>分销关系链主要有两种情况：</p><ul><li>无固定关系：这种方式其实可以理解为一级分销，如下图所示的第一种情况。每个分销员都是独立的，没有上下级关系，彼此之间也没有任何的绑定关系。</li><li>固定关系：类似于下图二级分销和三级分销的情况，分销员之间建立固定的捆绑关系，下一级分销员产生的订单，上级都可以获得一定比例的奖励。</li></ul><img src="T45PP8B94ZXA0R.png" alt="分销系统分解与产品设计" style="zoom:67%;"><h3 id="3-佣金标准"><a href="#3-佣金标准" class="headerlink" title="3. 佣金标准"></a>3. 佣金标准</h3><p>分销模式的佣金标准一般有两个特点，一个是<strong>分段提成</strong>，一个是<strong>跨级提成</strong>。</p><p><strong>1）分段提成</strong></p><p><strong>分销员的成长体系</strong>，当分销员成长为更高等级时，其个人所获得的包括其上级所得到的佣金比例也随之升高。分段提成不仅可以促使分销员自身更有动力成长为高级别的分销员，还能促使其培养更高级别的成员。</p><img src="T45PPjSB0PRHjM.png" alt="分销系统分解与产品设计" style="zoom:67%;"><p><strong>2）跨级提成</strong></p><p>分销员通过直接分享商品获得订单的销售佣金，或者下级成交订单后获得的间接销售佣金，随着其分销员的级别变化而变化。跨级提成一方面可以刺激分销员进行商品销售，激发其销售动力，另一个方面可有利于团队管理者对于团队成员的配置，实现该模式的正向发展。</p><p>这里的跨级指的是分销级数：一级、二级、三级。</p><p>有成交客户之后，平台会按照一级佣金给分销员结算；当存在二级分销时，二级分销员会得到成交客户的一级佣金，而一级分销员会得到成交客户的二级佣金；三级分销也是类似的逻辑。</p><p>通常来说，末尾三级分佣，一级分销商获得佣金最多，因为能直接为商家带来订单，发展一级分销商的二级、三级分销商会获得较低的二级、三级佣金。</p><img src="T45PPkFGHm3Nyf.png" alt="分销系统分解与产品设计" style="zoom:67%;"><p><strong>3）等级权益</strong></p><p>分销员等级以及权益：分销体系的核心诉求是让分销渠道源源不断地产生动力，所以好的分销等级及对应权益的设计可以持续激励分销员，不断提升分销员的积极性，从而不断地为平台拉新或者提升销售额。</p><p>通常的晋升规则是按订单量或成交金额来进行等级划分，对应的等级权益常见的有：分销佣金的奖励比例、额外的返现、特殊商品的分销资格等等。</p><p>高等级的高分销佣金比例，可以不断提升分销员热情和活跃度，让分销员拥有更高的内驱力进行分销。</p><p>同时也可以设计分销员降级规则，在规定的时间内没有完成指定任务则进行相应的惩罚措施，例如降级等，降级规则要谨慎使用，若使用不好有可能降低分销员的积极主动性，具体要看业务在实际过程当中的应用及需要。</p><h2 id="五、分销产品设计"><a href="#五、分销产品设计" class="headerlink" title="五、分销产品设计"></a>五、分销产品设计</h2><p>我们简单列举一下在进行分销产品设计时所涉及到的前端信息架构及后台支撑系统，具体内容就不在此展开了。</p><p>前端应用的使用方主要是分销员，在进行产品设计时我们需要注意做为分销员最的核心模块是什么，一般分销产品的功能模块及信息架构如下：</p><img src="T45PPl666hrVV0.png" alt="分销系统分解与产品设计" style="zoom:67%;"><p>对应的APP架构设计如下：</p><img src="T45PPlZ7NeP6ue.png" alt="分销系统分解与产品设计" style="zoom:90%;"><p>分销后台则支撑着整个分销业务的发展，因此在进行分销建设时需要充分考虑应用场景、便捷性以及高度可拓展性。以下列举了分销系统中的核心模块，具体的模块功能需要根据业务的实际需求来进行产品设计。</p><img src="T45PPmG7E9AE82.png" alt="分销系统分解与产品设计" style="zoom:75%;"><ol><li>分销系统的基本要求易用性：分销系统无论是to B还是to C，面对的都有可能是庞大的客户群，需要在没有任何培训的情况下进行使用,各功能模块区域都要简单易用，清晰明确，使得用户在最短的路径内完成其特定需求。安全性：分销系统的每笔交易、每笔佣金都跟商家、客户的钱是息息相关的，在计算上面不能出错，否则这将给市场及售后带来很大的麻烦。稳定性：由于分销模式伴随着交易的产生，故对业务的稳定性要求较大，且需要考虑多并非对于系统的影响。</li><li>常见的分销系统，如赤焰社群直播分销系统。这是一款基于公众号平台搭建的二级和三级分销商城，通过系统可以设置一级、二级分销模式，设置分销佣金规则，网友注册账号即可成为分销商，拥有自己的分销二维码，通过推广和分享自己的分销二维码来为商城带来订单，从而获得推广佣金。</li></ol><hr><p><strong>参考：</strong></p><ul><li><a href="https://article.autotimes.com.cn/article/124668.html">分销是什么意思 分销模式是什么意思</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分销 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 7」-- 规则配置持久化</title>
      <link href="/maple/2023/06/08/Sentinel7-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/maple/2023/06/08/Sentinel7-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="规则配置持久化"><a href="#规则配置持久化" class="headerlink" title="规则配置持久化"></a>规则配置持久化</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功后可以动态增加各种流控降级规则。Sentinel 提供两种方式修改规则：</p><ul><li>通过 API 直接修改 (<code>loadRules</code>)</li><li>通过 <code>DataSource</code> 适配不同数据源修改</li></ul><p>通过 API 修改比较直观，可以通过以下几个 API 修改不同的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlowRuleManager.loadRules(List&lt;FlowRule&gt; rules); <span class="comment">// 修改流控规则</span></span><br><span class="line">DegradeRuleManager.loadRules(List&lt;DegradeRule&gt; rules); <span class="comment">// 修改降级规则</span></span><br></pre></td></tr></table></figure><p>手动修改规则（硬编码方式）一般仅用于测试和演示，生产上一般通过动态规则源的方式来动态管理规则。</p><h2 id="规则管理模式"><a href="#规则管理模式" class="headerlink" title="规则管理模式"></a>规则管理模式</h2><p>Sentinel的控制台规则管理有三种模式：Sentinel的规则默认是保存在内存中，Sentinel重启之后规则就会丢失</p><table><thead><tr><th><strong>推送模式</strong></th><th><strong>说明</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">原始模式</a></td><td>API 将规则推送至客户端并直接更新到内存中，扩展写数据源（<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">WritableDataSource</a>），默认就是这种</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境</td></tr><tr><td>[Pull <a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">模式</a></td><td>扩展写数据源（<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">WritableDataSource</a>），  客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件 等</td><td>简单，无任何依赖；规则持久化</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。</td></tr><tr><td><strong><a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">Push</a></strong><a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">模式</a></td><td>扩展读数据源（<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">ReadableDataSource</a>），规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用  Nacos、Zookeeper  等配置中心。这种方式有更好的实时性和一致性保证。<strong>生产环境下一般采用</strong>  <strong>push</strong>  <strong>模式的数据源。</strong></td><td>规则持久化；一致性；</td><td>引入第三方依赖</td></tr></tbody></table><h3 id="原始模式"><a href="#原始模式" class="headerlink" title="原始模式"></a>原始模式</h3><p>控制台配置的规则直接推送到Sentinel客户端，也就是我们的应用。然后保存在内存中，服务重启则丢失。</p><img src="image-20230609154151569.png" alt="image-20230609154151569" style="zoom: 50%;"><h3 id="Pull模式"><a href="#Pull模式" class="headerlink" title="Pull模式"></a>Pull模式</h3><p>实现拉模式的数据源最简单的方式是继承 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AutoRefreshDataSource.java"><code>AutoRefreshDataSource</code></a> 抽象类，然后实现 <code>readSource()</code> 方法，在该方法里从指定数据源读取字符串格式的配置数据。比如 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-dynamic-file-rule/src/main/java/com/alibaba/csp/sentinel/demo/file/rule/FileDataSourceDemo.java">基于文件的数据源</a>。</p><p>控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p><img src="image-20230609154244371.png" alt="image-20230609154244371" style="zoom:50%;"><h3 id="Push模式"><a href="#Push模式" class="headerlink" title="Push模式"></a>Push模式</h3><p>实现推模式的数据源最简单的方式是继承 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AbstractDataSource.java"><code>AbstractDataSource</code></a> 抽象类，在其构造方法中添加监听器，并实现 <code>readSource()</code> 从指定数据源读取字符串格式的配置数据。比如 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-nacos-datasource/src/main/java/com/alibaba/csp/sentinel/demo/datasource/nacos/NacosDataSourceDemo.java">基于 Nacos 的数据源</a>。</p><p>控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。</p><p>常见的有两种玩法：</p><ul><li><strong>sentinel-core + sentinel-datasource-nacos（规则配置中心）</strong><ul><li>直接在Nacos界面配置Sentinel规则配置文件，在使用Sentinel的应用中自定义Nacos监听器对Nacos配置文件变更进行监听并进行解析和loadRule进行限流降级，实现Sentinel的规则持久化操作。</li></ul></li><li><strong>sentinel-dashboard（控制台） + sentinel-datasource-nacos（规则配置中心）</strong><ul><li>结合sentinel-dashboard可视化UI，在sentinel-dashboard中配置的规则直接push到Nacos中，然后使用Sentinel的应用中监听Nacos的配置文件的变更，并进行loadRule操作实现限流降级。</li><li>需要对Sentinel-Dashboard的源码进行二次开发。</li></ul></li></ul><p>我们推荐<strong>通过控制台设置规则后将规则推送到统一的规则中心，客户端实现</strong> <code>ReadableDataSource</code> <strong>接口端监听规则中心实时获取变更</strong>，流程如下：</p><img src="45406233-645e8380-b698-11e8-8199-0c917403238f.png" alt="push-rules-from-dashboard-to-config-center" style="zoom: 50%;"><blockquote><p>Sentinel 目前支持以下数据源扩展：</p><ul><li>Pull-based: 动态文件数据源、<a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-consul">Consul</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-eureka">Eureka</a></li><li>Push-based: <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-zookeeper">ZooKeeper</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-redis">Redis</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-nacos">Nacos</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-apollo">Apollo</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-etcd">etcd</a></li></ul></blockquote><h3 id="注册数据源"><a href="#注册数据源" class="headerlink" title="注册数据源"></a>注册数据源</h3><p>通常需要调用以下方法将数据源注册至指定的规则管理器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="keyword">new</span> <span class="title class_">NacosDataSource</span>&lt;&gt;(remoteAddress, groupId, dataId, parser);</span><br><span class="line">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure><p>若不希望手动注册数据源，可以借助 Sentinel 的 <code>InitFunc</code> SPI 扩展接口。只需要实现自己的 <code>InitFunc</code> 接口，在 <code>init</code> 方法中编写注册数据源的逻辑。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.init;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceInitFunc</span> <span class="keyword">implements</span> <span class="title class_">InitFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">remoteAddress</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">groupId</span> <span class="operator">=</span> <span class="string">&quot;Sentinel:Demo&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;com.alibaba.csp.sentinel.demo.flow.rule&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="keyword">new</span> <span class="title class_">NacosDataSource</span>&lt;&gt;(remoteAddress, groupId, dataId,</span><br><span class="line">            source -&gt; JSON.parseObject(source, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class="line">        FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将对应的类名添加到位于资源目录（通常是 <code>resource</code> 目录）下的 <code>META-INF/services</code> 目录下的 <code>com.alibaba.csp.sentinel.init.InitFunc</code> 文件中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.test.init.DataSourceInitFunc</span><br></pre></td></tr></table></figure><p>这样，当初次访问任意资源的时候，Sentinel 就可以自动去注册对应的数据源了。</p><h3 id="sentinel-core-sentinel-datasource-nacos（规则配置中心）"><a href="#sentinel-core-sentinel-datasource-nacos（规则配置中心）" class="headerlink" title="sentinel-core + sentinel-datasource-nacos（规则配置中心）"></a>sentinel-core + sentinel-datasource-nacos（规则配置中心）</h3><p>示例：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/tree/master/sentinel-demo/sentinel-demo-nacos-datasource">sentinel-demo-nacos-datasource</a></p><h3 id="sentinel-dashboard（控制台）-sentinel-datasource-nacos（规则配置中心）"><a href="#sentinel-dashboard（控制台）-sentinel-datasource-nacos（规则配置中心）" class="headerlink" title="sentinel-dashboard（控制台） + sentinel-datasource-nacos（规则配置中心）"></a>sentinel-dashboard（控制台） + sentinel-datasource-nacos（规则配置中心）</h3><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/dynamic-rule-configuration.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 6」-- 系统自适应保护 &amp; 来源控制</title>
      <link href="/maple/2023/06/07/Sentinel6-%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%9D%E6%8A%A4/"/>
      <url>/maple/2023/06/07/Sentinel6-%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="系统自适应保护"><a href="#系统自适应保护" class="headerlink" title="系统自适应保护"></a>系统自适应保护</h1><p>Sentinel 系统自适应保护从整体维度对应用入口流量进行控制，结合应用的 Load、总体平均 RT、入口 QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开始之前，先回顾一下 Sentinel 做系统自适应保护的目的：</p><ul><li>保证系统不被拖垮</li><li>在系统稳定的前提下，保持系统的吞吐量</li></ul><p>长期以来，系统自适应保护的思路是根据硬指标，即系统的负载 (load1) 来做系统过载保护。当系统负载高于某个阈值，就禁止或者减少流量的进入；当 load 开始好转，则恢复流量的进入。这个思路给我们带来了不可避免的两个问题：</p><ul><li>load 是一个“果”，如果根据 load 的情况来调节流量的通过率，那么就始终有延迟性。也就意味着通过率的任何调整，都会过一段时间才能看到效果。当前通过率是使 load 恶化的一个动作，那么也至少要过 1 秒之后才能观测到；同理，如果当前通过率调整是让 load 好转的一个动作，也需要 1 秒之后才能继续调整，这样就浪费了系统的处理能力。所以我们看到的曲线，总是会有抖动。</li><li>恢复慢。想象一下这样的一个场景（真实），出现了这样一个问题，下游应用不可靠，导致应用 RT 很高，从而 load 到了一个很高的点。过了一段时间之后下游应用恢复了，应用 RT 也相应减少。这个时候，其实应该大幅度增大流量的通过率；但是由于这个时候 load 仍然很高，通过率的恢复仍然不高。</li></ul><p><a href="https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_BBR">TCP BBR</a> 的思想给了我们一个很大的启发。我们应该根据系统能够处理的请求，和允许进来的请求，来做平衡，而不是根据一个间接的指标（系统 load）来做限流。最终我们追求的目标是 <strong>在系统不被拖垮的情况下，提高系统的吞吐率，而不是 load 一定要到低于某个阈值</strong>。如果我们还是按照固有的思维，超过特定的 load 就禁止流量进入，系统 load 恢复就放开流量，这样做的结果是无论我们怎么调参数，调比例，都是按照果来调节因，都无法取得良好的效果。</p><p>Sentinel 在系统自适应保护的做法是，用 load1 作为启动控制流量的值，而允许通过的流量由处理请求的能力，即请求的响应时间以及当前系统正在处理的请求速率来决定。</p><h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 和线程数四个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的阈值类型：</p><ul><li><strong>Load</strong>（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 <code>maxQps * minRt</code> 计算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0）。</li><li><strong>RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先用经典图来镇楼:</p><p><img src="50813887-bff10300-1352-11e9-9201-437afea60a5a.png" alt="TCP-BBR-pipe"></p><p>我们把系统处理请求的过程想象为一个水管，到来的请求是往这个水管灌水，当系统处理顺畅的时候，请求不需要排队，直接从水管中穿过，这个请求的RT是最短的；反之，当请求堆积的时候，那么处理请求的时间则会变为：排队时间 + 最短处理时间。</p><ul><li>推论一: 如果我们能够保证水管里的水量，能够让水顺畅的流动，则不会增加排队的请求；也就是说，这个时候的系统负载不会进一步恶化。</li></ul><p>我们用 T 来表示(水管内部的水量)，用RT来表示请求的处理时间，用P来表示进来的请求数，那么一个请求从进入水管道到从水管出来，这个水管会存在 <code>P * RT</code>　个请求。换一句话来说，当 <code>T ≈ QPS * Avg(RT)</code> 的时候，我们可以认为系统的处理能力和允许进入的请求个数达到了平衡，系统的负载不会进一步恶化。</p><p>接下来的问题是，水管的水位是可以达到了一个平衡点，但是这个平衡点只能保证水管的水位不再继续增高，但是还面临一个问题，就是在达到平衡点之前，这个水管里已经堆积了多少水。如果之前水管的水已经在一个量级了，那么这个时候系统允许通过的水量可能只能缓慢通过，RT会大，之前堆积在水管里的水会滞留；反之，如果之前的水管水位偏低，那么又会浪费了系统的处理能力。</p><ul><li>推论二:　当保持入口的流量使水管出来的流量达到最大值的时候，可以最大利用水管的处理能力。</li></ul><p>然而，和 TCP BBR 的不一样的地方在于，还需要用一个系统负载的值（load1）来激发这套机制启动。</p><blockquote><p>注：这种系统自适应算法对于低 load 的请求，它的效果是一个“兜底”的角色。<strong>对于不是应用本身造成的 load 高的情况（如其它进程导致的不稳定的情况），效果不明显。</strong></p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们提供了系统自适应限流的示例：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/system/SystemGuardDemo.java">SystemGuardDemo</a>。</p><h1 id="来源访问控制（黑白名单）"><a href="#来源访问控制（黑白名单）" class="headerlink" title="来源访问控制（黑白名单）"></a>来源访问控制（黑白名单）</h1><p>很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的黑白名单控制的功能。黑白名单根据资源的请求来源（<code>origin</code>）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p><blockquote><p>调用方信息通过 <code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数传入。</p></blockquote><h2 id="规则配置"><a href="#规则配置" class="headerlink" title="规则配置"></a>规则配置</h2><p>黑白名单规则（<code>AuthorityRule</code>）非常简单，主要有以下配置项：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>limitApp</code>：对应的黑名单/白名单，不同 origin 用 <code>,</code> 分隔，如 <code>appA,appB</code></li><li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>比如我们希望控制对资源 <code>test</code> 的访问设置白名单，只有来源为 <code>appA</code> 和 <code>appB</code> 的请求才可通过，则可以配置如下白名单规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AuthorityRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorityRule</span>();</span><br><span class="line">rule.setResource(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">rule.setStrategy(RuleConstant.AUTHORITY_WHITE);</span><br><span class="line">rule.setLimitApp(<span class="string">&quot;appA,appB&quot;</span>);</span><br><span class="line">AuthorityRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure><p>详细示例请参考 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/authority/AuthorityDemo.java">AuthorityDemo</a>.</p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 5」-- 熔断降级</title>
      <link href="/maple/2023/06/07/Sentinel5-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
      <url>/maple/2023/06/07/Sentinel5-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><img src="62410811-cd871680-b61d-11e9-9df7-3ee41c618644.png" alt="chain" style="zoom:50%;"><p>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p><blockquote><p><strong>注意</strong>：本文档针对 Sentinel 1.8.0 及以上版本。1.8.0 版本对熔断降级特性进行了全新的改进升级，请使用最新版本以更好地利用熔断降级的能力。</p></blockquote><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>Sentinel 提供以下几种熔断策略：</p><ul><li>**慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)**：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li><li>**异常比例 (<code>ERROR_RATIO</code>)**：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li><li>**异常数 (<code>ERROR_COUNT</code>)**：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li></ul><p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  entry = SphU.entry(resource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write your biz code here.</span></span><br><span class="line">  <span class="comment">// &lt;&lt;BIZ CODE&gt;&gt;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开源整合模块，如 Sentinel Dubbo Adapter, Sentinel Web Servlet Filter 或 <code>@SentinelResource</code> 注解会自动统计业务异常，无需手动调用。</p><h2 id="熔断降级规则说明"><a href="#熔断降级规则说明" class="headerlink" title="熔断降级规则说明"></a>熔断降级规则说明</h2><p>熔断降级规则（DegradeRule）包含下面几个重要的属性：</p><table><thead><tr><th align="center">Field</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，即规则的作用对象</td><td align="left"></td></tr><tr><td align="center">grade</td><td align="left">熔断策略，支持慢调用比例/异常比例/异常数策略</td><td align="left">慢调用比例</td></tr><tr><td align="center">count</td><td align="left">慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值</td><td align="left"></td></tr><tr><td align="center">timeWindow</td><td align="left">熔断时长，单位为 s</td><td align="left"></td></tr><tr><td align="center">minRequestAmount</td><td align="left">熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td><td align="left">5</td></tr><tr><td align="center">statIntervalMs</td><td align="left">统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td><td align="left">1000 ms</td></tr><tr><td align="center">slowRatioThreshold</td><td align="left">慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td><td align="left"></td></tr></tbody></table><h2 id="熔断器事件监听"><a href="#熔断器事件监听" class="headerlink" title="熔断器事件监听"></a>熔断器事件监听</h2><p>Sentinel 支持注册自定义的事件监听器监听熔断器状态变换事件（state change event）。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EventObserverRegistry.getInstance().addStateChangeObserver(<span class="string">&quot;logging&quot;</span>,</span><br><span class="line">    (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (newState == State.OPEN) &#123;</span><br><span class="line">            <span class="comment">// 变换至 OPEN state 时会携带触发时的值</span></span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;%s -&gt; OPEN at %d, snapshotValue=%.2f&quot;</span>, prevState.name(),</span><br><span class="line">                TimeUtil.currentTimeMillis(), snapshotValue));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;%s -&gt; %s at %d&quot;</span>, prevState.name(), newState.name(),</span><br><span class="line">                TimeUtil.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>慢调用比例熔断示例：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/degrade/SlowRatioCircuitBreakerDemo.java">SlowRatioCircuitBreakerDemo</a></p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 4」-- 热点参数限流</title>
      <link href="/maple/2023/06/07/Sentinel4-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/"/>
      <url>/maple/2023/06/07/Sentinel4-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h1><h2 id="热点参数规则"><a href="#热点参数规则" class="headerlink" title="热点参数规则"></a>热点参数规则</h2><p>热点参数规则（<code>ParamFlowRule</code>）类似于流量控制规则（<code>FlowRule</code>）：</p><table><thead><tr><th align="center">属性</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，必填</td><td align="left"></td></tr><tr><td align="center">count</td><td align="left">限流阈值，必填</td><td align="left"></td></tr><tr><td align="center">grade</td><td align="left">限流模式</td><td align="left">QPS 模式</td></tr><tr><td align="center">durationInSec</td><td align="left">统计窗口时间长度（单位为秒），1.6.0 版本开始支持</td><td align="left">1s</td></tr><tr><td align="center">controlBehavior</td><td align="left">流控效果（支持快速失败和匀速排队模式），1.6.0 版本开始支持</td><td align="left">快速失败</td></tr><tr><td align="center">maxQueueingTimeMs</td><td align="left">最大排队等待时长（仅在匀速排队模式生效），1.6.0 版本开始支持</td><td align="left">0ms</td></tr><tr><td align="center">paramIdx</td><td align="left">热点参数的索引，必填，对应 <code>SphU.entry(xxx, args)</code> 中的参数索引位置</td><td align="left"></td></tr><tr><td align="center">paramFlowItemList</td><td align="left">参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 <code>count</code> 阈值的限制。<strong>仅支持基本类型和字符串类型</strong></td><td align="left"></td></tr><tr><td align="center">clusterMode</td><td align="left">是否是集群参数流控规则</td><td align="left"><code>false</code></td></tr><tr><td align="center">clusterConfig</td><td align="left">集群流控相关配置</td><td align="left"></td></tr></tbody></table><p>我们可以通过 <code>ParamFlowRuleManager</code> 的 <code>loadRules</code> 方法更新热点参数规则，下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ParamFlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowRule</span>(resourceName)</span><br><span class="line">    .setParamIdx(<span class="number">0</span>)</span><br><span class="line">    .setCount(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 针对 int 类型的参数 PARAM_B，单独设置限流 QPS 阈值为 10，而不是全局的阈值 5.</span></span><br><span class="line"><span class="type">ParamFlowItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowItem</span>().setObject(String.valueOf(PARAM_B))</span><br><span class="line">    .setClassType(<span class="type">int</span>.class.getName())</span><br><span class="line">    .setCount(<span class="number">10</span>);</span><br><span class="line">rule.setParamFlowItemList(Collections.singletonList(item));</span><br><span class="line"></span><br><span class="line">ParamFlowRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure><h2 id="热点限流"><a href="#热点限流" class="headerlink" title="热点限流"></a>热点限流</h2><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><img src="sentinel-hot-param-overview-1.png" alt="Sentinel Parameter Flow Control" style="zoom: 50%;"><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要使用热点参数限流功能，需要引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-parameter-flow-control<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后为对应的资源配置热点参数限流规则，并在 <code>entry</code> 的时候传入相应的参数，即可使热点参数限流生效。</p><blockquote><p>注：若自行扩展并注册了自己实现的 <code>SlotChainBuilder</code>，并希望使用热点参数限流功能，则可以在 chain 里面合适的地方插入 <code>ParamFlowSlot</code>。</p></blockquote><p>那么如何传入对应的参数以便 Sentinel 统计呢？我们可以通过 <code>SphU</code> 类里面几个 <code>entry</code> 重载方法来传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">entry</span><span class="params">(String name, EntryType type, <span class="type">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">entry</span><span class="params">(Method method, EntryType type, <span class="type">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException</span><br></pre></td></tr></table></figure><p>其中最后的一串 <code>args</code> 就是要传入的参数，有多个就按照次序依次传入。比如要传入两个参数 <code>paramA</code> 和 <code>paramB</code>，则可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paramA in index 0, paramB in index 1.</span></span><br><span class="line"><span class="comment">// 若需要配置例外项或者使用集群维度流控，则传入的参数只支持基本类型。</span></span><br><span class="line">SphU.entry(resourceName, EntryType.IN, <span class="number">1</span>, paramA, paramB);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。正确的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    entry = SphU.entry(resourceName, EntryType.IN, <span class="number">1</span>, paramA, paramB);</span><br><span class="line">    <span class="comment">// Your logic here.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">    <span class="comment">// Handle request rejection.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">        entry.exit(<span class="number">1</span>, paramA, paramB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>@SentinelResource</code> 注解方式定义的资源，若注解作用的方法上有参数，Sentinel 会将它们作为参数传入 <code>SphU.entry(res, args)</code>。比如以下的方法里面 <code>uid</code> 和 <code>type</code> 会分别作为第一个和第二个参数传入 Sentinel API，从而可以用于热点规则判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;myMethod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">doSomething</span><span class="params">(String uid, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">  <span class="comment">// some logic here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sentinel-Dashboard热点限流配置"><a href="#Sentinel-Dashboard热点限流配置" class="headerlink" title="Sentinel-Dashboard热点限流配置"></a>Sentinel-Dashboard热点限流配置</h2><h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h3><p><strong>热点参数限流对默认的SpringMVC的Controller层资源无效，如果需要使用热点规则，需要使用 <code>@SentileResource</code> 注解进行单独标识。</strong></p><p>热点参数限流是分别统计参数值相同的请求数，判断是否超过QPS阈值。</p><img src="dashboard12.png" style="zoom:50%;"><p>如上图，有请求<code>goods/&#123;id&#125;</code>的资源，其中id是热点参数，其值有两种 1,3；如果需要对请求参数<code>id=1</code>进行限流，则需要进行热点参数限流：</p><img src="dashboard13.png" style="zoom: 33%;"><p>在热点参数限流的高级选项中，可以对部分参数进行<font color="green">例外配置</font>：</p><img src="dashboard14.png" style="zoom:33%;"><p>结合上一个配置，<strong>这里的含义是对索引值为0号（即请求资源时的第一个参数）的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：</strong></p><ul><li><strong>如果参数值是100，则每1秒允许的QPS为10；</strong></li><li><strong>如果参数值是101，则每1秒允许的QPS为10；</strong></li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 3 」-- 流量控制&amp;规则</title>
      <link href="/maple/2023/06/07/Sentinel3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/maple/2023/06/07/Sentinel3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="流量控制-amp-规则"><a href="#流量控制-amp-规则" class="headerlink" title="流量控制&amp;规则"></a>流量控制&amp;规则</h1><h2 id="流量控制规则-FlowRule"><a href="#流量控制规则-FlowRule" class="headerlink" title="流量控制规则 (FlowRule)"></a>流量控制规则 (FlowRule)</h2><h3 id="流量规则的定义"><a href="#流量规则的定义" class="headerlink" title="流量规则的定义"></a>流量规则的定义</h3><p>重要属性：</p><table><thead><tr><th align="center">Field</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，资源名是限流规则的作用对象</td><td align="left"></td></tr><tr><td align="center">count</td><td align="left">限流阈值</td><td align="left"></td></tr><tr><td align="center">grade</td><td align="left">限流阈值类型，QPS 或线程数模式</td><td align="left">QPS 模式</td></tr><tr><td align="center">limitApp</td><td align="left">流控针对的调用来源</td><td align="left"><code>default</code>，代表不区分调用来源</td></tr><tr><td align="center">strategy</td><td align="left">调用关系限流策略：直接、链路、关联</td><td align="left">根据资源本身（直接）</td></tr><tr><td align="center">controlBehavior</td><td align="left">流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流</td><td align="left">直接拒绝</td></tr></tbody></table><p>同一个资源可以同时有多个限流规则。</p><h3 id="通过代码定义流量控制规则"><a href="#通过代码定义流量控制规则" class="headerlink" title="通过代码定义流量控制规则"></a>通过代码定义流量控制规则</h3><p>理解上面规则的定义之后，我们可以通过调用 <code>FlowRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFlowQpsRule</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">FlowRule</span> <span class="variable">rule1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">    rule1.setResource(resource);</span><br><span class="line">    <span class="comment">// Set max qps to 20</span></span><br><span class="line">    rule1.setCount(<span class="number">20</span>);</span><br><span class="line">    rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule1.setLimitApp(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    rules.add(rule1);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>: 限流阈值</li><li><code>grade</code>: 限流阈值类型，QPS 或线程数</li><li><code>strategy</code>: 根据调用关系选择策略</li></ul><h3 id="基于QPS-并发数的流量控制"><a href="#基于QPS-并发数的流量控制" class="headerlink" title="基于QPS/并发数的流量控制"></a>基于QPS/并发数的流量控制</h3><p>流量控制主要有两种统计类型，一种是统计线程数，另外一种则是统计 QPS。类型由 <code>FlowRule.grade</code> 字段来定义。其中，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。其中线程数、QPS 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p><p>可以通过下面的命令查看实时统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8719/cnode?id=resourceName</span><br></pre></td></tr></table></figure><p>输出内容格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx id   thread  pass  blocked   success  total Rt   1m-pass   1m-block   1m-all   exeption</span><br><span class="line">2   abc647 0     46     0           46     46   1       2763      0         2763     0</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>thread： 代表当前处理该资源的线程数；</li><li>pass： 代表一秒内到来到的请求；</li><li>blocked： 代表一秒内被流量控制的请求数量；</li><li>success： 代表一秒内成功处理完的请求；</li><li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li><li>RT： 代表一秒内该资源的平均响应时间；</li><li>1m-pass： 则是一分钟内到来的请求；</li><li>1m-block： 则是一分钟内被阻止的请求；</li><li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li><li>exception： 则是一秒内业务本身异常的总和。</li></ul><h4 id="2-1-并发线程数流量控制"><a href="#2-1-并发线程数流量控制" class="headerlink" title="2.1 并发线程数流量控制"></a>2.1 并发线程数流量控制</h4><p>线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）。这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。例子参见：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/FlowThreadDemo.java">ThreadDemo</a></p><h4 id="2-2-QPS流量控制"><a href="#2-2-QPS流量控制" class="headerlink" title="2.2 QPS流量控制"></a>2.2 QPS流量控制</h4><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p><ul><li><p>直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/FlowQpsDemo.java">FlowqpsDemo</a>。</p></li><li><p>冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。具体的例子参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/WarmUpFlowDemo.java">WarmUpFlowDemo</a>。</p><p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p></li></ul><img src="warmup.gif" alt="冷启动过程 QPS 曲线" style="zoom:67%;"><ul><li><p>匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。具体的例子参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/PaceFlowDemo.java">PaceFlowDemo</a>。</p><p>该方式的作用如下图所示：</p></li></ul><img src="queue.gif" alt="img" style="zoom: 40%;"><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><h3 id="基于调用关系的流量控制"><a href="#基于调用关系的流量控制" class="headerlink" title="基于调用关系的流量控制"></a>基于调用关系的流量控制</h3><p>调用关系包括调用方、被调用方；方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterNodeBuilderSlot</code> 记录每个资源的实时统计信息。</p><p>有了调用链路的统计信息，我们可以衍生出多种流量控制手段。</p><h4 id="3-1-根据调用方限流"><a href="#3-1-根据调用方限流" class="headerlink" title="3.1 根据调用方限流"></a>3.1 根据调用方限流</h4><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8719/origin?id=nodeA</span><br></pre></td></tr></table></figure><p>调用数据示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: nodeA</span><br><span class="line">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class="line">1   caller1 0         0         0          0        0     0         0          0</span><br><span class="line">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure><p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p><p>限流规则中的 <code>limitApp</code> 字段用于根据调用方进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p><ul><li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li><li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li><li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li></ul><p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name} &gt; other &gt; default**</p><h4 id="3-2-根据调用链路入口限流：链路限流"><a href="#3-2-根据调用链路入口限流：链路限流" class="headerlink" title="3.2 根据调用链路入口限流：链路限流"></a>3.2 根据调用链路入口限流：链路限流</h4><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p><p>一棵典型的调用树如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          machine-root</span><br><span class="line">              /       \</span><br><span class="line">             /         \</span><br><span class="line">       Entrance1     Entrance2</span><br><span class="line">          /             \</span><br><span class="line">         /               \</span><br><span class="line">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure><p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.CHAIN</code>，同时设置 <code>FlowRule.ref_identity</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而对来自 <code>Entrance2</code> 的调用漠不关心。</p><p>调用链的入口是通过 API 方法 <code>ContextUtil.enter(name)</code> 定义的。</p><h4 id="3-3-具有关系的资源流量控制：关联流量控制"><a href="#3-3-具有关系的资源流量控制：关联流量控制" class="headerlink" title="3.3 具有关系的资源流量控制：关联流量控制"></a>3.3 具有关系的资源流量控制：关联流量控制</h4><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.RELATE</code> 同时设置 <code>FlowRule.ref_identity</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流。</p><h2 id="开发中使用"><a href="#开发中使用" class="headerlink" title="开发中使用"></a>开发中使用</h2><p>在实际的开发中，常见的是在servlet的Filter层嵌入Sentinel流控。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphO;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Tracer;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.maple.sentinecore.errorcode.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在仅导入Sentinel-Core依赖的场景下,使用Sentinel API自定义目标资源.</span></span><br><span class="line"><span class="comment"> * 在使用Spring-Cloud和Sentinel的整合包时,默认Controller层的所有URL自动注册为Sentinel的资源,不需要手动进行注册.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 类型强转</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求的uri地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> httpServletRequest.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;客户端请求|url:[&#123;&#125;]&quot;</span>, uri);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端请求|url:&quot;</span> + uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置限流规则</span></span><br><span class="line">        initFlowRules(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行限流</span></span><br><span class="line">        <span class="comment">// flowControlWithException(uri);</span></span><br><span class="line">        flowControlWithBoolean(uri, httpServletResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续执行过滤器链</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义注册Sentinel监控的目标资源.</span></span><br><span class="line"><span class="comment">     * 抛出异常的方式定义资源.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flowControlWithException</span><span class="params">(String uri)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将目标uri定义为资源,对其进行限流</span></span><br><span class="line">            entry = SphU.entry(uri);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为Sentinel的流控降级异常</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">blockException</span> <span class="operator">=</span> BlockException.isBlockException(throwable);</span><br><span class="line">            <span class="keyword">if</span> (blockException) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[flowControlWithException]|执行限流拦截策略...&quot;</span>);</span><br><span class="line">                log.error(<span class="string">&quot;[flowControlWithException]|Sentinel触发限流异常|e:&quot;</span>, throwable);</span><br><span class="line">                <span class="comment">// Maple TODO | 2023/5/11 : 执行限流拦截策略</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 业务异常</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动调用Tracer.trace(throwable)来记录业务异常,否则对应的业务异常不会统计到Sentinel的异常计数中.</span></span><br><span class="line">                <span class="comment">// 这样会导致如果使用异常数来进行熔断降级时会导致异常数统计不准.</span></span><br><span class="line">                Tracer.trace(throwable); <span class="comment">// 追踪业务异常,便于StatisticsSlot进行业务异常数统计.</span></span><br><span class="line">                log.error(<span class="string">&quot;[flowControlWithException]|SystemException&quot;</span>);</span><br><span class="line">                <span class="comment">// Maple TODO | 2023/5/15 : 系统异常处理</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放Sentinel的资源</span></span><br><span class="line">                <span class="comment">// SphU.entry(xxx) 需要与 entry.exit() 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 ErrorEntryFreeException 异常。</span></span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义注册Sentinel监控的目标资源.</span></span><br><span class="line"><span class="comment">     * 返回布尔值方式定义资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flowControlWithBoolean</span><span class="params">(String uri, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> SphO.entry(uri);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 目标资源通过限流控制,正常处理业务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Maple TODO | 2023/6/1 : 业务处理</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// finally必须要执行</span></span><br><span class="line">                SphO.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 资源访被阻止,被限流或者降级</span></span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;[flowControlWithBoolean]|执行限流拦截策略...&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;[flowControlWithBoolean]|Sentinel触发限流&quot;</span>);</span><br><span class="line">            <span class="comment">// Maple TODO | 2023/6/1 : 拦截处理</span></span><br><span class="line"></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            <span class="type">byte</span>[] bytes = ErrorCode.SENTINEL_FLOWEXCEPTION.toString().getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            writer.write(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义限流规则 - QPS限流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri 目标资源地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFlowRules</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">        <span class="comment">// 设置限流的目标资源</span></span><br><span class="line">        rule.setResource(uri);</span><br><span class="line">        <span class="comment">// 设置限流的类型|QPS or 线程数</span></span><br><span class="line">        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        <span class="comment">// 设置QPS阈值</span></span><br><span class="line">        rule.setCount(<span class="number">1</span>);</span><br><span class="line">        rules.add(rule);</span><br><span class="line">        <span class="comment">// 加载限流规则</span></span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中异常码为个人自定义二方工具包：<a href="https://gitee.com/maple_eitba/maple-commons">maple-commons</a></p></blockquote><h2 id="Sentinel-dashboard流控配置"><a href="#Sentinel-dashboard流控配置" class="headerlink" title="Sentinel-dashboard流控配置"></a>Sentinel-dashboard流控配置</h2><h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><p>可以为每个资源定义流控规则，在簇点链路界中点击目标资源后面的<code>+流控</code> 按钮，就会出现设置页面，如图：</p><img src="dashboard5.png" style="zoom:30%;"><ul><li>资源名：表示需要进行流控的目标资源名称，就是展示在簇点链路页面中所有资源的名称</li><li>针对来源：一般都是default</li><li>阈值类型：QPS or 线程数<ul><li>QPS是指对访问目标资源的QPS进行限制</li><li>线程数是指对访问目标资源的并发度进行限制</li></ul></li><li>单机阈值：单节点的访问限制值</li></ul><p>其含义是限制 <code>/order/&#123;orderId&#125;</code> 这个资源的单机QPS为5，即每秒只允许5次请求，超出的请求会被拦截并报错。</p><h4 id="流控高级选项"><a href="#流控高级选项" class="headerlink" title="流控高级选项"></a>流控高级选项</h4><p>限流规则中有两个高级选项，可以对流控模式和流控效果进行进一步的细化，如图：</p><img src="dashboard6.png" style="zoom:33%;"><h5 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h5><ul><li><p><strong>直接</strong>：统计当前资源的请求，触发阈值时对当前资源直接限流，默认模式；</p></li><li><p><strong>关联</strong>：统计与当前资源相关的另一个资源，<font color="green">当另一个资源触发阈值时，对当前资源限流；</font></p><ul><li>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。因此当修改订单业务触发阈值时，需要对查询订单业务限流。</li><li>满足下面条件可以使用关联模式：<ul><li>两个有竞争关系的资源；</li><li>一个优先级较高，一个优先级较低；<strong>当优先级高的资源达到阈值之后对优先级低的资源进行限流，高优先级的资源不受影响。</strong></li></ul></li></ul></li></ul><img src="dashboard7.png" style="zoom:35%;"><ul><li><strong>链路</strong>：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流；<ul><li>Sentinel默认只标记<code>Controller</code>层中的方法为资源，如果要标记其它方法，需要利用<code>@SentinelResource</code>注解，如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO 逻辑处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Sentinel默认会将<code>Controller</code>方法做<code>context</code> 整合 ，这会导致链路模式的流控失效，需要修改<code>application.yml</code>，添加配置：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure><ul><li>使用场景：<ul><li>例如有两条请求链路：<code>/test1 -&gt; /common</code> 和  <code>test2 -&gt; /common</code> 如果只希望统计从<code>/test2</code>进入到<code>/common</code>的请求，则可以这样配置：</li></ul></li></ul><img src="dashboard8.png" style="zoom:40%;"><h5 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h5><p>流控效果是指请求达到流控阈值时采取的措施，包括三种：</p><ul><li><p><strong>快速失败</strong>：请求达到阈值后，新的请求会被立即拒绝并抛出<code>FlowException异常</code>。默认流控效果。</p></li><li><p><strong>warm up</strong>：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p><ul><li><p>warm up也叫预热模式，是应对服务冷启动的一种方案（整体实现的方案和Dubbo的服务预热很类似）。请求阈值初始值是<code> threshold / coldFactor</code>，持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3。</p><p>例如，设置QPS的threshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10。整个过程如图：</p><img src="dashboard9.png" style="zoom:45%;"></li></ul></li><li><p><strong>排队等待</strong>：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</p><ul><li><p>当请求超过QPS阈值时，快速失败 和 warm up 都会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>例如：QPS = 5，意味着理论上每200ms处理一个队列中的请求；timeout = 2000，意味着预期等待超过2000ms的请求会被拒绝并抛出异常。如果队列中已经存在了10个请求，那么后续的请求等待时间理论上就是 10 * 200 ms = 2000ms，已经到达timeout时间了，请求就会被拒绝。</p><img src="dashboard10.png" style="zoom:50%;"></li><li><p>排队等待的限流效果其实就是流量整形</p></li><li><img src="dashboard11.png" style="zoom:50%;"></li></ul></li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/flow-control.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 2」-- Sentinel基本使用</title>
      <link href="/maple/2023/06/07/Sentinel2-Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/maple/2023/06/07/Sentinel2-Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel基本使用"><a href="#Sentinel基本使用" class="headerlink" title="Sentinel基本使用"></a>Sentinel基本使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。</p><p>我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:</p><ol><li><strong>定义资源</strong></li><li><strong>定义规则</strong></li><li><strong>检验规则是否生效</strong></li></ol><p>先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。</p><blockquote><p>对于主流的框架，我们提供适配，只需要按照适配中的说明配置，Sentinel 就会默认定义提供的服务，方法等为资源。</p></blockquote><h2 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h2><h3 id="方式一：主流框架的默认适配"><a href="#方式一：主流框架的默认适配" class="headerlink" title="方式一：主流框架的默认适配"></a>方式一：主流框架的默认适配</h3><p>为了减少开发的复杂程度，我们对大部分的主流框架，例如 Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux、Reactor 等都做了适配。您只需要引入对应的依赖即可方便地整合 Sentinel。可以参见：<a href="https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html">主流框架的适配</a>。</p><blockquote><p>我们在实际开发中一般都是根据应用项目使用的框架来使用对应的Sentinel适配框架。</p></blockquote><h3 id="方式二：抛出异常的方式定义资源"><a href="#方式二：抛出异常的方式定义资源" class="headerlink" title="方式二：抛出异常的方式定义资源"></a>方式二：抛出异常的方式定义资源</h3><p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.5.0 版本开始可以利用 try-with-resources 特性</span></span><br><span class="line"><span class="comment">// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;resourceName&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// 被保护的业务逻辑</span></span><br><span class="line">  <span class="comment">// do something here...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">  <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">  <span class="comment">// 在此处进行相应的处理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别地</strong>，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 <code>Tracer.trace(ex)</code> 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 <code>Tracer.trace(ex)</code>。</p><p>1.5.0 之前的版本的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 务必保证finally会被执行</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 资源名可使用任意有业务语义的字符串</span></span><br><span class="line">  entry = SphU.entry(<span class="string">&quot;自定义资源名&quot;</span>);</span><br><span class="line">  <span class="comment">// 被保护的业务逻辑</span></span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">  <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">  <span class="comment">// 进行相应的处理操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>SphU.entry(xxx)</code> 需要与 <code>entry.exit()</code> 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 <code>ErrorEntryFreeException</code> 异常。</p><h3 id="方式三：返回布尔值方式定义资源"><a href="#方式三：返回布尔值方式定义资源" class="headerlink" title="方式三：返回布尔值方式定义资源"></a>方式三：返回布尔值方式定义资源</h3><p><code>SphO</code> 提供 if-else 风格的 API。用这种方式，当资源发生了限流之后会返回 <code>false</code>，这个时候可以根据返回值，进行限流之后的逻辑处理。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源名可使用任意有业务语义的字符串</span></span><br><span class="line"><span class="keyword">if</span> (SphO.entry(<span class="string">&quot;自定义资源名&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// 务必保证finally会被执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被保护的业务逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    SphO.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">  <span class="comment">// 进行相应的处理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式四：注解方式定义资源"><a href="#方式四：注解方式定义资源" class="headerlink" title="方式四：注解方式定义资源"></a>方式四：注解方式定义资源</h3><p>Sentinel 提供了 <code>@SentinelResource</code> 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 <code>BlockException</code> 等。使用 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-annotation-aspectj">Sentinel Annotation AspectJ Extension</a> 的时候需要引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SentinelResource-注解"><a href="#SentinelResource-注解" class="headerlink" title="@SentinelResource 注解"></a>@SentinelResource 注解</h4><blockquote><p>注意：注解方式埋点不支持 private 方法。</p></blockquote><p><code>@SentinelResource</code> 用于定义资源，并提供可选的异常处理和 fallback 配置项。 <code>@SentinelResource</code> 注解包含以下属性：</p><ul><li><p><code>value</code>：资源名称，必需项（不能为空）</p></li><li><p><code>entryType</code>：entry 类型，可选项（默认为 <code>EntryType.OUT</code>）</p></li><li><p><code>blockHandler</code> / <code>blockHandlerClass</code>: <code>blockHandler</code> 对应处理 <code>BlockException</code> 的函数名称，可选项。blockHandler 函数访问范围需要是 <code>public</code>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 <code>BlockException</code>。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</p></li><li><p><code>fallback</code>：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li><li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p><code>defaultFallback</code></p><p>（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所以类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要为空，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li><li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p><code>exceptionsToIgnore</code>（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</p></li></ul><blockquote><p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（<code>DegradeException</code>）进行处理，<strong>不能针对业务异常进行处理</strong>。</p></blockquote><p>特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 <code>BlockException</code> 时只会进入 <code>blockHandler</code> 处理逻辑。若未配置 <code>blockHandler</code>、<code>fallback</code> 和 <code>defaultFallback</code>，则被限流降级时会将 <code>BlockException</code> <strong>直接抛出</strong>。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 static 函数.</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;test&quot;, blockHandler = &quot;handleException&quot;, blockHandlerClass = &#123;ExceptionUtil.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;hello&quot;, blockHandler = &quot;exceptionHandler&quot;, fallback = &quot;helloFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="type">long</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Hello at %d&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloFallback</span><span class="params">(<span class="type">long</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Halooooo %d&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">exceptionHandler</span><span class="params">(<span class="type">long</span> s, BlockException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// Do some log here.</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Oops, error occurred at &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 1.4.0 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.4.0 以前的版本需要自行调用 <code>Tracer.trace(ex)</code> 来记录业务异常。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>AspectJ</strong></p><p>若您的应用直接使用了 AspectJ，那么您需要在 <code>aop.xml</code> 文件中引入对应的 Aspect：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">&quot;com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Spring AOP</strong></p><p>若您的应用使用了 Spring AOP，您需要通过配置的方式将 <code>SentinelResourceAspect</code> 注册为一个 Spring Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelAspectConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SentinelResourceAspect <span class="title function_">sentinelResourceAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SentinelResourceAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提供了 Spring AOP 的示例，可以参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/tree/master/sentinel-demo/sentinel-demo-annotation-spring-aop">sentinel-demo-annotation-spring-aop</a>。</p><h3 id="方式五：异步调用支持"><a href="#方式五：异步调用支持" class="headerlink" title="方式五：异步调用支持"></a>方式五：异步调用支持</h3><p>Sentinel 支持异步调用链路的统计。在异步调用中，需要通过 <code>SphU.asyncEntry(xxx)</code> 方法定义资源，并通常需要在异步的回调函数中调用 <code>exit</code> 方法。以下是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">AsyncEntry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.asyncEntry(resourceName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用.</span></span><br><span class="line">    doAsync(userId, result -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在此处处理异步调用的结果.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在回调结束后 exit.</span></span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">    <span class="comment">// Request blocked.</span></span><br><span class="line">    <span class="comment">// Handle the exception (e.g. retry or fallback).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SphU.asyncEntry(xxx)</code> 不会影响当前（调用线程）的 Context，因此以下两个 entry 在调用链上是平级关系（处于同一层），而不是嵌套关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用链类似于：</span></span><br><span class="line"><span class="comment">// -parent</span></span><br><span class="line"><span class="comment">// ---asyncResource</span></span><br><span class="line"><span class="comment">// ---syncResource</span></span><br><span class="line">asyncEntry = SphU.asyncEntry(asyncResource);</span><br><span class="line">entry = SphU.entry(normalResource);</span><br></pre></td></tr></table></figure><p>若在异步回调中需要嵌套其它的资源调用（无论是 <code>entry</code> 还是 <code>asyncEntry</code>），只需要借助 Sentinel 提供的上下文切换功能，在对应的地方通过 <code>ContextUtil.runOnContext(context, f)</code> 进行 Context 变换，将对应资源调用处的 Context 切换为生成的异步 Context，即可维持正确的调用链路关系。Context 维持的方式：通过 ThreadLocal 传递，只有在入口 <code>enter</code> 的时候生效。由于 Context 是通过 ThreadLocal 传递的，因此对于异步调用链路，线程切换的时候会丢掉 Context，因此需要手动通过 <code>ContextUtil.runOnContext(context, f)</code> 来变换 context。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry = SphU.entry(<span class="string">&quot;handleResultForAsync&quot;</span>);</span><br><span class="line">        <span class="comment">// Handle your result here.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">        <span class="comment">// Blocked for the result handler.</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">AsyncEntry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.asyncEntry(resourceName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Asynchronous invocation.</span></span><br><span class="line">        doAsync(userId, result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 在异步回调中进行上下文变换，通过 AsyncEntry 的 getAsyncContext 方法获取异步 Context</span></span><br><span class="line">            ContextUtil.runOnContext(entry.getAsyncContext(), () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 此处嵌套正常的资源调用.</span></span><br><span class="line">                    handleResult(result);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    entry.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">        <span class="comment">// Request blocked.</span></span><br><span class="line">        <span class="comment">// Handle the exception (e.g. retry or fallback).</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的调用链就类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-parent</span><br><span class="line">---asyncInvocation</span><br><span class="line">-----handleResultForAsync</span><br></pre></td></tr></table></figure><p>更详细的示例可以参考 Demo 中的 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/AsyncEntryDemo.java">AsyncEntryDemo</a>，里面包含了普通资源与异步资源之间的各种嵌套示例。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim基础</title>
      <link href="/maple/2023/05/29/Vim/"/>
      <url>/maple/2023/05/29/Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim基础"><a href="#Vim基础" class="headerlink" title="Vim基础"></a>Vim基础</h1><h2 id="Vim的操作模式"><a href="#Vim的操作模式" class="headerlink" title="Vim的操作模式"></a>Vim的操作模式</h2><p>Vim有四种操作模式，分别为：</p><ul><li><strong>正常模式(normal-mode)</strong></li><li><strong>插入模式(insert-mode)</strong></li><li><strong>命令模式(command-mode)</strong></li><li><strong>可视模式(visual-mode)</strong></li></ul><h3 id="①-正常模式"><a href="#①-正常模式" class="headerlink" title="①  正常模式"></a>①  正常模式</h3><p>正常模式主要用来浏览和修改文本内容的。</p><p>一般的打开Vim之后默认的都是正常模式。在任何模式下，只要按下 <code>Esc 键</code>就可以返回正常模式。</p><h3 id="②-插入模式"><a href="#②-插入模式" class="headerlink" title="② 插入模式"></a>② 插入模式</h3><p>插入模式是用来向文本中添加内容的。</p><p><strong>i</strong>：表示进入插入模式，并在光标所在字符前开始输入；</p><p><strong>a</strong>：表示进入插入模式，并在光标所在字符后开始输入；</p><p><strong>o</strong> (字母o)：表示进入插入模式并在光标所在行的下一新行开始输入；</p><p><strong>s</strong>：表示进入插入模式，并删除光标所在的字符；</p><p><strong>I</strong>：在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。如果行首有空格，则在    空格之后输入文字并进入插入模式；</p><p><strong>A</strong>：在行尾开始输入文字并进入插入模式。这个好用，您不必管光标在此行的什麽地方，只要按 A 就会在行尾等着您输入文字；</p><p><strong>O</strong> (大写字母O)：在光标所在行的上面单独开一新行来输入文字并进入插入模式；</p><p><strong>S</strong>：删除光标所在行并进入插入模式；</p><h3 id="③-命令模式"><a href="#③-命令模式" class="headerlink" title="③ 命令模式"></a>③ 命令模式</h3><p>命令模式则多用于操作文件。不是操作文本文件的内容，而是对文件本身进行操作，例如：保存文件等；或者用来改变编辑器本身的状态，例如：设定多栏窗口、标签或者退出编辑器等。</p><h3 id="④-可视模式"><a href="#④-可视模式" class="headerlink" title="④ 可视模式"></a>④ 可视模式</h3><p>可视模式相当于高亮选取文本后的普通模式。</p><p>可视模式具有子模式，以行为单位进行选取的可视行模式，使用<code>“V”</code>键进入（也就是<code>Shift+v</code>）；和以块为单位进行选取的可视块模式，使用<code>“Ctrl+v”</code>键进入。</p><h2 id="模式之间的切换"><a href="#模式之间的切换" class="headerlink" title="模式之间的切换"></a>模式之间的切换</h2><h3 id="其它模式-gt-正常模式"><a href="#其它模式-gt-正常模式" class="headerlink" title="其它模式==&gt;正常模式"></a>其它模式==&gt;正常模式</h3><ul><li>按 Esc键</li></ul><h3 id="正常模式-gt-插入模式"><a href="#正常模式-gt-插入模式" class="headerlink" title="正常模式==&gt;插入模式"></a>正常模式==&gt;插入模式</h3><ul><li>按 i 在光标前插入</li><li>按 I 在行首插入</li><li>按 a 在光标后插入</li><li>按 s 删除光标所在的字符再插入</li><li>按 A 在行末插入</li><li>按 o 在当前行之下新建行</li><li>按 O 在当前行之上新建行</li><li>按 S 删除光标所在行再插入</li></ul><h3 id="正常模式-gt-命令模式"><a href="#正常模式-gt-命令模式" class="headerlink" title="正常模式==&gt;命令模式"></a>正常模式==&gt;命令模式</h3><ul><li>按（shift 加 冒号）或 /</li></ul><h3 id="正常模式-gt-可视模式"><a href="#正常模式-gt-可视模式" class="headerlink" title="正常模式==&gt;可视模式"></a>正常模式==&gt;可视模式</h3><ul><li>按 v 可视模式</li><li>按 V 可视块模式</li></ul><p>以下是正常模式【一般模式】、插入模式【编辑模式】和命令模式之间的转换图，没有视图模式是因为其就是高亮后的正常模式。</p><img src="vim1.png" style="zoom:33%;"><h2 id="命令模式下的基本操作"><a href="#命令模式下的基本操作" class="headerlink" title="命令模式下的基本操作"></a>命令模式下的基本操作</h2><p><strong>:w</strong> 保存编辑后的文件内容，但不退出vim编辑器。</p><p>这个命令的作用是把内存缓冲区【一个隐藏目录】中的数据写到启动vim时指定的文件中。</p><p><strong>:w!</strong> 强制写文件，即强制覆盖原有文件。</p><p>如果原有文件的访问权限不允许写入文件，例如，原有的文件为只读文件，则可使用这个命令强制写入。但是，这种命令用法仅当用户是文件的属主时才适用，而超级用户则不受此限制<strong>。</strong></p><p><strong>:w filename</strong> 把编辑处理后的结果写到指定的文件中保存，不退出vim。</p><p><strong>:w! filename</strong> 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件。</p><p><strong>:wq</strong> 保存文件并退出vim。</p><p><strong>:wq!</strong> 强制保存文件，并退出vim。</p><p><strong>:wq! filename</strong> 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件，并退出vim编辑器。</p><p><strong>:q</strong> 不保存文件，退出vim【在没有做任何修改的前提下可以退出；如果有修改操作使用该命令会有提示该命令无法生效】。</p><blockquote><p><strong>提示内容：</strong>E37: 已修改但尚未保存 (可用 ! 强制执行)</p></blockquote><p><strong>:q!</strong> 不保存文件，强制退出vim【在有无修改操作的情况下都可以使用】。</p><p><strong>:e!</strong> 放弃所有修改，从上次保存文件开始再编辑。</p><h2 id="Vim常用快捷键"><a href="#Vim常用快捷键" class="headerlink" title="Vim常用快捷键"></a>Vim常用快捷键</h2><p><strong>【正常模式】yy + p</strong> ：拷贝当前行；</p><p>​    在正常模式下，使用yy复制当前行，p粘贴当前行。</p><p><strong>【正常模式】数字yy + p</strong>：多行拷贝，拷贝当前行向下的指定数字行；如：3yy + p，拷贝当前行的下三行【包括当前行】至当前行的下一行；</p><p><strong>【正常模式】/关键字</strong> <strong>+ Ente</strong>r：在文件中查找某个单词，如果有多个结果，使用 n 进行切换；</p><p><strong>【正常模式】G</strong>：跳至文档的最末行；</p><p><strong>【正常模式】gg</strong>：跳至文档的首行；</p><p>【<strong>正常模式】n</strong>：撤销操作；</p><p><strong>【正常模式】数字 + shift + g</strong>：跳转至指定行的行首；</p><ol><li>第一步：显示行号，<code>:set nu</code>；</li><li>第二步：输入指定行数，如：10；</li><li>第三步：输入<code>shift + g</code>；</li></ol><img src="vim2.jpeg" style="zoom:80%;"><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://www.jianshu.com/p/14fde3a5ed25">Vim四种模式切换与基本命令</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「设计模式」- 单例模式</title>
      <link href="/maple/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/maple/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在类加载的时候直接将Singleton对象提前创建好，等需要用的时候调用<code>getSingleton()</code>方法获取即可。</p><p>提前创建，是一种空间换时间的方式，无法实现延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 特点:</span></span><br><span class="line"><span class="comment"> * 1. 空间换时间 -- 一上来就创建对象(慢),后面直接用就好;</span></span><br><span class="line"><span class="comment"> * 2. 线程安全;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法,其他类不能访问该构造方法，即无法通过构造器来实例化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有当前类的实例对象,让外部对象无法直接对其进行访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK源码中的典型实现： <code>java.lang.Runtime</code>类 和 <code>Unsafe</code>类（只不过获取Unsafe实例时往往使用反射打破单例模式强行创建）。</p><p>JVM中的Runtime类就是饿汉式单例模型的典型实现，只能通过 <code>Runtime.getRuntime()</code>方法获取其实例对象。</p></blockquote><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>等需要使用单例对象的时候才去实例化对象，是一种时间换空间的延迟加载方式，线程不安全，实际开发中一般不用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式(延迟加载模式)</span></span><br><span class="line"><span class="comment"> * 特点:</span></span><br><span class="line"><span class="comment"> * 1. 时间换空间 -- 一上来只是声明(快),等需要的时候再创建对象</span></span><br><span class="line"><span class="comment"> * 2. 线程不安全;在多线程访问时,懒汉式可能会创建多个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在多线程时，线程1执行到这一步,刚刚创建完对象执行权就被别的线程抢占了，</span></span><br><span class="line">            <span class="comment">// 另外一个线程执行到上一句的判断时依旧成立，就会再次进入并创建一个对象，这就不是单例了</span></span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于synchronized-线程安全型懒汉式"><a href="#基于synchronized-线程安全型懒汉式" class="headerlink" title="基于synchronized 线程安全型懒汉式"></a>基于synchronized 线程安全型懒汉式</h2><p>对于上述线程安全的问题，可以使用synchronized关键字加锁来保证线程安全，不过，加锁会导致串行化，会在一定程度上影响代码性能。</p><blockquote><p>不过随着JDK对synchroniezd锁的优化，这种性能损耗也是越来越小，可以忽略不计。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DCL（Double-Check-Lock）"><a href="#DCL（Double-Check-Lock）" class="headerlink" title="DCL（Double Check Lock）"></a>DCL（Double Check Lock）</h2><p>DCL（Double Check Lock），双重检查锁，比线程安全型的懒汉式运行效率更高。</p><p>对获取单例对象的请求有<strong>分流</strong>，只在获取不到单例对象的时候才会去创建对象；在单例对象存在时直接获取，方法的执行效率高；</p><p><strong>DCL存在的问题:</strong></p><p>由于JVM在编译和运行的时候都会对代码进行一定的优化，比如：指令重排；因此可能会导致NullPointerException – Singleton对象创建过程有指定重排。</p><p>当一个线程执行请求获取单例对象，进入同步代码块创建一个单例对象；另外一个线程也尝试获取单例对象，判断得知单例对象已经创建，直接返回创建的对象供其使用，但是在使用的过程中可能会出现空指针异常，因为指令重排可能会导致对象是创建出来了，但尚未完成初始化，所以另外一个线程获取的对象内部可能有值为null的属性；</p><blockquote><p>JVM中对象的实例化过程简单地说：加载、链接、初始化、使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经创建了对象，就直接返回已创建的对象，不需要获取锁这一环节了。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 再次判断对象是否为空是针对获取锁阻塞的场景，如果其他线程已经获取锁并创建了实例对象，等当期线程获取到锁时，对象已经被创建了。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止指令重排的DCL"><a href="#禁止指令重排的DCL" class="headerlink" title="禁止指令重排的DCL"></a>禁止指令重排的DCL</h2><p>volatile 关键字会禁止指令重排，保证创建对象的过程是有序的，即可保证使用的对象都是已经完成了初始化操作的完整对象；</p><blockquote><p>JVM使用指令重排的目的就是优化性能，所以频繁使用volatile禁止指令重排会影响性能；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// Singleton对象的创建过程不会进行指令重排。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Holder"><a href="#Holder" class="headerlink" title="Holder"></a>Holder</h2><p>懒加载|线程安全|效率高，充分利用了JVM的类加载机制。</p><blockquote><p>JVM中的类加载机制为懒加载，一个应用在启动的时候不会一上来就直接加载应用中所有引入的类，而是加载应用启动时有使用的类，剩余没有加载的类只有在用到的使用才会加载。所以从Java应用启动的时候，就会创建一个方法区，随着业务场景的调用，使用到的类越来越多，方法区中的已使用内存也会越来越大，直到该应用中所有用到的类都经历了加载，那么方法区中的已使用内存大小就会趋于稳定不变。</p><p>当然了，也有例外，方法区中存放的是类信息和字符串常量池（JDK1.6），针对这两块在程序运行时还有有可能会越来越大。</p><p>类信息：运行时不断地增加加载的类。</p><ol><li>自定义类加载器，去自定目录下加载自定义类；</li><li>反射，通过反射不断地生成Class文件；</li></ol><p>字符串常量池：不断地创建字符串对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒加载|线程安全|效率高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用静态内部类的类变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="comment">// static保证唯一性，充分利用类加载机制。类只会被加载一次，所以只会创建一个Singleton对象。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>线程安全|懒加载|高效|优雅</p><p>充分利用枚举项的构造器只会执行一次的特性来创建单例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充分利用了枚举项的构造函数只会执行一次的特点来进行单例对象的实例化;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">SingletionEnum</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton singleton;</span><br><span class="line">        </span><br><span class="line">        SingletionEnum() &#123;</span><br><span class="line">            <span class="built_in">this</span>.singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletionEnum.INSTANCE.getSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打破单例"><a href="#打破单例" class="headerlink" title="打破单例"></a>打破单例</h1><p>Singleton单例模式从其定义出发就是永远获取的是同一个对象，但是可以通过反射来打破单例；</p><p>单例实现的核心就是通过私有化构造器，让外界无法通过构造器来创建对象，而是在类的内部维护了一个对象的引用，来实现单例；而反射可以在系统运行时通过Class对象来获取对象的构造器，包括私有构造器，然后通过获取的构造器对象来创建对象；这样就打破了单例模式。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式不是绝对的，可以通过反射来破解单例;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量|共享</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块只会在类加载的时候执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获取私有构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置对私有构造器的访问</span></span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 通过私有构造器来创建一个对象</span></span><br><span class="line">            singleton = (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码获取的就是一个新的单例对象，和<code>Singleton.getIntance()</code>获取的不是同一个对象；但是利用上述方法获取的都是同一个对象；因为创建对象的过程是在静态代码块中，所以创建对象的过程只会在类加载的时候执行一次，所以通过<code>create()</code>方法获取的都是同一个对象；</p><p>也可以写的更过分，将单例粉碎了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获取私有构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置对私有构造器的访问</span></span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 通过私有构造器来创建一个对象</span></span><br><span class="line">            singleton = (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码每获取一次对象，都是通过反射重新创建一个新的对象，返回的结果没有一个是相同的，都是新生成的对象，单例已经不复存在了。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析面向对象和面向过程</title>
      <link href="/maple/2023/05/23/%E6%B5%85%E6%9E%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/maple/2023/05/23/%E6%B5%85%E6%9E%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析面向对象和面向过程"><a href="#浅析面向对象和面向过程" class="headerlink" title="浅析面向对象和面向过程"></a>浅析面向对象和面向过程</h1><p><font color="green"><strong>面向过程和面向对象都是对软件分析、设计和开发的一种思想，它指导着开发者以不同的方式去分析、设计和开发软件。</strong></font> </p><p>早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的不足也越来越明显，随之应运而生的就是面向对象思想，并成为目前开发者们使用的主流思想。两者都贯穿于软件分析、设计和开发各个阶段，根据面向对象思想的使用场景，又可以分别称为 <strong>面向对象分析（OOA）</strong>、<strong>面向对象设计（OOD）</strong>和<strong>面向对象编程（OOP）</strong>。</p><blockquote><p>C语言是一种典型的面向过程语言，Java是一种典型的面向对象语言。</p></blockquote><p>面向过程思想思考问题时，我们首先思考“怎么按<strong>步骤</strong>实现？”并将步骤对应成方法，一步一步，最终完成。 这种适合简单的任务，不需要过多协作的情况下。比如，如何开车？我们很容易就列出实现步骤：</p><p><code>点火</code> –&gt; <code>挂挡</code> –&gt; <code>给油</code> –&gt; <code>走你</code></p><p>面向过程适合简单、不需要太多模块协作的事务，重点关注如何一步一步地执行。</p><p>但是当我们思考比较复杂的设计任务时，比如“如何造车？”，就会发现列出1234这样的步骤，是不可能的。因为造车太复杂，需要很多部门协作才能完成。此时面向对象思想就非常适用了。</p><p>面向对象(Oriented-Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 比如：思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。</p><p>其次应该思考”应该让谁来实现?”，这个”谁”就是对象 , 对象如何实现我们不关注，只关注对象本身。</p><p>我们会从“车由什么组成”开始思考。发现车由如下对象组成：</p><ul><li>轮胎</li><li>发送机</li><li>底盘</li><li>外壳</li><li>…</li></ul><p>为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤，等等；这样，发现各个模块可以分别同时进行车部件的制造，互相不用关心彼此，直到最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开执行者、离不开面向过程思维！</p><p><strong>区别：</strong></p><ul><li>面向过程：目标事物相对比较简单，可以使用线性的思维去解决</li><li>面向对象：目标事物相对复杂，无法使用简单线性的思维去解决</li></ul><p><strong>共同点：</strong></p><ul><li>面向过程和面向对象都是解决实际问题的一种思维方式；</li><li><font color="red"><strong>面向过程和面向对象二者是相辅相成的，并不是对立的。</strong></font></li><li><font color="green"><strong>解决复杂问题，通过面向对象思想便于我们从宏观上把握事物之间的复杂关系、方便梳理整个系统；而具体到内部微观实现层面，还是需要使用面向过程思想来进行一步一步的处理。</strong></font></li></ul><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://blog.csdn.net/m0_62886303/article/details/123377192">浅谈面向对象和面向过程</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象，面向过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析数仓</title>
      <link href="/maple/2023/05/18/%E6%B5%85%E6%9E%90%E6%95%B0%E4%BB%93/"/>
      <url>/maple/2023/05/18/%E6%B5%85%E6%9E%90%E6%95%B0%E4%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析数仓"><a href="#浅析数仓" class="headerlink" title="浅析数仓"></a>浅析数仓</h1><p>随着互联网及物联网等技术发展，越来越多的数据被生成，如何有效利用这些数据就成为了企业决胜的法宝了。大型公司会基于数据做出BI、推荐系统、决策支持、统计分析、报表等业务。</p><h2 id="OLTP-VS-OLAP"><a href="#OLTP-VS-OLAP" class="headerlink" title="OLTP VS OLAP"></a>OLTP VS OLAP</h2><p>1970年随着关系数据库理论的提出，诞生了一系列经典的RDBMS，如MySQL、Oracle、SQL Server、DB2等。这些RDBMS为社会信息化的发展做出的重大贡献。然而随着数据库使用范围的不断扩大，它被逐步划分为<strong>操作型数据库</strong>OLTP（在线事务处理）跟<strong>分析型数据库</strong>OLAP（在线分析处理）。</p><h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p><strong>操作型数据库OLTP</strong>（On-Line Transaction Processing 在线事务处理）也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对记录进行CRUD。OLTP模式下用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</p><h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p><strong>分析型数据库OLAP</strong>（On-Line Analytical Processing）叫在线分析处理，主要用于历史数据分析。这类数据库作为公司的单独数据存储，负责利用历史数据对公司各<strong>主题域</strong>进行统计分析。为啥要分成操作型跟分析型呢？原因是他们有太多不同了！</p><img src="dw1.png" style="zoom:80%;"><h3 id="操作型OLTP-VS-分析型OLAP"><a href="#操作型OLTP-VS-分析型OLAP" class="headerlink" title="操作型OLTP VS 分析型OLAP"></a>操作型OLTP VS 分析型OLAP</h3><p>之所以区分为操作型跟分析型，那是因为这俩的核心功能不同！前者主要是面向操作，后者主要是面向分析，在细节上存在众多差异。</p><h4 id="数据组成差别"><a href="#数据组成差别" class="headerlink" title="数据组成差别"></a>数据组成差别</h4><ul><li>数据时间范围不同：一般操作型数据库只存放90天内数据，分析型数据存放数年内数据，所以这俩要进行物理分离。</li><li>数据细节差异不同：操作型数据库主要存放细节数据，汇总数据是动态技术而成的。分析型数据库中既存放细节数据又存放用户关系的汇总数据。</li><li>数据时间表示不同：操作型数据库反应的是当前状态，分析师数据库中既有当前状态又有过去各时刻的快照数据。</li></ul><h4 id="技术差别"><a href="#技术差别" class="headerlink" title="技术差别"></a>技术差别</h4><ul><li>查询数量跟频率不同：操作型数据库查询频率高但量小，分析型数据库查询量大但频率低。</li><li>数据更新不同：操作型数据库设计到用户CRUD。<font color="cornflowerblue">分析型数据库属于归档性质存储，只提供查询。</font></li><li>数据冗余性不同：<font color="cornflowerblue">操作型数据库在设计表的时候就会减少数据冗余避免更新复杂。</font>分析型数据库中则只有查询功能，因此数据冗余性一般都存在。</li></ul><h4 id="功能差别"><a href="#功能差别" class="headerlink" title="功能差别"></a>功能差别</h4><ul><li>数据读者不同：操作型数据的使用者是业务环节下的各个角色，比如用户、商家等。分析型数据库一般只有研发跟数据分析人员专门使用。</li><li>定位不同：操作型数据库主要是面向应用层的数据库，是为了支持具体业务而存在的。分析型数据库是针对特定业务主体域的分析人物而创建的，是面向主体型数据库。</li></ul><h2 id="数仓"><a href="#数仓" class="headerlink" title="数仓"></a>数仓</h2><h3 id="数仓简介"><a href="#数仓简介" class="headerlink" title="数仓简介"></a>数仓简介</h3><p>随着人类IT发展，数据越来越多被产生，并且这些数据还可能跨部门，跨业务。如何把数据集成起来进行OLAP是个巨大挑战。数据仓库(Data Warehouse)应运而生，数据仓库是一个<strong>面向主题的</strong>、集成的、相对稳定的、反映历史变化的数据集合，用于支持管理中的决策制定。数据仓库是伴随着企业信息化发展起来的，在企业信息化的过程中，随着信息化工具的升级和新工具的应用，数据量变的越来越大，数据格式越来越多，决策要求越来越苛刻，数据仓库技术也在不停的发展。数据仓库的趋势：</p><ul><li>实时数据仓库以满足实时化&amp;自动化决策需求。</li><li>大数据&amp;数据湖以支持大量&amp;复杂数据类型(文本、图像、视频、音频)。</li></ul><p>对于数仓可以理解为原来各个数据孤岛中的数据可能存储位置、存储格式、编程语言等各个方面不同。数仓要做的就是把数据按照所需格式提取出来，进行转换、过滤、清洗。最终装载到数据仓库，整个过程也<strong>ETL</strong>。</p><ul><li><strong>提取 Extraction</strong>：表示从操作型数据库搜集指定数据。</li><li><strong>转换 Transformation</strong>：表示将数据转化为指定格式，并进行数据清洗保证数据质量。</li><li><strong>加载 Load</strong>：加载过程表示将转换过后满足指定格式的数据加载进数据仓库。</li></ul><p>随着数仓的不断普及跟使用，<strong>信息产业就开始从以关系型数据库为基础的运营式系统慢慢向决策支持系统发展。</strong>这个<strong>决策支持系统</strong>，其实就是我们现在说的<strong>商务智能（Business Intelligence），即BI</strong>。可以这么说，数据仓库为OLAP解决了数据来源问题，数据仓库和OLAP互相促进发展，进一步驱动了商务智能的成熟，但真正将商务智能赋予智能的，其实是数据挖掘。</p><h3 id="数仓特征"><a href="#数仓特征" class="headerlink" title="数仓特征"></a>数仓特征</h3><h4 id="面向主题"><a href="#面向主题" class="headerlink" title="面向主题"></a>面向主题</h4><p><strong>面向主题特性</strong>是数据仓库和操作型数据库的根本区别。</p><ol><li>操作型数据库是为了支撑各种业务而建立，是按照业务功能进行组织的。</li><li>分析型数据库则是为了对从各种繁杂业务中抽象出来的分析主题进行分析而建立。</li><li><font color="cornflowerblue">所谓主题是指用户使用数据仓库进行决策时所关心的重点方面</font>，如：收入、客户、销售渠道等。<strong>所谓面向主题，是指数据仓库内的信息是按主题进行组织的</strong>。</li></ol><h4 id="集成性"><a href="#集成性" class="headerlink" title="集成性"></a>集成性</h4><p>集成性指数据仓库中的信息不是从各个业务系统中简单抽取出来的，而是经过一系列加工、整理和汇总的过程，因此数据仓库中的信息是关于整个企业的一致的全局信息。</p><h4 id="企业范围"><a href="#企业范围" class="headerlink" title="企业范围"></a>企业范围</h4><p>数据仓库内的数据是面向公司全局的。比如：某个主题域为成本，则全公司和成本有关的信息都会被汇集进来。</p><h4 id="历史性"><a href="#历史性" class="headerlink" title="历史性"></a>历史性</h4><p>较之操作型数据库，数据仓库的时间跨度通常比较长。前者通常保存几个月，后者可能几年甚至几十年。</p><h4 id="时变性"><a href="#时变性" class="headerlink" title="时变性"></a>时变性</h4><p>时变性是指数据仓库包含来自其时间范围不同时间段的数据快照。有了这些数据快照以后，用户便可将其汇总，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。</p><h3 id="数仓架构"><a href="#数仓架构" class="headerlink" title="数仓架构"></a>数仓架构</h3><p>数仓的整体建构图：</p><img src="dw2.png" style="zoom: 50%;"><h2 id="数仓分层架构"><a href="#数仓分层架构" class="headerlink" title="数仓分层架构"></a>数仓分层架构</h2><p>数仓分层并没有严格的固定格式，各个业务可以根据自身的业务架构和决策支持个性化数仓分层机构，常见的通用的数仓分层有三层架构和四层架构，如下：</p><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li><strong>数据运营层（ ODS ）</strong></li><li><strong>数据仓库层（DW）</strong><ul><li><strong>DWD：数据明细层：DWD（Data Warehouse Detail）</strong></li><li><strong>DWM：数据中间层：DWM（Data WareHouse Middle）</strong></li><li><strong>DWS：数据服务层：DWS（Data WareHouse Servce）</strong></li></ul></li><li><strong>数据应用层（APP）</strong></li></ul><p>如下图所示。简单来讲，我们可以理解为：ODS层存放的是接入的原始数据，DW层是存放我们要重点设计的数据仓库中间层数据，APP是面向业务定制的应用数据。</p><img src="dw6.png" style="zoom: 67%;"><h3 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h3><p>将三层架构中的DWD和DWS凸显出来并弱化DWM层就形成了四层架构，如下图：</p><img src="dw7.png" style="zoom: 25%;"><p>数据分层是数据仓库设计中一个十分重要的环节，良好的分层设计能够让整个数据体系更容易被理解和使用。</p><p><img src="dw3.png"></p><h3 id="图解数据分层"><a href="#图解数据分层" class="headerlink" title="图解数据分层"></a>图解数据分层</h3><img src="dw4.png" style="zoom: 33%;"><h3 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h3><p>数据仓库中涉及到的问题：</p><ol><li>为什么要做数据仓库？</li><li>为什么要做数据质量管理？</li><li>为什么要做元数据管理？</li><li>数仓分层中每个层的作用是什么？</li><li>……</li></ol><p>在实际的工作中，我们都希望自己的数据能够有顺序地流转，设计者和使用者能够清晰地知道数据的整个声明周期，比如下面左图。但是，实际情况下，我们所面临的数据状况很有可能是复杂性高、且层级混乱的，我们可能会做出一套表依赖结构混乱，且出现循环依赖的数据体系，比如下面的右图。</p><img src="dw5.png" style="zoom:80%;"><p>为了解决我们可能面临的问题，需要一套行之有效的数据组织、管理和处理方法，来让我们的数据体系更加有序，这就是<strong>数据分层</strong>。数据分层的好处：</p><ul><li>清晰数据结构：让每个数据层都有自己的作用和职责，在使用和维护的时候能够更方便和理解</li><li>复杂问题简化：将一个复杂的任务拆解成多个步骤来分步骤完成，每个层只解决特定的问题</li><li>统一数据口径：通过数据分层，提供统一的数据出口，统一输出口径</li><li>减少重复开发：规范数据分层，开发通用的中间层，可以极大地减少重复计算的工作</li></ul><h3 id="数据分层"><a href="#数据分层" class="headerlink" title="数据分层"></a>数据分层</h3><p>每个公司的业务都可以根据自己的业务需求分层不同的层次；目前比较流行的数据分层：数据运营层、数据仓库层、数据服务层。</p><h4 id="数据运营层ODS"><a href="#数据运营层ODS" class="headerlink" title="数据运营层ODS"></a>数据运营层ODS</h4><p>数据运营层：Operation Data Store 数据准备区，也称为贴源层。数据源中的数据，经过抽取、洗净、传输，也就是ETL过程之后进入本层。现在可选择的大数据同步技术也比较多，如：<strong>datax</strong>，<strong>canal</strong>，<strong>kafka</strong>等。这一层的主要目的是把源系统的数据基本原样（有些数据敏感等级高不同步）的同步到大数据平台，因此比较容易进行方案的统一。该层的主要功能：</p><ul><li>ODS是后面数据仓库层的准备区；</li><li>为DWD层提供原始数据；</li><li>减少对业务系统的影响；</li></ul><p>为了考虑后续可能需要追溯数据问题，因此对于这一层就不建议做过多的数据清洗工作，原封不动地接入原始数据即可，这层的数据是后续数据仓库加工数据的来源。数据来源的方式：</p><ol><li>业务库：sqoop定时抽取数据；实时方面考虑使用canal监听mysql的binlog日志，实时接入即可</li><li>埋点日志：日志一般是以文件的形式保存，可以选择使用flume来定时同步；可以使用spark streaming或者Flink、Kafka来实时接入</li><li>消息队列：来自ActiveMQ、Kafka的数据等</li></ol><h4 id="数据仓库层"><a href="#数据仓库层" class="headerlink" title="数据仓库层"></a>数据仓库层</h4><p> DW为数据仓库层，DW层的数据应该是一致的、准确的、干净的数据。主要有清洗，拆分，整合，标准化，备份，隔离几个任务。即对源系统数据进行清洗后的数据。这一层的数据一般是遵循数据库第三范式的，在DW层会保存BI系统中所有的历史数据，例如保存10年的数据。数据仓库层从上到下，又可以分为3个层：数据细节层DWD、数据中间层DWM、数据服务层DWS。</p><p><strong>数据细节层DWD，data warehouse details</strong></p><p>该层是业务层和数据仓库的隔离层，保持和ODS层一样的数据颗粒度；主要是对ODS数据层做一些数据的清洗和规范化的操作，比如去除空数据、脏数据、离群值等。</p><p>为了提高数据明细层的易用性，该层通常会才采用一些维度退化方法，将维度退化至事实表中，减少事实表和维表的关联。</p><p><strong>数据中间层DWM | Data Warehouse Middle</strong></p><p>该层是在DWD层的数据基础上，对数据做一些轻微的聚合操作，生成一些列的中间结果表，提升公共指标的复用性，减少重复加工的工作。</p><blockquote><p>简答来说，对通用的核心维度进行聚合操作，算出相应的统计指标。</p></blockquote><p><strong>数据服务层DWS | Data Warehouse Service</strong></p><p>该层是基于DWM上的基础数据，整合汇总成分析某一个主题域的数据服务层，一般是宽表，用于提供后续的业务查询，OLAP分析，数据分发等。一般来说，该层的数据表会相对较少；一张表会涵盖比较多的业务内容，由于其字段较多，因此一般也会称该层的表为<strong>宽表</strong>。</p><p><strong>数据应用层ADS | Application Data Service</strong></p><p>该层主要是提供给数据产品和数据分析使用的数据，一般会存放在ES、Redis、PostgreSql等系统中供线上系统使用；也可能存放在hive或者Druid中，供数据分析和数据挖掘使用，比如常用的数据报表就是存在这里的。</p><h3 id="事实表-Fact-Table"><a href="#事实表-Fact-Table" class="headerlink" title="事实表 Fact Table"></a>事实表 Fact Table</h3><p>事实表是指存储有事实记录的表，比如：系统日志、销售记录等。事实表的记录在不断地增长，比如电商的商品订单表，就是类似的情况，所以事实表的体积通常是远大于其他表。</p><h3 id="维表层Dimension-DIM"><a href="#维表层Dimension-DIM" class="headerlink" title="维表层Dimension | DIM"></a>维表层Dimension | DIM</h3><p>维度表（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联，相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。维度表主要是包含两个部分：</p><ul><li>高基数维度数据：一般是用户资料表、商品资料表类似的资料表，数据量可能是千万级或者上亿级别</li><li>低基数维度数据：一般是配置表，比如：枚举字段对应的中文含义，或者日期维表等；数据量可能就是个位数或者几千几万。</li></ul><p>常见的维度表有：日期表（存储与日期对应的周、月、季度等的属性）、地点表（包含国家、省／州、城市等属性）等。</p><p><font color="red"><strong>分层的核心思想就是解耦，再解耦，把复杂的问题简单化!</strong></font></p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.jianshu.com/p/5ac1a3a88c39">了解啥是数仓</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTMzMjE2NA==&mid=2247484463&idx=1&sn=5d2bfe658f07e9862ddf49fcc62365d7&chksm=9f736b04a804e212d4c1c8a7f3cafab4ca53dfad686f23d7dd96aecb003c8591d35884717169&scene=27">数据仓库系统架构和数仓分层体系介绍</a></p><p><a href="https://www.cnblogs.com/itboys/p/10592871.html">数据仓库–通用的数据仓库分层方法</a></p><p><a href="https://zhuanlan.zhihu.com/p/377978194">详解数据仓库分层</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析CAP理论&amp;Base理论</title>
      <link href="/maple/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA/"/>
      <url>/maple/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析CAP理论-amp-Base理论"><a href="#浅析CAP理论-amp-Base理论" class="headerlink" title="浅析CAP理论&amp;Base理论"></a>浅析CAP理论&amp;Base理论</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><strong>CAP理论是分布式应用的理论基础，虽然所有的分布式系统在设计时都会向其看齐，但事实上的所有分布式系统都不可能同时满足CAP三种特性：</strong></p><h3 id="一致性-C-Consistency"><a href="#一致性-C-Consistency" class="headerlink" title="一致性 [C: Consistency]"></a>一致性 [C: Consistency]</h3><p>在分布式环境中，一致性是指数据在多个副本（分布式节点）之间能否保持数据强一致的特性。在一致性的要求下，当一个系统在数据一致状态下执行更新操作后，应该保证系统的数据仍然处于一致状态。</p><h3 id="可用性-A-Available"><a href="#可用性-A-Available" class="headerlink" title="可用性 [A: Available]"></a>可用性 [A: Available]</h3><p>可用性是指系统提供的服务必须一直处于可用的状态，对用户的每一个请求操作总是能够在有限时间内返回结果。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p><h3 id="分区容错性-P-Partition-Tolerance"><a href="#分区容错性-P-Partition-Tolerance" class="headerlink" title="分区容错性 [P: Partition Tolerance]"></a>分区容错性 [P: Partition Tolerance]</h3><p>分布式系统在遇到任何网络分区故障的时候，仍然能够保证对外提供满足一致性或者可用性的服务，除非是整个网络环境都发生了故障。分区容错性要求应用虽然是一个分布式系统，但看上去是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p><p>这三个基本需求，任何一个分布式系统最多只能同时满足其中的两项，其中<strong>P是必须的，所以往往选择实现CP或者AP。</strong></p><p>此处的一致性表示实时的强一致性，而不是最终一致性；例如：Redis的主从集群只能保持最终一致性，在发生网络分区时，主从同步的过程中会出现数据不一致的场景，但是等网络恢复之后，从节点会进行一系列操作去追赶主节点的数据变更，数据最终会达到数据一致性，在此期间Redis集群整体依然能够提供服务（可用性），所以，<strong>Redi主从集群是AP！</strong></p><p>Zookeeper集群是数据强一致性的，如果发生网络分区，Zookeeper集群针对写请求（事务请求）无法完成半数机制场景下，Zookeeper集群是不可用的（即无法保证可用性），所以，<strong>Zookeeper集群是CP！</strong></p><blockquote><p><strong>Zookeeper不可用场景：</strong></p><ul><li>Zookeeper不能保证每次服务请求的可用性。(在极端环境下，Zookeeper可能会丢失一些请求，消费者程序需要重新请求才能获取结果)，所以说Zookeeper不能保证服务的持续可用性；</li><li>进行Leader选举时，整个集群都是不可用的。</li></ul></blockquote><h3 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h3><p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p><img src="image1.png" style="zoom: 25%;"><blockquote><p>图中指示Redis是CP是针对单机而言的 – Redis单机是CP，Redis主从集群是AP。</p></blockquote><p><strong>CA without P</strong>：如果不要求P（不允许网络分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。也就是节点应用。</p><p><strong>CP without A</strong>：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统，在此期间集群整体是不可用的。</p><p><strong>AP wihtout C</strong>：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><p>根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><h1 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：</p><h3 id="基本可用-Basically-Available"><a href="#基本可用-Basically-Available" class="headerlink" title="基本可用 | Basically Available"></a>基本可用 | Basically Available</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性 — 注意，这绝不等价于系统不可用。比如：</p><p>（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；</p><p>（2）系统功能上的损失。正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；</p><h3 id="软状态-Soft-state"><a href="#软状态-Soft-state" class="headerlink" title="软状态 | Soft state"></a>软状态 | Soft state</h3><p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；</p><h3 id="最终一致性-Eventually-consistent"><a href="#最终一致性-Eventually-consistent" class="headerlink" title="最终一致性 | Eventually consistent"></a>最终一致性 | Eventually consistent</h3><p>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于分布式系统的项目，使用中没有强制要求一定是CAP中要达到某几种，具体根据各自业务场景所需来制定相应的策略而选择适合的产品服务等。例如：支付订单场景中，由于分布式本身就在数据一致性上面很难保证，从A服务到B服务的订单数据有可能由于服务宕机或其他原因而造成数据不一致性。因此此类场景会酌情考虑：AP，不强制保证数据一致性，但保证数据最终一致性。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Cloud-2-2」-- Eureka内部机制及源码分析</title>
      <link href="/maple/2023/05/16/Spring-Cloud-2-2-Eureka%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/maple/2023/05/16/Spring-Cloud-2-2-Eureka%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka-内部机制及源码分析"><a href="#Eureka-内部机制及源码分析" class="headerlink" title="Eureka 内部机制及源码分析"></a>Eureka 内部机制及源码分析</h1><h2 id="Eureka-运作原理"><a href="#Eureka-运作原理" class="headerlink" title="Eureka 运作原理"></a>Eureka 运作原理</h2><p>Eureka-server 对外提供的是 restful 风格的服务，以http动词的形式对url资源进行操作：<code>get</code>、 <code>post</code>、 <code>put</code>、 <code>delete</code>，只要利用这些restful接口我们就能对项目实现注册和发现，只不过eureka已经帮我们使用java语言封装好了client端的代码，让开发者只需要在项目中依赖Eureka Client就能实现注册和发现。</p><p><strong>只要能发起 Http 请求，那就可以向Eureka Server进行服务注册和发现，不管是什么语言。</strong></p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>当Eureka Client项目启动时，就会向Eureka Server发送自己的元数据（原始数据），如：运行的 ip、端口 port、健康的状态监控等。使用的是HTTP/ResuFul 请求风格。Eureka Server会在自己内部保留这些元数据（JVM内存中），形成一个服务列表。注册过程中为避免网络问题，会尝试3次。Eureka提供的是ResutFul风格的HTTP请求，Eureka封装的Java客户端底层使用的是<a href="https://baike.baidu.com/item/Jersey/17577306?fr=aladdin">Jersey框架</a>进行HTTP请求。</p><h4 id="注册调用链路"><a href="#注册调用链路" class="headerlink" title="注册调用链路"></a>注册调用链路</h4><img src="eureka6.png" style="zoom:90%;"><h4 id="核心类-com-netflix-discovery-DiscoveryClient"><a href="#核心类-com-netflix-discovery-DiscoveryClient" class="headerlink" title="核心类 com.netflix.discovery.DiscoveryClient"></a>核心类 com.netflix.discovery.DiscoveryClient</h4><p><strong>注册方法 | com.netflix.discovery.DiscoveryClient#register( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register with the eureka service by making the appropriate REST call.</span></span><br><span class="line"><span class="comment">   * Eureka Client注册方法入口.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">&quot;&#123;&#125;: registering service...&quot;</span>, appPathIdentifier);</span><br><span class="line">  EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Eureka Client向目标URL进行注册，其实就是将实例的具体信息发送至Eureka Server端</span></span><br><span class="line">    httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.warn(PREFIX + <span class="string">&quot;&#123;&#125; - registration failed &#123;&#125;&quot;</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(PREFIX + <span class="string">&quot;&#123;&#125; - registration status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重试封装层 | com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient#execute()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;R&gt; EurekaHttpResponse&lt;R&gt; <span class="title function_">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> &#123;</span><br><span class="line">  List&lt;EurekaEndpoint&gt; candidateHosts = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">endpointIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123; <span class="comment">// numberOfRetries固定值，默认为3次，当注册失败时会自动尝试3次</span></span><br><span class="line">    <span class="type">EurekaHttpClient</span> <span class="variable">currentHttpClient</span> <span class="operator">=</span> delegate.get();</span><br><span class="line">    <span class="type">EurekaEndpoint</span> <span class="variable">currentEndpoint</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (currentHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (candidateHosts == <span class="literal">null</span>) &#123;</span><br><span class="line">        candidateHosts = getHostCandidates();</span><br><span class="line">        <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransportException</span>(<span class="string">&quot;There is no known eureka server; cluster server list is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransportException</span>(<span class="string">&quot;Cannot execute request on any known server&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      currentEndpoint = candidateHosts.get(endpointIdx++);</span><br><span class="line">      currentHttpClient = clientFactory.newClient(currentEndpoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注册</span></span><br><span class="line">      EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</span><br><span class="line">      <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</span><br><span class="line">        delegate.set(currentHttpClient);</span><br><span class="line">        <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Request execution succeeded on retry #&#123;&#125;&quot;</span>, retry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      logger.warn(<span class="string">&quot;Request execution failure with status code &#123;&#125;; retrying on another server if available&quot;</span>, response.getStatusCode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Request execution failed with message: &#123;&#125;&quot;</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></span><br><span class="line">    delegate.compareAndSet(currentHttpClient, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (currentEndpoint != <span class="literal">null</span>) &#123;</span><br><span class="line">      quarantineSet.add(currentEndpoint);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransportException</span>(<span class="string">&quot;Retry limit reached; giving up on completing the request&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Jersey封装层 | com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient#register</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title function_">register</span><span class="params">(InstanceInfo info)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> <span class="string">&quot;apps/&quot;</span> + info.getAppName();</span><br><span class="line">  <span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 底层使用Jersey框架进行RestFul风格的HTTP请求 | serviceUrl为目标Eureka Server的地址</span></span><br><span class="line">    <span class="type">Builder</span> <span class="variable">resourceBuilder</span> <span class="operator">=</span> jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br><span class="line">    addExtraHeaders(resourceBuilder);</span><br><span class="line">    response = resourceBuilder</span><br><span class="line">      .header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>) <span class="comment">// 压缩</span></span><br><span class="line">      .type(MediaType.APPLICATION_JSON_TYPE) <span class="comment">// json格式</span></span><br><span class="line">      .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">      .post(ClientResponse.class, info); <span class="comment">// POST请求</span></span><br><span class="line">    <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Jersey HTTP POST &#123;&#125;&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;&quot;</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                   response == <span class="literal">null</span> ? <span class="string">&quot;N/A&quot;</span> : response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">      response.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Eureka Client启动的时候，会向我们指定的 <code>serviceUrl</code> 发送请求，把自己节点的数据用json格式以post 请求的方式发送过到Eureka Server端。当返回的状态码为 <code>204</code> 的时候，表示注册成功。</p><h3 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h3><p>项目Eureka Client启动成功了，除了向Eureka Server注册自己成功，还会定时的向Eureka Server发送心跳请求，表示自己还活着。</p><h3 id="服务下线-主动下线"><a href="#服务下线-主动下线" class="headerlink" title="服务下线 | 主动下线"></a>服务下线 | 主动下线</h3><p>当项目关闭时，会给 eureka-server 报告，说明自己要下机了。</p><h3 id="服务剔除-主动剔除、被动下线"><a href="#服务剔除-主动剔除、被动下线" class="headerlink" title="服务剔除 | 主动剔除、被动下线"></a>服务剔除 | 主动剔除、被动下线</h3><p>当项目超过了指定时间没有向 eureka-server 汇报自己，那么 eureka-server 就会认为此节点死掉了，会把它剔除掉，也不会放流量和请求到此节点了。</p><p>注册中心有一个容器保留各个注册的服务的信息：IP、端口号、续约时间、健康状态等等。</p><p>注册中心有一个剔除机制（定时删除下线的客户端）。</p><p>客户端可以设置续约时间（心跳）。</p><p>客户端可以从注册中心的拉取一份服务列表信息缓存到本地，但是会有脏读问题。</p><p>客户端可以设置拉取服务列表的时间间隔，时间间隔越短，脏读问题出现的概率越小，但是对客户端性能会有影响。</p><h3 id="Eureka保护机制"><a href="#Eureka保护机制" class="headerlink" title="Eureka保护机制"></a>Eureka保护机制</h3><p>正常情况下Eureka Server接收心跳失败的比率在15分钟之内，低于85%的节点，Eureka server会认为这个实例出现了网络故障，直接删除这个有问题的服务。这样在网络抖动和网络不稳定的情况下就会出现误删除有效的Eureka Client。Eureka Server保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。为了防止Eureka Client可以正常运行，但是与Eureka Server网络不畅通情况下（网络延迟等原因），在保护模式开启的情况下，Eureka Server不会立刻将Eureka Client服务剔除，以避免误删除。</p><p>Eureka保护机制的核心就是AP！</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="comment"># server配置,eureka-server既是服务端又是客户端,也就是说,它不仅可以提供客户端注册,同时本身也可以注册到其他server上.</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">10000</span> <span class="comment"># 服务端定时剔除下线的实例信息的间隔时间/ms</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment"># 续约百分比,超过85%的应用没有发送心跳续约,那么eureka会保护服务,不会剔除任何一个实例(eureka会认为是自己的网络问题,AP)</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span> <span class="comment"># Eureka Server的自我保护机制,避免因为网络原因造成误删除,生产环境建议打开</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">instance:</span> <span class="comment"># instance实例配置</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="comment"># 实例ID名称: 主机名:应用名:端口号</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># 主机名称或者服务节点IP</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 服务列表以IP形式展示</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 服务实例的心跳续约时间间隔,需要比上面的eviction-interval-timer-in-ms配置值小</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">20</span> <span class="comment"># Eureka Server至上一次收到Eureka Client心跳之后,等待下一次心跳的超时时间,这个时间内若没有收到下一次心跳,就剔除该客户端实例.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 指定注册中心的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVER_URL:http://localhost:8761/eureka&#125;</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="string">$&#123;REGISTER_WITH_EUREKA:false&#125;</span> <span class="comment"># 先将server自己注册自己关掉|默认是开启的(集群模式需要开启,单机一般关闭)</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 应用是否去拉取服务列表到本地</span></span><br></pre></td></tr></table></figure><h4 id="保护流程"><a href="#保护流程" class="headerlink" title="保护流程"></a>保护流程</h4><ol><li>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比（这个15分钟是在源码当中有个每15分钟执行一次的定时任务），如果低于85%就会触发自我保护机制。</li><li>触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期，但这些服务也并不是永远不会过期（该现象可能出现在如果网络不通但是EurekaClient未出现岩机）。</li><li>Eureka在启动完成后，每隔60秒会检查一次服务健康状态（这个10秒就是上面提到的Eureka Server查看心跳是否收到默认的配置：eviction-interval-timer-in-ms）</li><li>如果这些被保护起来失效的服务过一段时间后（默认90秒，这个20秒就是上面提到的心跳最大等待时间：lease-expiration-duration-in-seconds）还是没有恢复，就会把这些服务剔除。如果在此期间服务恢复了并且实例心跳占比高于85%时，就会自动关闭自我保护机制。</li></ol><p>如果换做别的注册中心，如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的。</p><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://blog.csdn.net/qq_43170213/article/details/115049535">Spring Cloud Eureka</a></li><li><a href="https://blog.csdn.net/weixin_43888891/article/details/125325794">什么是Eureka？</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Cloud-2-1」-- Eureka Quick Start</title>
      <link href="/maple/2023/05/16/Spring%20Cloud2-Eureka/"/>
      <url>/maple/2023/05/16/Spring%20Cloud2-Eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h1><p>Eureka是服务注册发现中心。Eureka 来源于古希腊词汇，意为“发现了”。在软件领域， Eureka是Netflix公司开源的一个<strong>服务注册与发现</strong>的组件，和Netflix公司其它的一些服务组件(例如：负载均衡、 熔断器、网关等) 一起被Spring Cloud社区整合为Spring Cloud Netflix模块。 Eureka是Netflix贡献给Spring Cloud的一个开源框架。</p><p>同为注册中心，相比动物管理员Zookeeper，Spring Cloud Eureka有什么区别呢？</p><p><strong><font color="green">核心点在于分布式微服务中的CAP定理！</font></strong></p><blockquote><p><strong>问：为什么 Zookeeper 不适合做注册中心?</strong></p><p>Zookeeper 注重数据的一致性，Eureka 则侧重服务的可用性。</p><ul><li>在 Zookeeper中，若Leader挂了，则Zookeeper集群整体不对外提供服务了，直到重新选举出一个新的Leader出来(选举时间大约120s 左右)，才能继续对外提供服务。</li><li>Eureka注重服务的可用性，当Eureka集群只要有一台活着，它就能对外提供服务。</li></ul><p><strong>Zookeeper是CP，而Eureka是AP</strong>，</p><p>CAP理论相关请见博文：<a href="/maple/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA">浅析CAP理论&amp;Base理论</a> </p></blockquote><h2 id="Eureka-Quick-Start-Demo"><a href="#Eureka-Quick-Start-Demo" class="headerlink" title="Eureka Quick Start Demo"></a>Eureka Quick Start Demo</h2><h3 id="单Eureka-Server"><a href="#单Eureka-Server" class="headerlink" title="单Eureka Server"></a>单Eureka Server</h3><p>设计一个Eureka的快速开始Demo，结果如下图所示：</p><img src="eureka1.png" style="zoom: 33%;"><p>Eureka Server作为服务注册中心，向所有Eureka Client提供服务注册的能力（Eureka Server自身具备Eureka Client一样的注册能力，单机部署Eureka Server时体现不出来，集群模式部署Eureka Server的时候就体现出来了，因为各个Eureka Server相互之间也是需要进行注册），所有注册的Eureka Client都可以和Eureka Server进行通信，请求获取注册到Eureka Server上的Eureka Client的服务列表，这就是服务发现。</p><p>在实际开发中，如果使用Eureka进行服务治理，一般都是单独创建一个Eureka Server应用作为服务注册中心独立部署。不过由于Eureka版本的停更，同时其他注册中心组件Nacos、Consul等出现，可能项目开发中使用Eureka的场景越来越少了，但有些旧的微服务代码中还是有Eureka的痕迹，可以作为学习了解的对象。</p><blockquote><p>Eureka Demo地址：<a href="https://gitee.com/maple_eitba/maple-springcloud/tree/master/maple-eureka">Eureka Quick Start Demo</a></p></blockquote><h4 id="Eureka的UI"><a href="#Eureka的UI" class="headerlink" title="Eureka的UI"></a>Eureka的UI</h4><p>代码运行执行，访问：<code>http://localhost:8761/</code>，如下图：</p><img src="eureka2.png" style="zoom: 50%;"><p>其中：</p><p>Status表示服务节点的状态：</p><ul><li><strong>UP</strong>: 服务是上线的，括号里面是具体服务实例的个数，提供服务的最小单元 ；</li><li><strong>DOWN</strong>: 服务是下线的；</li><li><strong>UN_KONW</strong>: 服务的状态未知；</li></ul><h4 id="Eureka-Server的配置"><a href="#Eureka-Server的配置" class="headerlink" title="Eureka Server的配置"></a>Eureka Server的配置</h4><p>常用的配置项如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="comment"># 如果Eureka的client配置中没有指定注册中心的地址service-url,并且自己注册自己配置没有关闭,那么应用的端口号就必须设置为8761,否则Eureka</span></span><br><span class="line"><span class="comment"># 启动之后会抛出异常,并且无法成功注册到Eureka Server上.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server-1</span>  <span class="comment"># 应用名称,不要使用特殊字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka的配置分为三类: server配置, client配置, instance实例配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="comment"># server配置,eureka-server既是服务端又是客户端,也就是说,它不仅可以提供客户端注册,同时本身也可以注册到其他server上.</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">10000</span> <span class="comment"># 服务端定时剔除下线的实例信息的间隔时间/ms</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment"># 续约百分比,超过85%的应用没有发送心跳续约,那么eureka会保护服务,不会剔除任何一个实例(eureka会认为是自己的网络问题,AP)</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span> <span class="comment"># Eureka Server的自我保护机制,避免因为网络原因造成误删除,生产环境建议打开</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">instance:</span> <span class="comment"># instance实例配置</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="comment"># 实例ID名称: 主机名:应用名:端口号</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># 主机名称或者服务节点IP</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 服务列表以IP形式展示</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 服务实例的心跳续约时间间隔,需要比上面的eviction-interval-timer-in-ms配置值小</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">20</span> <span class="comment"># Eureka Server至上一次收到Eureka Client心跳之后,等待下一次心跳的超时时间,这个时间内若没有收到下一次心跳,就剔除该客户端实例.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 指定注册中心的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVER_URL:http://localhost:8761/eureka&#125;</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="string">$&#123;REGISTER_WITH_EUREKA:false&#125;</span> <span class="comment"># 先将server自己注册自己关掉|默认是开启的(集群模式需要开启,单机一般关闭)</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 应用是否去拉取服务列表到本地</span></span><br></pre></td></tr></table></figure><p>关于端口port的配置需要注意，如果Eureka的client配置中没有指定注册中心的地址service-url，并且自己注册自己配置没有关闭，那么应用的端口号就必须设置为8761，否则Eureka启动之后会抛出异常，并且无法成功注册到Eureka Server上。异常信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">2023-05-16 18:13:00.233  INFO 54488 --- [extShutdownHook] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application EUREKA-SERVER-1 with eureka with status DOWN</span><br><span class="line">2023-05-16 18:13:00.233  INFO 54488 --- [extShutdownHook] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1684231980233, current=DOWN, previous=UP]</span><br><span class="line">2023-05-16 18:13:00.234  INFO 54488 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_EUREKA-SERVER-1/localhost:eureka-server-1:8762: registering service...</span><br><span class="line">2023-05-16 18:13:00.235  INFO 54488 --- [nfoReplicator-0] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint&#123; serviceUrl=&#x27;http://localhost:8761/eureka/&#125;, exception=java.net.ConnectException: Connection refused (Connection refused) stacktrace=com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:187)</span><br><span class="line">at com.sun.jersey.api.client.filter.GZIPContentEncodingFilter.handle(GZIPContentEncodingFilter.java:123)</span><br><span class="line">at com.netflix.discovery.EurekaIdentityHeaderFilter.handle(EurekaIdentityHeaderFilter.java:27)</span><br><span class="line">at com.sun.jersey.api.client.Client.handle(Client.java:652)</span><br><span class="line">at com.sun.jersey.api.client.WebResource.handle(WebResource.java:682)</span><br><span class="line">at com.sun.jersey.api.client.WebResource.access$200(WebResource.java:74)</span><br><span class="line">at com.sun.jersey.api.client.WebResource$Builder.post(WebResource.java:570)</span><br><span class="line">at com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient.register(AbstractJerseyEurekaHttpClient.java:57)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient.execute(MetricsCollectingEurekaHttpClient.java:73)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:876)</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">at org.apache.http.conn.scheme.PlainSocketFactory.connectSocket(PlainSocketFactory.java:121)</span><br><span class="line">at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:144)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:134)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:605)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:440)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:118)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)</span><br><span class="line">at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:173)</span><br><span class="line">... 30 more</span><br><span class="line"></span><br><span class="line">2023-05-16 18:13:00.235  WARN 54488 --- [nfoReplicator-0] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">2023-05-16 18:13:00.236  WARN 54488 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_EUREKA-SERVER-1/localhost:eureka-server-1:8762 - registration failed Cannot execute request on any known server</span><br><span class="line"></span><br><span class="line">com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:876) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121) [eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101) [eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]</span><br><span class="line"></span><br><span class="line">2023-05-16 18:13:00.236  WARN 54488 --- [nfoReplicator-0] c.n.discovery.InstanceInfoReplicator     : There was a problem with the instance info replicator</span><br><span class="line"></span><br><span class="line">com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:876) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101) [eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]</span><br></pre></td></tr></table></figure><p><strong>原因分析：</strong></p><p>因为Eureka Server中如果没有配置注册中心的地址，并且Eureka Server会注册的本身时，Eureka Sever在启动之后就会使用源码中默认的硬编码写的URL地址为：<code>http://localhost:8761</code>，尝试对本身进行注册。从上述异常中的代码调用链中追溯可以找到源码中默认配置类为：</p><p><code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default Eureka URL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8761&quot;</span> + DEFAULT_PREFIX+ <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default availability zone if none is resolved based on region.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_ZONE</span> <span class="operator">=</span> <span class="string">&quot;defaultZone&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serviceUrl初始化时会放入默认的Map集合：</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();&#123;</span><br><span class="line">  <span class="built_in">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法就是配置文件中的，eureka:client:service-url配置项，如果没有配置，其中就只有默认的URL，</span></span><br><span class="line"><span class="comment">// Eureka Server注册自身的时候就会向http://localhost:8761发送注册请求，如果端口号不是8761，</span></span><br><span class="line"><span class="comment">// 就会抛出上述异常信息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServiceUrl</span><span class="params">(Map&lt;String, String&gt; serviceUrl)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.serviceUrl = serviceUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集群Eureka-Server"><a href="#集群Eureka-Server" class="headerlink" title="集群Eureka Server"></a>集群Eureka Server</h3><p><strong>集群Demo架构图</strong></p><img src="eureka3.png" style="zoom:50%;"><blockquote><p>Eureka Demo地址：<a href="https://gitee.com/maple_eitba/maple-springcloud/tree/master/maple-eureka">Eureka Quick Start Demo</a></p><p>在本地部署Eureka Server集群时需要注意，如果所有的Eureka Server的IP都是本机，Eureka会认为只是同一个服务启动了多台，其间并没有数据交互，不是集群，需要修改操作系统的配置文件自定义IP地址别名，然后在Eureka Server配置文件中利用别名以示区分即可。</p></blockquote><p>Eureka Server集群是去中心化设计，没有主从的概念，所有的节点都是对等的，每个节点互相注册，只要集群中各有一个节点存活，就能对外提供服务注册和服务发现能力，保证服务的可用性。</p><blockquote><p>Eureka是AP，没有主从，<font color="red"><strong>一旦有主从就会涉及到主从的选举，同步会造成一定的时间内不可用。</strong></font></p></blockquote><p><strong>Eureka Server集群内部数据流图：</strong></p><img src="eureka4.png" style="zoom: 67%;"><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://blog.csdn.net/qq_43170213/article/details/115049535">Spring Cloud Eureka</a></li><li><a href="https://blog.csdn.net/weixin_43888891/article/details/125325794">什么是Eureka？</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Cloud - 1」-- 浅析分布式架构和微服务架构</title>
      <link href="/maple/2023/05/16/Spring%20Cloud1-%E5%88%86%E5%B8%83%E5%BC%8Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/maple/2023/05/16/Spring%20Cloud1-%E5%88%86%E5%B8%83%E5%BC%8Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析分布式架构和微服务架构"><a href="#浅析分布式架构和微服务架构" class="headerlink" title="浅析分布式架构和微服务架构"></a>浅析分布式架构和微服务架构</h1><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p>在《分布式系统原理与范型》一书中有如下定义：</p><blockquote><p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p></blockquote><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储等任务。其目的是利用更多的机器，处理更多的数据。</p><p><strong>分布式系统（distributed system）是建立在网络之上的软件系统。</strong></p><p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、提升CPU核数）无法明显改善时，应用程序也无法进一步优化的场景，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。</p><p>因此，随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。</p><blockquote><p>分布式的典型代表：Dubbo。当然了，Dubbo现在也提供了微服务的生态。</p></blockquote><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>任何技术的演进都是有迹可循的，任何新技术的出现都是为了解决原有技术无法解决的需求，所以，微服务的出现就是因为原来单体应用架构已经无法满足当前互联网产品的技术需求。微服务的设计就是为了解决不因为某个模块的升级和BUG影响整体的系统业务。</p><p><strong>微服务架构，核心就是为了解决应用微服务化之后的服务治理问题。</strong></p><p>在微服务架构之前还有一个概念：SOA（Service-Oriented Architecture）– 面向服务的体系架构。</p><p>微服务的特征：</p><p>单一职责的。一个微服务应该都是单一职责的，这才是“微”的体现，一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。<br>面向服务的。将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能使用到其它微服务的能力。</p><p>应用微服务化之后，会出现一些问题：</p><ul><li>服务发现问题。一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时利用服务发现机制可以从服务注册中心获取当前可用的服务清单。</li><li>服务配置管理的问题。当服务数量超过一定程度之后，如果需要在每个服务里面分别维护每一个服务的配置文件，运维人员估计要哭了。那么，就需要用到微服务架构里面第二个重要的组件：配置中心。</li><li>服务治理问题，当客户端或外部应用调用服务的时候怎么处理呢？服务A可能有多个节点，服务A、服务B和服务C的服务地址都不同，服务授权验证在哪里做？这时，就需要使用到服务网关提供统一的服务入口，最终形成典型微服务架构：</li></ul><img src="springcloud1.png" style="zoom:67%;"><p>这便是一个典型的微服务架构，当然微服务的服务治理还涉及很多内容，比如：</p><ul><li>通过熔断、限流等机制保证高可用；</li><li>微服务之间调用的负载均衡；</li><li>分布式事务（2PC、3PC、TCC、LCN等）；</li><li>服务调用链跟踪等等。</li></ul><p><font color="red"><strong>服务治理主要作用是改变运行时服务的行为和选址逻辑、限流熔断、负载权重、配置读写、日志追踪等目的。</strong></font></p><h2 id="分布式和微服务的区别"><a href="#分布式和微服务的区别" class="headerlink" title="分布式和微服务的区别"></a>分布式和微服务的区别</h2><p>分布式和微服的架构很相似，只是部署的方式不一样而已。分布式服务架构与微服务架构概念的区别与联系：</p><h3 id="分布式-–-分散压力"><a href="#分布式-–-分散压力" class="headerlink" title="分布式 – 分散压力"></a>分布式 – 分散压力</h3><ul><li>不同模块部署在不同服务器上;<ul><li>作用：分布式解决网站高并发带来性能问题；</li></ul></li><li>集群：相同的服务；<ul><li>多台服务器部署相同应用构成一个集群；</li><li>作用：通过负载均衡设备共同对外提供服务；</li></ul></li><li>SOA［组装服务/ESB企业服务总线］;<ul><li>业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力;</li><li>通过服务的组合和编排来实现上层的业务流程;</li><li>作用：简化维护，降低整体风险，伸缩灵活;</li></ul></li></ul><h3 id="微服务-–-分散能力"><a href="#微服务-–-分散能力" class="headerlink" title="微服务 – 分散能力"></a>微服务 – 分散能力</h3><ul><li>架构设计概念：各服务间隔离（分布式也是隔离），自治（分布式依赖整体组合），其它特性（单一职责，边界，异步通信，独立部署），是分布式概念更加严格的执行;</li><li>作用：各服务可独立应用，组合服务也可系统应用（巨石应用［monolith］的简化实现策略 – 平台思想）.</li></ul><blockquote><p>将所有功能都部署在一个web容器中运行的系统就叫做<strong>巨石应用</strong>。</p></blockquote><p><font color="red"><strong>核心：分布式重在资源共享与加快计算机计算速度。 分布式:分散压力。微服务:分散能力。</strong></font></p><blockquote><p><strong>问题：分布式是否属于微服务？</strong></p><p>关于这个问题，搜罗了蛮多博文，答案也不完全一致，有属于也有不属于。</p><p>个人理解：如果不对微服务的’微’字太较真，或者分布式节点上部署的应用业务粒度足够小，那可以认为分布式属于微服务。</p><p>但是反过来就不成立了。因为微服务就是将业务模块拆分成一个独立的服务单元，然后基于网络通信通过接口来实现数据的交互，微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，它可以是同一个服务器。这也是分布式和微服务的一个细微差别。</p></blockquote><h2 id="微服务架构的理解"><a href="#微服务架构的理解" class="headerlink" title="微服务架构的理解"></a>微服务架构的理解</h2><p>在应用的初始阶段，单体架构无论是在开发速度、运维难度上，还是服务器的成本上都有着显著的优势。在一个产品的前景不明确的初始阶段，使用单体架构是非常明智的选择。随着应用业务的发展和业务复杂度的提高，这种架构明显存在很多的不足，主要体现在以下 3 个方面: </p><ol><li>业务越来越复杂，单体应用的代码量越来越大，代码的可读性、可维护性和可扩展性下降， 新人接手代码所需的时间成倍增加，业务扩展带来的代价越来越大。</li><li>随着用户越来越多，程序承受的并发越来越高，单体应用的并发能力有限。</li><li>测试的难度越来越大，单体应用的业务都在同个程序中，随着业务的扩张、复杂度的增加， 单体应用修改业务或者增加业务或许会给其他业务带来定的影响，导致测试难度增加。</li></ol><p>微服务（不是一个框架 而是一种架构思想），是著名的 oo （面向对象， Object Oriented ）专家 Martin Fowler 提出来的，它是用来描述将软件应用程序设计为独立部署的服务的种特殊方式。微服务架将业务整体构按领域划分为独立的服务单元，有自动化运维、容错、快速演进的特点，它能够解决传统单体架构系统的痛点，同时也能满足越来越复杂的业务需求。</p><blockquote><p>Martin Fowler 对微服务的理解：</p><p>简而言之，微服务架构的风格，就是将单一程序开发成一个微服务， 每个微服务运行在自己的进程中，并使用轻量级通信机制，通常是 HTTP RESTFUL API 。这些服务围绕业务能力来划分构建的，并通过完全自动化部署机制来独立部署这些服务可以使用不同的编程语言，以及不同数据存储技术，以保证最低限度的集中式管理。</p></blockquote><h2 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h2><h3 id="微服务单元基于业务划分"><a href="#微服务单元基于业务划分" class="headerlink" title="微服务单元基于业务划分"></a>微服务单元基于业务划分</h3><p>微服务的“微”到底需要定义到什么样的程度，这是个非常难以界定的概念，可以从几个方面来界定: </p><ul><li>是根据代码量来定义，根据代码的多少来判断程序的大小: </li><li>是根据开发时间的长短来判断；</li><li>是根据业务粒度的大小来划分；</li></ul><p>根据 Martin Fowler 的定义，<strong>微服务的“微”是按照业务来划分的</strong> 。一个大的业务可以拆分成若干小的业务， 小的业务又可以拆分成若干更小的业务，业务到底怎么拆分才算合适，这需要开发人员根据领域划分和职责划分自己去决定。</p><h3 id="微服务基于HTTP协议进行通信"><a href="#微服务基于HTTP协议进行通信" class="headerlink" title="微服务基于HTTP协议进行通信"></a>微服务基于HTTP协议进行通信</h3><p>按照业务划分的微服务单元独立部署并运行在各自的进程中。微服务单元之间的通信方般倾向于使用 HTTP 这种简单的通信机制，更多的时候是使用 RESTfulAPI 。这种接受请求、处理业务逻辑、返回数据的 HTTP 模式非常高效，并且这种通机制与平台和语言无关。</p><h3 id="微服务的数据库独立"><a href="#微服务的数据库独立" class="headerlink" title="微服务的数据库独立"></a>微服务的数据库独立</h3><p>在单体架构中，所有的业务都共用一个数据库。随着业务量的增加，数据库的表的数量越来越多，难以管理和维护，并且数据量的增加会导致数据库服务器压力越来越大，查询速度越来越慢。 微服务的特点就是按业务划分服务，服务与服务之间无耦合，就数据库也是独立的，典型的微服务架构就是每个微服务都有自己独立的数据库，数据库之间没有何联系，这样做的好处在于随着业务的不断扩张，服务与服务之间不需要提供数据库集成，而是提供 API 接口相互调用，还有个好处是数据库独立，单业务的数据量少，易于维护，数据库性能有着明显的优势，数据库的迁移也很方便。</p><h3 id="微服务的自动化部署-CI-CD-持续集成-持续交付"><a href="#微服务的自动化部署-CI-CD-持续集成-持续交付" class="headerlink" title="微服务的自动化部署(CI /CD)(持续集成 持续交付)"></a>微服务的自动化部署(CI /CD)(持续集成 持续交付)</h3><p>在微服务架构中，系统会被拆分为若干个微服务，每个微服务又是一个独立的应用程序。单体架构的应用程序只需要部署一次，而微服务架构有多少个服务就需要部署多少次。随着服务数量的增加，如果微服务按照单体架构的部署方式，部署的难度会呈指数增加。业务的粒度划分得越细，微服务的数量就越多，这时需要更稳定的部署机制。随着技术的发展，尤其是 Docker 容器技术的推进，以及自动化部署工具（例如开源组件 Jenkins）的出现，微服务的自动化部署(CI持续集成 /CD持续交付)变得越来越简单。 自动化部署可以提高部署的效率，减少人为的控制，部署过程中出现错误的概率降低，部署过程的每一步自动化，提高软件的质量。构建一个自动化部署的系统，虽然在前期需要开发人员或者运维人员的学习，但对于整个软件系统来说是一个全新的概念。在软件系统的整个生命周期之中，每一步是由程序控制的，而不是人为控制，软件的质量提高到了一个新的高度。随着 DevOps 这种全新概念的推进，自动化部署必然会成为微服务部署的优配方式。</p><h3 id="微服务的集中化管理"><a href="#微服务的集中化管理" class="headerlink" title="微服务的集中化管理"></a>微服务的集中化管理</h3><p>微服务系统是按业务单元来划分服务的，服务数量越多，管理起来就越复杂，因此微服务必须使用集中化管理。目前流行的微服务框架中，例如： Spring Cloud 采用 Eureka、Nacos 等来进行注册服务和服务发现，另外， Zookeeper、 Consul 等业都是非常优秀的服务集中化管理框架。只不过基于CAP理论，这个开源框架的侧重点不同，开发者可以视业务场景选择合适的框架。</p><h3 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h3><p>为了防止“雪崩效应”事件的发生，分布式系统采用了熔断机制。在用 SpringCloud 构建的微服务系统中，采用了熔断器（即 Hystrix 组件的 Circuit Breaker）去做熔断。</p><h2 id="微服务的优劣势"><a href="#微服务的优劣势" class="headerlink" title="微服务的优劣势"></a>微服务的优劣势</h2><h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><p>相对于单体服务来说，微服务具有很多的优势，主要体现在以下方面。</p><ol><li>将一个复杂的业务分解成若干小的业务，每个业务拆分成一个服务，服务的边界明确，将复杂的问题简单化。服务按照业务拆分，代码也是按照业务来拆分，代码的可读性和可扩展性增加。</li><li>服务与服务之间没有耦合，随着业务的增加，可以根据业务再拆分服务，具有极强的横向扩展能力。随着应用的用户量的增加，井发量增加，可以将微服务集群化部署，从而增加系统的负载能力。简而言之，微服务系统的微服务单元具有很强的横向扩展能力。</li><li>服务与服务通过HTT网络通信协议来交互，单个微服务内部高度内聚，服务与服务之间完全独立，无耦合。这使得微服务可以采用任何的开发语言和技术来实现。开发人员不再被强迫使用公司以前的技术或者已经过时的技术，而是可以自由选择最适合业务场景的或者最适合自己的开发语言和技术，提高开发效率、降低开发成本。</li><li>如果是一个单体的应用，由于业务的复杂性、代码的耦合性，以及可能存在的历史问题。 在重写一个单体应用时，要求重写的应用的人员了解所有的业务，所以重写单体应用是非常困难的，并且重写风险也较高。如果是微服务系统，由于微服务系统是按照业务的进行拆分的，并且有坚实的服务边界，所以重写某个服务就相当于重写某一个业务的代码。</li><li>微服务在 CAP 理论中采用的是 AP 架构，即具有高可用和分区容错的特点。高可用主要体现在系统 7 x 24 小时不间断的服务，它要求系统有大量的服务器集群，从而提高了系统 的负载能力。另外，分区容错也使得系统更加健壮。</li></ol><h3 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h3><p>凡事都有两面性，微服务也不例外，微服务相对于单体应用来说具有很多的优势，当然也有它 的不足，主要体现在如下方面:</p><ol><li>微服务的复杂度</li><li>分布式事务问题。</li><li>服务的划分（按照功能划分还是按照组件来划分呢）分工 ，领域模型划分。</li><li>服务的部署（是否是自动化部署）。</li></ol><p>在微服务架构中，有三大难点，那就是<font color="cornflowerblue"><strong>服务故障的传播性(熔断)、服务划分 和 分布式事务</strong></font>。在微服务设计时，一定要考虑清楚这三个场景，从而选择合适的框架。目前比较流行的微服务框架有 Spring 社区的 Spring Cloud、 Google 公司的 Kubemetes 等。</p><ul><li>为了解决服务故障的传播性，一般的微服务框架都有熔断机制组件，如：Hystrix、Sentinel等。</li><li>服务的划分是标准的划分方案的，一般来说根据业务来划分服务，领域驱动设计具有指导作用。</li><li>分布式事务一般的解决办法就是两阶段提交或者三阶段提 交，不管使用哪一种都存在事务失败导致数据不一致的情况，关键时刻还得人工去恢复数据。</li></ul><p> 总之，微服务的设计一定是渐进式的，并且是随着业务的发展而发展的。</p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud 作为 Java 语言的微服务框架，它依赖于 Spring Boot，有快速开发、持续交付和容易部署等特点。 Spring Cloud 的组件非常多，涉及微服务的方方面面，井在开源社区 Spring 和 Netflix、 Pivotal 两大公司的推动下越来越完善，如今 alibaba 也加入到其中。Spring Cloud 在开发部署上继承了Spring Boot 的一些优点，提高其在开发和部署上的效率。 Spring Cloud 的首要目标就是通过提供一系列开发组件和框架，帮助开发者迅速搭建一个分布式的微服务系统。 Spring Cloud 是通过包装其他技术框架来实现的，其提供了开发分布式微服务系统的一些常用组件，例如：服务注册和发现、 配置中心、熔断器、远程调用，路由、微代理、控制总线、全局锁、分布式会话等。</p><h3 id="SpringCloud-常用组件表"><a href="#SpringCloud-常用组件表" class="headerlink" title="SpringCloud 常用组件表"></a>SpringCloud 常用组件表</h3><table><thead><tr><th>组件功能</th><th>组件名称</th></tr></thead><tbody><tr><td>服务的注册和发现</td><td>Eureka、Nacos、Consul</td></tr><tr><td>服务的负载均衡</td><td>Ribbon – 负载均衡 + 服务调用 <br> Dubbo（严格的说，Dubbo只是内部集成了LoadBalance的能力，一般并不会作为负载均衡器使用）</td></tr><tr><td>服务的相互调用</td><td>OpenFeign – 基于Controller的restful风格的HTTP协议进行网络通信 <br>Dubbo – 基于Netty进行网络通信</td></tr><tr><td>服务的容错</td><td>Hystrix、Sentinel</td></tr><tr><td>服务网关</td><td>Gateway、Zuul</td></tr><tr><td>服务配置的统一管理</td><td>Config-server、Nacos、Apollo</td></tr><tr><td>服务消息总线</td><td>Bus</td></tr><tr><td>服务安全组件</td><td>Security、Oauth2.0</td></tr><tr><td>服务监控</td><td>Admin、jvm</td></tr><tr><td>链路追踪</td><td>Sleuth、Zipkin</td></tr></tbody></table><p>SpringCloud 只是微服务架构的一种具体实现方式，目前开发中常用的落地实现有三种:</p><ul><li>Dubbo + Zookeeper 半自动化的微服务实现架构</li><li>SpringCloud Netflix 一站式微服务架构</li><li>SpringCloud Alibaba 新的一站式微服务架构</li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/qq_43842093/article/details/122612285">分布式和微服务是什么？二者的区别又是什么？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon</title>
      <link href="/maple/2023/05/15/Spring%20Cloud3-Ribbon/"/>
      <url>/maple/2023/05/15/Spring%20Cloud3-Ribbon/</url>
      
        <content type="html"><![CDATA[<p>轮训算法的实现</p><p><code>%</code>取模运算的结果得到一个整型的周期函数，让得到的结果总是小于除数的。</p><ul><li>1 % 2 = 1</li><li>2 % 2 = 0</li><li>3 % 2 = 1</li><li>4 % 2 =0</li><li>…</li></ul><p>这样就得到一个[0,1]区间的一个周期函数。</p><p>CAS在Java层面是无锁的状态，但是在JVM层面还是有锁的，总线锁或者缓存锁。</p><p>基于CAS的自旋锁，如果有线程同时操作可能会导致短暂的CPU飙升，还有总所周知的ABA问题。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SPI</title>
      <link href="/maple/2023/05/15/Java-SPI/"/>
      <url>/maple/2023/05/15/Java-SPI/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>SPI（Service Provider Interface），是一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，其核心是基于“<strong>面向接口编程＋策略模式＋配置文件</strong>”组合实现的<font color="red"><strong>动态加载机制</strong></font>。</p><blockquote><p>SPI是一种机制，Java SPI只是它的其中一种实现。</p></blockquote><p>SPI整体机制如图：</p><img src="b9a8c10eb304b7ea80f005eba6492199.jpeg" alt="img" style="zoom: 40%;"><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类的全路径名。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行反射加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><h2 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h2><p>在现今的微服务的框架下，我们最常见的是提供API服务，也就是接口和实现都部署在同一个集群中，向外通过Http/Rpc协议进行暴露，外部调用方通过引入jar包的方式，使用我们的服务，常用的框架，如：Dubbo，Feign，Ribbon等便是如此。</p><p>这里实际包含两个问题，<strong>第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？</strong></p><p><strong>SPI接口位于调用方所在的包中</strong></p><ul><li>概念上更依赖调用方。</li><li>组织上位于调用方所在的包中。</li><li>实现位于独立的包中。</li><li>常见的例子是：插件模式的插件。</li><li>例如：<ul><li>数据库驱动加载接口实现类的加载 – JDBC加载不同类型数据库的驱动；</li><li>日志门面接口实现类加载 – SLF4J加载不同提供商的日志实现类；</li><li>Spring – Spring中大量使用了SPI，比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI（Converter SPI、Formatter SPI）等；</li><li>Dubbo – Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口；</li></ul></li></ul><blockquote><p>JDK中原生SPI接口，请参考博文：<a href="https://xie.infoq.cn/article/3747510d5b814e43792c3886f">Java Core「6」反射与 SPI 机制</a></p></blockquote><p><strong>API接口位于实现方所在的包中</strong></p><ul><li>概念上更接近实现方。</li><li>组织上位于实现方所在的包中。</li><li>实现和接口在一个包中。<ul><li>例如：微服务中提供的接口API，OpenFeign中的所有Controller层方法。</li></ul></li></ul><h2 id="SPI-的使用"><a href="#SPI-的使用" class="headerlink" title="SPI 的使用"></a>SPI 的使用</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>SPI一般使用在一个接口有多个实现的场景，可以在外界无感的情况下实现接口实现的动态切换，内部会有一个类的动态加载的过程。</p><blockquote><h2 id="动态类加载"><a href="#动态类加载" class="headerlink" title="动态类加载"></a>动态类加载</h2><h3 id="类的动态加载有两种方式："><a href="#类的动态加载有两种方式：" class="headerlink" title="类的动态加载有两种方式："></a>类的动态加载有两种方式：</h3><ul><li><strong>自定义类加载器ClassLoader在代码运行时来进行加载指定的类</strong><ul><li>ClassLoader 类：ClassLoader 是用于加载类的一个抽象类，Java 提供了多种实现，比如 URLClassLoader 和 AppClassLoader。使用 ClassLoader 加载类的方式更加灵活，可以从不同的位置加载类，比如本地文件系统、网络等等。</li></ul></li><li><strong>反射（SPI是基于反射实现的）</strong><ul><li><code>Class.forName()</code> 方法：该方法根据类的完整路径名加载类，返回对应的 Class 对象。需要注意的是，该方法可能会抛出 <code>ClassNotFoundException</code> 异常，需要进行捕获或声明抛出。</li></ul></li></ul><h3 id="Class-forName-和-ClassLoader-的区别"><a href="#Class-forName-和-ClassLoader-的区别" class="headerlink" title="Class.forName() 和 ClassLoader 的区别"></a>Class.forName() 和 ClassLoader 的区别</h3><p>使用 <code>Class.forName()</code> 加载类时，会自动初始化该类，包括执行静态代码块和初始化静态成员变量。而使用 ClassLoader 加载类时，可以控制类的初始化时机，只有在需要使用类时才会进行初始化。</p><h3 id="加载外部类和本地类的区别"><a href="#加载外部类和本地类的区别" class="headerlink" title="加载外部类和本地类的区别"></a>加载外部类和本地类的区别</h3><p>Java 中的类可以分为两类：<strong>外部类</strong>和<strong>本地类</strong>。<strong>外部类是指存储在磁盘上的类文件</strong>，而<strong>本地类是指在当前程序中定义的类</strong>。</p><p>加载外部类时需要指定类文件的路径，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.maple.MyClass&quot;</span>, <span class="literal">true</span>, ClassLoader.getSystemClassLoader());</span><br></pre></td></tr></table></figure><p>其中：第一个参数是类的完整路径名，第二个参数表示是否进行初始化，第三个参数是 ClassLoader。</p><p>加载本地类则可以直接使用目标类，这是利用Java类加载机制，默认是懒加载的，用到的时候才会进行加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>定义一个顶层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RobotInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一些底层实现<br>实现1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.jdk.spi.intf.RobotInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">RobotInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m Bumblebee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">RobotInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个配置文件，特定目录下，特定名称，特定内容<br>在类路径（Spring架构下是src/main/resources 下即可）下创建<code>/META-INF/services</code>文件夹，然后文件夹里创建<strong>以顶层接口全路径为名的文件</strong>，如图：</p><img src="spi3.png" style="zoom:80%;"><p>文件内容为每一个实现类的全路径为一行，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.jdk.spi.impl.Bumblebee</span><br><span class="line">com.jdk.spi.impl.OptimusPrime</span><br></pre></td></tr></table></figure><p>测试SPI：</p><p>执行过程：根据入参获取META-INF/services/目录下的目标配置文件，一行一行读取配置内容得到所有实现类的全路径，最后通过反射进行实例化并调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">// 默认使用的是线程上下文类加载器,但是JDK默认是没有具体的实现,而是使用系统类加载器作为线程上下文类加载器来使用.</span></span><br><span class="line">  <span class="comment">// 到此也只是完成了目标类和对应的类加载器的封装 -- 懒加载迭代器.</span></span><br><span class="line">  ServiceLoader&lt;RobotInterface&gt; serviceLoader = ServiceLoader.load(RobotInterface.class);</span><br><span class="line">  <span class="comment">// 执行迭代器的时候才进行类加载并通过反射实例化对象,最后调用目标方法.</span></span><br><span class="line">  serviceLoader.forEach(RobotInterface::sayHello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, I&#x27;m Bumblebee</span><br><span class="line">Hello, I&#x27;m Optimus Prime.</span><br></pre></td></tr></table></figure><h2 id="SPI的优缺点"><a href="#SPI的优缺点" class="headerlink" title="SPI的优缺点"></a>SPI的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用Java SPI机制的优势是实现<strong>解耦</strong>，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类；</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的<code>META-INF/services</code>目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>注意到实现类的加载过程，是通过java.util.ServiceLoader进行实现。通过iterator，遍历每一个实现类，而没有按需加载。</p><ul><li>不能按需加载。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化一遍。容易造成资源浪费。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式迭代获取，不能根据某个参数来获取对应的实现类。</li><li>多线程并发使用 ServiceLoader 类的实例存在安全隐患。</li><li>实现类不能通过有参构造器实例化。</li></ul><blockquote><p><strong>注意事项</strong><br><strong>接口实现类必须提供一个无参的构造器！，因为实例化接口实现类的时候是利用class.newInstance()方法，其是利用无参构造来实例化的。</strong></p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>其实就是利用线程上下文类加载器来对指定路径下的文件进行类加载，然后通过反射来实例化对象，核心就是<code>Class.forName()</code>，并封装成一个Iterable对象（LazyIterator懒迭代器），实现遍历调用。<br>LazyIterator 懒迭代器在执行迭代的时候才进行反射操作，并通过反射实例化对象，最后调用目标方法来完成具体业务执行。</p><p><strong>ServiceLoader.load()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定自定义类加载的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取线程线程的上下文类加载器</span></span><br><span class="line">  <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用线程上下文类加载器(如果为null, 就是用系统类加载器)对目标service接口的所有实现类进行加载, 并封装成为Iterator对象.</span></span><br><span class="line">  <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">  service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">  loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl; <span class="comment">// 线程上下文类加载器为空就使用系统类加载器</span></span><br><span class="line">  acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">  reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">  providers.clear(); <span class="comment">// 清空缓存</span></span><br><span class="line">  <span class="comment">// 懒加载的迭代器,即在开始进行迭代时才会执行类加载动作并通过反射创建对象并调用目标方法</span></span><br><span class="line">  lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LazyIterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">  <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">  nextName = <span class="literal">null</span>;</span><br><span class="line">  Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射进行类加载并获取到Class对象.</span></span><br><span class="line">    c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射实例化对象并进行类型转换.</span></span><br><span class="line">    <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">    providers.put(cn, p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，Java 应用运行的初始线程的上下文类加载器就是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 </p><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 <code>javax.xml.parsers</code>包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 <code>javax.xml.parsers.DocumentBuilderFactory</code>类中的 <code>newInstance()</code>方法用来生成一个新的 <code>DocumentBuilderFactory</code>的实例。这里的实例的真正的类是继承自 <code>javax.xml.parsers.DocumentBuilderFactory</code>，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 <code>org.apache.xerces.jaxp.DocumentBuilderFactoryImpl</code>。而问题在于<strong>，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的； SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的父类加载器。也就是说，类加载器的代理模式无法解决这个问题。线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。这就是JVM中常说的打破类加载的双亲委派模型。</strong></p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/2301_76607156/article/details/129425834">Java 反射：动态类加载和调用教程</a></p><p><a href="https://blog.csdn.net/qq_37080455/article/details/127970892">Java基础五大机制 —— SPI机制基础</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令</title>
      <link href="/maple/2023/05/12/Git/"/>
      <url>/maple/2023/05/12/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><p>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目<a href="https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/2511538?fromModule=lemma_inlink">版本管理</a>。</p><h2 id="Git仓库及命令执行的数据流图"><a href="#Git仓库及命令执行的数据流图" class="headerlink" title="Git仓库及命令执行的数据流图"></a>Git仓库及命令执行的数据流图</h2><img src="git1.png" style="zoom:70%;"><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>初始化一个Git仓库，在一个目录下执行该指令，表示将该目录初始化成一个Git本地工作区。</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add ."></a>git add .</h4><p>添加本地工作区下所有文件添加到到暂存区。</p><h4 id="git-commit-m-xxx"><a href="#git-commit-m-xxx" class="headerlink" title="git commit -m xxx"></a>git commit -m xxx</h4><p>将工作区的文件提交至本地仓库，并描述本次提交信息。</p><h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>从远程仓库获取最新版本数据到本地仓库，但不会自动merge到暂存区。最常见的场景如取回origin主机的master 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure><p>取回更新后，会返回一个<code>FETCH_HEAD</code> ，指的是fetch的branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro passport % git log -p FETCH_HEAD</span><br><span class="line">commit 2a89dc68df05b8e538daaad5e63083fbcf20f685 (origin/master, origin/HEAD)</span><br><span class="line">Merge: f74c0c3 d6e16b5</span><br><span class="line">Author: scmgit &lt;scmgit@geely.com&gt;</span><br><span class="line">Date:   Tue May 26 11:11:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;merge_20200522_145657&#x27; into &#x27;master&#x27;</span><br><span class="line">    </span><br><span class="line">    after release merge to maste</span><br><span class="line">    </span><br><span class="line">    See merge request j-farmer/passport!58</span><br><span class="line"></span><br><span class="line">commit d6e16b528e0bf80dd4c06619dc6f7160e2a65612</span><br><span class="line">Author: scmgit &lt;scmgit@geely.com&gt;</span><br><span class="line">Date:   Fri May 22 15:17:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    scm_change_version</span><br><span class="line"></span><br><span class="line">diff --git a/api/pom.xml b/api/pom.xml</span><br><span class="line">index cf78d01..e9483a7 100644</span><br><span class="line">--- a/api/pom.xml</span><br><span class="line">+++ b/api/pom.xml</span><br><span class="line">@@ -5,7 +5,7 @@</span><br><span class="line">     &lt;parent&gt;</span><br><span class="line">         &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">         &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">-        &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+        &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">     &lt;/parent&gt;</span><br><span class="line">     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">diff --git a/pom.xml b/pom.xml</span><br><span class="line">index 7716b9c..b020af7 100644</span><br><span class="line">--- a/pom.xml</span><br><span class="line">+++ b/pom.xml</span><br><span class="line">@@ -3,7 +3,7 @@</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">-  &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+  &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">   &lt;modules&gt;</span><br><span class="line">     &lt;module&gt;start&lt;/module&gt;</span><br><span class="line">     &lt;module&gt;service&lt;/module&gt;</span><br><span class="line">diff --git a/service/pom.xml b/service/pom.xml</span><br><span class="line">index 96feaea..6af8f12 100644</span><br><span class="line">--- a/service/pom.xml</span><br><span class="line">+++ b/service/pom.xml</span><br><span class="line">@@ -4,7 +4,7 @@</span><br><span class="line">     &lt;parent&gt;</span><br><span class="line">         &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">         &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">-        &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+        &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">     &lt;/parent&gt;</span><br><span class="line">     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">diff --git a/start/pom.xml b/start/pom.xml</span><br><span class="line">index e704136..1fdccae 100644</span><br><span class="line">--- a/start/pom.xml</span><br><span class="line">+++ b/start/pom.xml</span><br><span class="line">@@ -5,7 +5,7 @@</span><br><span class="line">     &lt;parent&gt;</span><br><span class="line">         &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">         &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">-        &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+        &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">     &lt;/parent&gt;</span><br><span class="line">     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">diff --git a/test/pom.xml b/test/pom.xml</span><br></pre></td></tr></table></figure><p>可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 </p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>从远程仓库拉取内容到本地，该命令的作用相当于下面两个命令的组合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master // 从远程主机的master分支拉取最新内容 </span><br><span class="line">git merge FETCH_HEAD    // 将拉取下来的最新内容合并到当前所在的分支中</span><br></pre></td></tr></table></figure><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>查看当前仓库的状态，即对是否哪些文件进行了修改|删除|增加等操作；</p><h4 id="git-diff-fileName"><a href="#git-diff-fileName" class="headerlink" title="git diff [fileName]"></a>git diff [fileName]</h4><p>查看所有文件[目标文件]在仓库中修改的具体信息（如果是新创建文件则无法查看修改），在第一次提交之后才能查看修改；如果输出信息太多自动分页，按 <code>q</code> 退出；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git diff</span><br><span class="line">diff --git a/test.json b/test.json</span><br><span class="line">index 5171a05..31fd6a8 100644</span><br><span class="line">--- a/test.json</span><br><span class="line">+++ b/test.json</span><br><span class="line">@@ -1 +1,4 @@</span><br><span class="line">-&#123;&quot;name&quot;:&quot;Maple&quot;&#125;</span><br><span class="line">+&#123;</span><br><span class="line"></span><br><span class="line">+   &quot;name&quot;:&quot;Maple&quot;,</span><br><span class="line">+   &quot;age&quot;:27</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>查看从近到远的提交日志信息，包含提交时的commit描述信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git log</span><br><span class="line">commit 7620e300373622ed19d784e37bbbea82a48678a6 (HEAD -&gt; master)</span><br><span class="line">Author: maple8 &lt;790379323@qq.com&gt;</span><br><span class="line">Date:   Tue May 26 17:43:10 2020 +0800</span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line"></span><br><span class="line">commit 74a85ad5cf670782f6df6a3f1a57cf7c0e42e41a</span><br><span class="line">Author: maple8 &lt;790379323@qq.com&gt;</span><br><span class="line">Date:   Tue May 26 17:37:53 2020 +0800</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><h4 id="git-log-–pretty-oneline"><a href="#git-log-–pretty-oneline" class="headerlink" title="git log –pretty=oneline"></a>git log –pretty=oneline</h4><p>仅显示一行提交的日志;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git log --pretty=oneline</span><br><span class="line">7620e300373622ed19d784e37bbbea82a48678a6 (HEAD -&gt; master) test1</span><br><span class="line">74a85ad5cf670782f6df6a3f1a57cf7c0e42e41a test</span><br></pre></td></tr></table></figure><p>其中: 7620e300373622ed19d784e37bbbea82a48678a6 称为提交版本号</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交7620e30…，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><h4 id="git-reset-–hard-提交的版本号"><a href="#git-reset-–hard-提交的版本号" class="headerlink" title="git reset –hard [提交的版本号]"></a>git reset –hard [提交的版本号]</h4><p>版本回退到最新的一次提交（就是最近的一次提交），也可以通过指定版本号进行回退。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git reset --hard HEAD^</span><br><span class="line">HEAD is now at 74a85ad test</span><br></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本时，Git仅移动HEAD指针即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br><span class="line">改为指向add distributed：</span><br><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令。</p><h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><p>记录每一次提交的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git reflog</span><br><span class="line">74a85ad (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">7620e30 HEAD@&#123;1&#125;: commit: test1</span><br><span class="line">74a85ad (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): test</span><br></pre></td></tr></table></figure><p>从输出可知，append GPL的commit id是7620e30，现在，你又可以乘坐时光机回到未来了。回退到原始版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git reset --hard 7620e30</span><br><span class="line">HEAD is now at 7620e30 test1</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><p>查看本地所有分支：<code>git branch</code></p></li><li><p>查看远程所有分支：<code>git branch -r</code></p></li><li><p>查看本地和远程的所有分支：<code>git branch -a</code> </p></li><li><p>创建本地分支：<code>git branch &lt;name&gt;</code></p></li><li><p>重命名本地分支：<code>git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt; 或者 git switch &lt;name&gt;</code></p></li><li><p>创建 + 切换分支：<code>git checkout -b &lt;name&gt; 或者 git switch -c &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>在merge的过程中可能会出现Conflict冲突，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">...</span><br><span class="line">当前分支上的内容</span><br><span class="line">=========</span><br><span class="line">...</span><br><span class="line">master分支合过来的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;master</span><br></pre></td></tr></table></figure></li><li><p>删除本地分支：<code>git branch -d &lt;name&gt;</code></p></li><li><p>删除远程分支：<code>git push origin --delete &lt;branchname&gt;</code> 或 <code>git branch -d -r &lt;branchname&gt;</code></p></li><li><p>本地分支推送至远程服务器：<code>git push origin &lt;branchname&gt;</code></p></li><li><p>查看远程仓库的信息 | 加上 -v 参数，查看更详细的信息：git remote<code>或</code>git remote -v`</p></li><li><p>新建本地分之并关联远程已存在的分支：<code>git checkout -b &lt;branchname&gt; origin/&lt;branchname&gt;</code></p></li></ul><h3 id="Git信息设置"><a href="#Git信息设置" class="headerlink" title="Git信息设置"></a>Git信息设置</h3><h4 id="设置git全局的名称和邮箱"><a href="#设置git全局的名称和邮箱" class="headerlink" title="设置git全局的名称和邮箱"></a>设置git全局的名称和邮箱</h4><p>查看当前应用git的提交名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>修改命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;新名称&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><h4 id="设置单个项目提交用户名和邮箱"><a href="#设置单个项目提交用户名和邮箱" class="headerlink" title="设置单个项目提交用户名和邮箱"></a>设置单个项目提交用户名和邮箱</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;新名称&quot;</span><br><span class="line">git config user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>之后可以打开当前项目的 <code>.git/config</code> 文件看配置生效如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">        name = 新名称</span><br><span class="line">        email = 邮箱地址</span><br></pre></td></tr></table></figure><h4 id="配置文件优先级及路径基本语法"><a href="#配置文件优先级及路径基本语法" class="headerlink" title="配置文件优先级及路径基本语法"></a>配置文件优先级及路径基本语法</h4><p>Git支持多级配置，分别是 <strong>system(系统级</strong>)、<strong>global（用户级）</strong>、<strong>local（项目级）</strong>和 <strong>worktree（工作区级）</strong><br>配置优先级： <strong><font color="green">worktree &gt; local &gt; global &gt; system</font></strong></p><ul><li><strong>system系统级（安装路径/etc/gitconfig）</strong>： 系统级配置文件，对系统中所有用户都普遍适用的配置。使用 <code>git config --system</code>读写的就是这个文件</li><li><strong>global用户级（C:/Users/用户名/.gitconfig）</strong>： 用户级配置文件，用户目录下的配置文件只适用于该用户。使用 <code>git config --global</code>读写的就是这个文件。</li><li><strong>local项目级（某仓库的本地路径/.git/config）</strong>： 项目级配置文件，当前项目的 git仓库目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）,这里的配置仅仅针对当前项目有效。使用 <code>git config [--local]</code>读写的就是这个文件。</li><li><strong>worktree工作区级</strong>： 工作区级配置，此配置仅仅针对当前工作区有效。使用 <code>git config --worktree</code>进行配置。</li></ul><p>每一个级别高的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。针对单个项目的配置同样会覆盖全局的配置。</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><hr><h3 id="Git-新建本地分支和远程分支，且关联起来"><a href="#Git-新建本地分支和远程分支，且关联起来" class="headerlink" title="Git 新建本地分支和远程分支，且关联起来"></a>Git 新建本地分支和远程分支，且关联起来</h3><ul><li>在本地新建分支并切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>将本地分支提交到远程仓库，此过程会在远程仓库中创建一个名为 <code>&lt;本地分支名&gt;</code>的远程分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>本地分支与远程分支关联</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/远程分支名</span><br></pre></td></tr></table></figure><hr><h3 id="Git-创建本地仓库关联远程仓库"><a href="#Git-创建本地仓库关联远程仓库" class="headerlink" title="Git 创建本地仓库关联远程仓库"></a>Git 创建本地仓库关联远程仓库</h3><p>本地创建了一个project，并在码云上创建了一个同名仓库，将本地的仓库链接到远程仓库。如果本地分支已经关联了远程的分支，在使用本地分支关联其他远程分支的时候会出现以下异常:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists</span><br></pre></td></tr></table></figure><p>这种场景下需要先删除当前项目中本地连接已关联的远程分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><ul><li>step1: 初始化本地仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>step2: 添加远程仓库地址：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure><ul><li>step3: 拉取远程仓库内容到本地</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>可能会出现下面的异常信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro elastic-job % git pull origin master</span><br><span class="line">remote: Enumerating objects: 3, done.</span><br><span class="line">remote: Counting objects: 100% (3/3), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://gitee.com/maple_eitba/elastic-job</span><br><span class="line"></span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">   error: The following untracked working tree files would be overwritten by merge:</span><br><span class="line">        .gitignore</span><br><span class="line">   Please move or remove them before you merge.</span><br><span class="line">   Aborting</span><br></pre></td></tr></table></figure><p>这是由于在远程创建仓库的时候有一个<code>.gitignore</code>文件,而是用<code>git init</code>命名也会在本地生成一个<code>.gitignore</code> 文件，所以出现了冲突；解决方法就是看需要保留哪一份，把不需要的删除即可，一般都是删除掉远程仓库中的<code>.gitignore</code> 文件。当然了，如果在开发者确定远程仓库中的内容是没用的前提下可以直接使用强制推送，直接对远程仓库进行覆盖，并进行本地和远程分支master的关联(这种操作仅限自己的项目,不能对工作项目使用强制推送):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f --set-upstream origin master</span><br></pre></td></tr></table></figure><blockquote><p>这个强制覆盖的命令在团队开发的时候不要用，嘎嘎危险！！！</p></blockquote><ul><li>step4: 添加本地工作区的修改到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><ul><li>step5: 将暂存区的信息提交到本地仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交的信息备注&quot;</span><br></pre></td></tr></table></figure><ul><li>step6: 推送本地仓库中的内容到远程仓库，并建立本地master分支和远程master分支的关联关系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>or: 这个命令不好使，终端会提示需要使用<code>--set-upstream origin master</code>;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><hr><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>丢弃暂存区的修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- fileName</span><br></pre></td></tr></table></figure><p><strong>Demo：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   test.json</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">maple@qixudongdeMacBook-Pro Test % git checkout -- test.json </span><br><span class="line"></span><br><span class="line">maple@qixudongdeMacBook-Pro Test % git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">maple@qixudongdeMacBook-Pro Test % </span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- test.json</code>意思就是，把<code>test.json</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是<code>test.json</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>test.json</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</li></ul><p>总之，就是<strong>让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态</strong>。</p><blockquote><p>git checkout – file命令中的<code>--</code>很重要，没有<code>--</code>就变成了<code>切换到另一个分支</code>的命令。</p></blockquote><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;fileName&gt;</span><br></pre></td></tr></table></figure><p>这个时候Git知道你删除了文件，因为工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在有两个选择:</p><p>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉版本库中的文件，并且<code>git commit</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> test.txt</span></span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><blockquote><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><p> 命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p></blockquote><hr><h3 id="强制覆盖本地代码（与git远程仓库保持一致）"><a href="#强制覆盖本地代码（与git远程仓库保持一致）" class="headerlink" title="强制覆盖本地代码（与git远程仓库保持一致）"></a>强制覆盖本地代码（与git远程仓库保持一致）</h3><p>git强制覆盖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>git强制覆盖本地命令（单条版本）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull</span><br></pre></td></tr></table></figure><p>解释:<br>第一个是：拉取远程仓库中的所有更新和不同步；<br>第二个是：本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；<br>第三个是：再更新一次（其实也可以不用，第二步命令做过了其实）;</p><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题及解决方案</title>
      <link href="/maple/2023/05/11/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/maple/2023/05/11/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><h2 id="什么是跨域问题？"><a href="#什么是跨域问题？" class="headerlink" title="什么是跨域问题？"></a>什么是跨域问题？</h2><p>出于浏览器的<font color="red">同源策略</font>限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。<font color="red">同源策略</font>会阻止一个域的<font color="red"><strong>javascript脚本</strong></font>和另外一个域的内容进行交互。<font color="cornflowerblue">所谓同源（即指在同一个域）就是两个页面的URL具有相同的协议（protocol），主机/域名（host）和端口号（port）。</font></p><h2 id="URI、URL和URN的区别"><a href="#URI、URL和URN的区别" class="headerlink" title="URI、URL和URN的区别"></a>URI、URL和URN的区别</h2><p>当我们打开浏览器，要访问一个网站或者一个ftp服务器的时候，输入一串字符串， 比如：<code>https://blog.csdn.net/</code>或者：<code>ftp://192.168.0.111/</code>，这样我们就可以得到一个html格式的页面或者一个文件。那么这个地址是什么意思呢？就必须要从URI、URL、URN讲起。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>URI = Uniform Resource Identifier 统一资源标志符</strong></li><li><strong>URL = Uniform Resource Locator 统一资源定位符</strong></li><li><strong>URN = Uniform Resource Name 统一资源名称</strong></li></ul><p>简单来说，URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI。本来设想的使用两种方法定位：1、<strong>URL，用地址定位</strong>；2、<strong>URN 用名称定位</strong>。但是urn没流行起来，导致现在大家说的所有的UR都是默认就是URL。</p><p><strong>举个例子</strong>：去村子找个具体的人（URI），如果用地址：某村多少号房子第几间房的主人，就是URL；如果用身份证号+名字去找就是URN了。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>URI是以一种抽象的，高层次概念定义统一资源标识，而URL则是具体的资源标识的方式。URL是一种URI。</li><li>格式不同：URL的格式一般由下列四部分组成：<ol><li>第一部分是协议(或称为服务方式)；</li><li>第二部分是存有该资源的主机IP地址，也叫域名；</li><li>第三部分是端口号；</li><li>第四部分是主机资源的具体地址。</li></ol></li></ol><p>3、在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema（protocol，协议）必须被指定。</p><h3 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h3><img src="url1.png" style="zoom:40%;"><h2 id="URL结构解析"><a href="#URL结构解析" class="headerlink" title="URL结构解析"></a>URL结构解析</h2><p>URL代表着是统一资源定位符（UniformResourceLocator）。</p><p>作用是为了告诉使用者 某个资源在 Web 上的地址。比如：用HTTP协议访问Web服务器：</p><img src="url2.png" style="zoom:80%;"><p>用FTP协议下载和上传文件的URL：</p><img src="url3.png" style="zoom:80%;"><p>读取客户端计算机本地文件的URL：</p><img src="url4.png" style="zoom:30%;"><p>URL的结构组成如下图：</p><img src="u=72685375,2378383068&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG.jpeg" style="zoom:33%;"><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>尽管 URL 有各种不同的写法， 但它们有一个共同点， 开头部分的内容必须是协议类型，可以是http、ftp、mailto或者https，这部分文字都表示浏览器应当使用的访问方法,会用‘//’为分隔符。决定了后面部分的写法， 因此并不会造成混乱。</p><h4 id="用户名-密码"><a href="#用户名-密码" class="headerlink" title="用户名/密码"></a>用户名/密码</h4><p>用户名密码通常可以省略。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名是<code>www.gitee.com</code>，在发送请求前，会向DNS服务器请求将域名字符串解析为IP地址。如果已经知道ip，还可以跳过DNS解析那一步，直接把IP当做域名部分使用。</p><p>域名是<font color="cornflowerblue">从右向左</font>进行分析的，依次为：<strong>域名后缀、顶级域名（一级域名）、二级域名、三级域名</strong>，如图：</p><img src="url5.png" style="zoom:50%;"><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>域名后面有些时候会带有端口，和域名之间用’:’分隔，端口不是一个URL的必须的部分。 当网址为http://时，默认端口为80， https://时，默认端口是443， ftp://时，默认端口是21。此时端口号可以省略不写。</p><h4 id="文件路径-文件名"><a href="#文件路径-文件名" class="headerlink" title="文件路径/文件名"></a>文件路径/文件名</h4><p><strong>从域名之后的第一个/开始到最后一个/为止，是虚拟目录的部分</strong>。虚拟目录也不是URL必须的部分，上述实例http协议url中的虚拟目录是：<code>/yikoulinux/chat/blob/master/</code></p><p><strong>从域名最后一个’/‘开始到’?’为止，是文件名部分</strong>；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。</p><p>文件名也不是一个URL的必须部分。</p><p>Demo：判断下列URL与 <code>http://www.example.com:8080</code>是否是跨域？</p><table><thead><tr><th align="center">比较的URL</th><th align="center">是否跨域</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center"><strong>http</strong>://<strong><a href="http://www.example.com/">www.example.com</a></strong>:<strong>8080</strong>/dir/page.html</td><td align="center">否</td><td align="center">协议、主机/域名、端口号等相同</td></tr><tr><td align="center"><strong>http</strong>://username:password@<strong><a href="http://www.example.com/">www.example.com</a></strong>:<strong>8080</strong>/dir/page.html</td><td align="center">否</td><td align="center">协议、主机/域名、端口号等相同</td></tr><tr><td align="center"><a href="http://www.example.com:**81**/dir/page.html">http://www.example.com:**81**/dir/page.html</a></td><td align="center">跨域</td><td align="center">端口号不相同</td></tr><tr><td align="center"><code>https://www.example.com:8080</code></td><td align="center">跨域</td><td align="center">协议不相同</td></tr><tr><td align="center"><code>http://en.example.com:8080</code></td><td align="center">跨域</td><td align="center">主机/域名不相同</td></tr></tbody></table><blockquote><p>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>常见的几种解决方案：</p><ul><li><p><strong>服务器代理</strong></p><ul><li>让请求和响应双方url不同源，域名不同。</li></ul></li><li><p><strong>改发JSONP</strong></p><ul><li>将ajax请求改为JSONP<ul><li>不是ajax</li><li>只能支持<code>get方式</code></li></ul></li></ul></li><li><p><strong>CORS</strong></p><ul><li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</li><li>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10(ie8通过XDomainRequest能支持CORS)。</li></ul></li><li><p>Spring MVC中提供的**@CrossOrigin注解**</p><ul><li>当域名<code>www.abc.com</code>下的js代码去访问<code>www.def.com</code>域名下的资源，就会受到限制。使用@CrossOrigin可以处理跨域请求，让你能访问不是一个域的文件。</li></ul></li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/weixin_66375317/article/details/124545878?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168377237516800211595928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168377237516800211595928&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124545878-null-null.142%5Ev86%5Ewechat,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%B7%A8%E5%9F%9F&spm=1018.2226.3001.4187">什么是跨域？跨域解决方法</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通Token令牌 vs. JWT令牌</title>
      <link href="/maple/2023/05/10/%E6%99%AE%E9%80%9AToken%E4%BB%A4%E7%89%8C-vs-JWT%E4%BB%A4%E7%89%8C/"/>
      <url>/maple/2023/05/10/%E6%99%AE%E9%80%9AToken%E4%BB%A4%E7%89%8C-vs-JWT%E4%BB%A4%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="普通Token令牌-vs-JWT令牌"><a href="#普通Token令牌-vs-JWT令牌" class="headerlink" title="普通Token令牌 vs. JWT令牌"></a>普通Token令牌 vs. JWT令牌</h1><blockquote><p>SpringSecurityOauth2令牌<br>参考： <a href="https://www.yuque.com/gaoxi-dj1fr/fxgaxe/ivvpqc">SpringSecurityOauth2令牌</a></p></blockquote><h2 id="令牌分类"><a href="#令牌分类" class="headerlink" title="令牌分类"></a>令牌分类</h2><p>常见的令牌有两种：普通令牌Token 和 JWT令牌</p><blockquote><p>JWT令牌请见博文：<a href="/maple/2023/05/05/JWT">浅析JWT</a></p></blockquote><h4 id="普通令牌"><a href="#普通令牌" class="headerlink" title="普通令牌"></a>普通令牌</h4><p>唯一标识存储在数据库或<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中的用户信息，在认证时，SpringSecurity服务端会拿着普通令牌去数据库中查询用户信息来实现认证鉴权。</p><h4 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h4><p>JWT令牌本身就存储着用户信息，在认证时，SpringSecurity从JWT令牌中按照约定的加密算法，解析出用户信息即可实现认证，不需要借助数据库等进行存储，进一步提高了认证鉴权的性能。</p><h3 id="普通Token令牌"><a href="#普通Token令牌" class="headerlink" title="普通Token令牌"></a>普通Token令牌</h3><p>普通令牌是SpringSecurityOauth2给客户端颁发的一个无含义的令牌，在令牌发布时，SpringSecurityOauth2将用户信息存储到程序指定的存储位置，并用普通令牌唯一标识这个存储信息，当用户再次携带令牌访问时，SpringSecurityOauth2会根据令牌查询用户信息，进而实现权限角色的限制。</p><p>普通令牌需要一个存储用户信息的地方，这个地方可以本地内存，也可以是数据库（Redis、Mysql）。</p><img src="1594967846444-df5a8f3b-aece-4032-86eb-dadfaa5f1661.png" alt="image.png" style="zoom:50%;"><h4 id="基于本地内存存储"><a href="#基于本地内存存储" class="headerlink" title="基于本地内存存储"></a>基于本地内存存储</h4><table><thead><tr><th>测试项</th><th>测试结果</th></tr></thead><tbody><tr><td>同一个认证服务器同一个用户多次调用发布令牌</td><td>会返回同一个令牌（access_token、refresh_token）</td></tr><tr><td>调用刷新token</td><td>1. refresh_token本身是不会变化，无论刷新几次<br>2. 刷新后原access_token立即失效，并生成新的access_token.</td></tr><tr><td>多台认证服务器同一个用户多次调用发布令牌</td><td>1.不同的认证服务器发布令牌各不相同</td></tr><tr><td>用户信息的获取方式</td><td>通过调用<code>/oauth/check_token</code>去获取用户认证信息</td></tr></tbody></table><p><strong>结论</strong></p><ul><li>基于内存存储用户信息的方式，认证服务器将用户信息存储在各自JVM运行时内存中；</li><li>当资源服务器获得access_token后，会通过远程调用认证服务器的<code>/oauth/check_token</code>，校验token，获得用户信息；</li><li>在微服务场景下不适用；</li></ul><h3 id="基于Redis缓存存储"><a href="#基于Redis缓存存储" class="headerlink" title="基于Redis缓存存储"></a>基于Redis缓存存储</h3><table><thead><tr><th>测试项</th><th>测试结果</th></tr></thead><tbody><tr><td>同一个认证服务器同一个用户多次调用发布令牌</td><td>会返回同一个令牌（access_token、refresh_token）</td></tr><tr><td>调用刷新token</td><td>1. refresh_token本身是不会变化，无论刷新几次<br>2. 刷新后原access_token立即失效，并生成新的access_token.</td></tr><tr><td>多台认证服务器同一个用户多次调用发布令牌</td><td>不同的认证服务器发布令牌是相同的，不论哪个认证服务器，都会返回同一个access_token和refresh_token</td></tr><tr><td>用户信息的获取方式</td><td>从Redis数据库中获取</td></tr></tbody></table><p><strong>结论</strong></p><ul><li>基于Redis存储用户信息的方式，认证服务器将用户信息存储到指定的Redis数据库中；</li><li>当资源服务获取到access_token时，会到Redis中获取用户信息；</li><li>在微服务场景下适用；</li></ul><p>其中：access_token就是所说的普通Token。</p><h3 id="JWT令牌-1"><a href="#JWT令牌-1" class="headerlink" title="JWT令牌"></a>JWT令牌</h3><p>JWT令牌的方式就无需数据库的介入，JWT令牌中就包含着用户的信息，SpringSecurityOauth在发布令牌时，会将用户信息放入JWT令牌中，用户拿着JWT令牌时，SpringSecurityOauth从中获取到用户信息，实现用户权限的控制。</p><img src="1594978948208-daf86822-f444-48cd-95e0-f6462d53c856.png" alt="image.png" style="zoom:50%;"><p>JWT不需要后端进行存储。</p><table><thead><tr><th>测试项</th><th>测试结果</th></tr></thead><tbody><tr><td>同一个认证服务器同一个用户多次调用发布令牌</td><td>同一个认证服务器会返回不同的令牌（access_token、refresh_token）</td></tr><tr><td>调用刷新token</td><td>1. refresh_token每请求依次就会变一次<br>2. 刷新后原access_token不会失效，并生成新的access_token.</td></tr><tr><td>多台认证服务器同一个用户多次调用发布令牌</td><td>不同的认证服务器发布令牌是不同的</td></tr><tr><td>用户信息的获取方式</td><td>从JWT令牌中获取</td></tr></tbody></table><p><strong>结论</strong></p><ul><li>基于JWT令牌的认证服务器，用户信息存储到令牌中；</li><li>当资源服务获取到access_token后，会解析这个JWT类型的access_token，从中会获取到用户信息；</li><li>微服务场景下不适用；</li></ul><blockquote><p>JWT令牌也不能说微服务场景下不适用，只是相对于基于数据库存储的普通令牌来说，重复请求的JWT是不一样的，也就是说JWT和用户信息是一种多对一的映射关系，可能微服务场景下，更常见的是令牌和用户是一对一的映射关系。</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="APP服务端接口，用-JWT-or-Redis-Token，分别有什么优势？"><a href="#APP服务端接口，用-JWT-or-Redis-Token，分别有什么优势？" class="headerlink" title="APP服务端接口，用 JWT or Redis+Token，分别有什么优势？"></a>APP服务端接口，用 JWT or Redis+Token，分别有什么优势？</h3><p><strong>JWT属于无状态设计</strong>，用户登陆的信息存放在JWT加密数据里，这种设计下服务器不需要存储JWT密文，只需要解密就能拿到授权信息等用户信息。这种设计是一种利用服务器的计算力减少Token设计下数据库及缓存的压力和设计复杂度，因此它的本质就是不存储登陆授权，而是通过密文本身保存授权信息。</p><p>Token加Redis设计，是一种登陆后分配随机Token，然后记录Token与用户信息这种一一映射关系的设计。</p><p>很明显，这两种设计的区别就在于Token是否是需要服务器存储，每次验权是否需要查询数据库。JWT不需要服务器存储，信息本身就存储于JWT本身，这种模式无需使用数据库。</p><p>但是这种流行的JWT有一个设计上的缺陷，它通过密文传输用户信息，那么服务器在这种基础结构下是无法做到关闭用户登陆授权的操作，如果用户的JWT密文被偷窃，那么黑客就能以用户身份登陆，并且即使知道密文丢失，也无法关闭被偷窃的JWT密文。为了应对这一问题，可以使用<strong>JWT内部验证有效期</strong>和<strong>JWT黑名单模式</strong>，但是有效期始终无法做到及时停止JWT授权，这是一个治标不治本的方法。而JWT黑名单模式，则需要数据库或内存存储黑名单，那么，这实际上违背了JWT的免数据库设计原则。</p><p>因此，如果严格按照两种模式设计，<font color="red">Token模式适合较高安全度和用户登陆等信息分析的系统</font>，如：普通的博客、阅读器等等，这种服务允许不严格的登陆授权，即使密文丢失也不会造成用户的严重损失，却能获得较高的服务性能。</p><p>Token模式，必须配合数据库进行存储和查询，虽然性能相对JWT会低一些（随着数据库和缓存性能的提升，这一次的查询操作其实不会造成明显的性能影响），但Token模式却能做到及时的授权关闭，已经登陆授权可见可查，每一次Token都会有对应的记录。因此<font color="red">Token模式适合较高安全度和用户登陆等信息分析的系统</font>，如政府系统，支付系统等不可能允许高权限的Token被偷窃却不能及时关闭授权。</p><p><strong>结论：</strong></p><ul><li>JWT，适合轻量的系统和权限不严格系统。</li><li>Token，适合重量系统和权限有严格要求的系统。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>普通的Token方式采用的是：<code>登录--&gt;生成随机字符串（Token）--&gt; 服务器保存Token与用户信息的对应关系</code>，对应用户利用Token校验的流程是 <code>Token--&gt;查询Token对应用户信息--&gt;各系统根据用户信息</code> 进行业务处理。</p><p>很明显可以看出，Token模式下的字符串实际上不需要和用户信息有任何关联，生成的Token字符串的要求就是唯一标识，不能被其他用户占有，否则就会出现用户登录后实际上是以其他人身份进行业务处理。如果字符串是随机生成，那么黑客就无法猜测Token的生成规律，也无法从Token直接猜测到用户相关信息。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT采用的生成：<code>登录--&gt;生成带有用户数据的加密字符串（该字符串服务器并不存储，直接下发给客户端</code>）</p><p>校验：<code>客户端将存储的JWT密文带上--&gt;服务器解密密文</code>，获取到用户信息</p><p>可以看出，JWT的凭证不仅要求唯一，还要求密文本身实际上是带有了用户信息，当然这块可以是非敏感信息，这只是实现上的细节区别，和结构本身没有特别大的关联。服务器本身并没有存储这次JWT密文，每次服务器的处理都是直接解密JWT密文。这样做的好处就是服务架构内直接抛弃了登录相关的传统Token系统，并且服务器不再管理登录状态，Token有效状态等问题。</p><p>而JWT带来的问题，凭证实际上的一串密文，更多的用户信息或session信息需要更大的密文来存储，进而每次请求都带上JWT就会使网络传输的内容变大，加大了<strong>网络开销</strong>；凭证是一串密文，那么如果黑客破解了服务器的加密方式，那么密文实际上就是用户的明文信息在网络上传输（这就是传说中的裸奔），黑客可以直接伪造JWT登录或通过JWT密文获取到用户信息；JWT本身不管理JWT的有效性，一旦密文被偷窃，无法做到关闭掉黑客的授权。</p><p><strong>核心缺点</strong>：<font color="red">网络开销</font>、<font color="red">黑客的窃取|篡改|伪装</font>、<font color="red">无法及时关闭授权</font>。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/inthat/article/details/108244652">普通令牌Token和JWT令牌Token区别以及使用场景</a></p><p><a href="https://blog.csdn.net/u014756827/article/details/103047695">APP服务端接口，用JWT还是用Redis和Token，分别有什么优势</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> 令牌 </tag>
            
            <tag> Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM钩子</title>
      <link href="/maple/2023/05/09/JVM%E9%92%A9%E5%AD%90/"/>
      <url>/maple/2023/05/09/JVM%E9%92%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM钩子"><a href="#JVM钩子" class="headerlink" title="JVM钩子"></a>JVM钩子</h1><p>JVM进程在接收到<code>kill -15</code>信号通知的时候，是可以做一些清理动作的，比如：删除临时文件等。当然了，开发者也可以基于该信号自定义做一些额外的操作，比如：让tomcat容器停止，让dubbo服务下线，清理数据等。这种自定义JVM清理动作的方式，是通过JDK中提供的<code>ShutdownHook</code>实现的。JDK提供了<code>Java.Runtime.addShutdownHook(Thread hook)</code> 方法，可以注册一个在JVM关闭时需要执行的钩子方法。</p><blockquote><p>kill命令原理请见博文：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650127782&idx=1&sn=87cc02ab1484b14e0313998da527bedf&chksm=f36ba087c41c29916a572f24f2a9b21cdc7080a75261c7f662d86de558840d13cd0bc93ed1fc&scene=178&cur_album_id=1337197892284809216#rd">kill -9的原理</a></p></blockquote><h2 id="JVM钩子的作用"><a href="#JVM钩子的作用" class="headerlink" title="JVM钩子的作用"></a>JVM钩子的作用</h2><p><strong>JVM钩子方法的执行时机是在所有非守护线程都执行完成之后，在JVM进程退出之前</strong>，利用钩子线程去执行一些清理工作，如：释放资源，文件清理等等。</p><p>我们都知道，在Linux中，Java应用是作为一个独立进程运行的，Java程序的终止就是基于JVM进程的关闭实现的，JVM进程关闭方式分为3种：</p><ul><li><strong>正常关闭</strong>：当最后一个非守护线程运行结束 或者 调用了 <code>System.exit( )</code> 或者 通过其他特定平台的方法关闭 或者 执行 <code>kill [-15]</code>（接收到SIGINT（2）、SIGTERM（15）信号等）；</li><li><strong>异常关闭</strong>：程序运行中遇到<code>RuntimeException</code>异常，或者操作系统程序出现异常导致JVM退出等；</li><li><strong>强制关闭</strong>：通过调用<code>Runtime.halt( )</code>方法 或者 在操作系统中强制 <code>kill -9</code>（接收到SIGKILL（9）信号)</li></ul><blockquote><p><strong>Linux常见的信号有：</strong></p><ul><li><strong>kill -2 PID</strong> —— 正常中断进程（作用等同于：Ctrl + C ）。程序在结束之前，能够保存相关数据，然后再退出。</li><li><strong>kill -9 PID</strong> —— 强制杀死一个进程。</li><li><strong>kill [-15] PID</strong> —— 正常方式关闭（终止）进程。关闭进程时应先考虑使用 <code>kill -15</code> ，以便于其能够预先清理临时文件和释放资源。</li></ul><p><strong>PS：<code>kill -9</code> 作为最后手段，应对那些失控的进程。</strong></p></blockquote><h2 id="JVM钩子的使用场景"><a href="#JVM钩子的使用场景" class="headerlink" title="JVM钩子的使用场景"></a>JVM钩子的使用场景</h2><h3 id="JVM正常关闭-–-钩子生效"><a href="#JVM正常关闭-–-钩子生效" class="headerlink" title="JVM正常关闭 – 钩子生效"></a>JVM正常关闭 – 钩子生效</h3><p>如果有注册钩子，那么当JVM进程中的所有非守护线程执行完任务之后，JVM退出之前会执行钩子里面的任务。</p><p><strong>Demo1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!! </span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p>从上述代码可以看出，我们一般定义的钩子任务都是被封装成一个线程任务，也就是说每个钩子都分别是在一个不同的线程中并发执行的。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h4><p>IDEA中debug上述Demo，发现在JVM进程中当所有的非守护线程结束时，JVM底层的C源码会调用JNI创建一个名为：**DestroyJavaVM线程 **用于执行注册的钩子任务。</p><img src="hook1.png" style="zoom:80%;"><p><strong>DestroyJavaVM线程定义</strong></p><p>从 <code>java.c</code> 源码文件中找到<strong>DestroyJavaVM线程</strong>的定义。如下图：</p><img src="hook2.png" style="zoom:80%;"><blockquote><p>* Wait for all non-daemon threads to end, then destroy the VM.</p><p>* This will actually create a trivial new Java waiter thread named “DestroyJavaVM”, but this will be seen as a different thread from the one that executed main, even though they are the same C thread.  This allows mainThread.join( )  and mainThread.isAlive() to work as expected.</p><p>译文：等待所有非守护线程结束，然后销毁VM。这实际上会创建一个名为“DestroyJavaVM”的Java等待线程，但这将被视为一个不同于执行main的线程，尽管它们是同一个C线程。这允许mainThread.join( )和mainThread.isAlive( )按预期工作。</p></blockquote><p>从上述debug的截图来看，这个<strong>DestroyJavaVM线程</strong>主要就是调用了<code>Shutdown.shutdown()</code>方法来执行注册的钩子。钩子任务的整个执行链路如下图所示：</p><img src="hook3.png" style="zoom:80%;"><p><strong>Shutdown.shutdwon( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by the JNI DestroyJavaVM procedure when the last non-daemon thread has finished. </span></span><br><span class="line"><span class="comment"> * Unlike the exit method, this method does not actually halt the VM.</span></span><br><span class="line"><span class="comment"> * 译文：当最后一个非守护线程执行完成时，由JNI DestroyJavaVM过程调用。与exit方法不同的是，此方法实际上不会停止虚拟机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:       <span class="comment">/* Initiate shutdown */</span></span><br><span class="line">            state = HOOKS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HOOKS:         <span class="comment">/* Stall and then return */</span></span><br><span class="line">        <span class="keyword">case</span> FINALIZERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (Shutdown.class) &#123;</span><br><span class="line">        sequence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.sequence( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The actual shutdown sequence is defined here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it weren&#x27;t for runFinalizersOnExit, this would be simple -- we&#x27;d just</span></span><br><span class="line"><span class="comment"> * run the hooks and then halt.  Instead we need to keep track of whether</span></span><br><span class="line"><span class="comment"> * we&#x27;re running hooks or finalizers.  In the latter case a finalizer could</span></span><br><span class="line"><span class="comment"> * invoke exit(1) to cause immediate termination, while in the former case</span></span><br><span class="line"><span class="comment"> * any further invocations of exit(n), for any n, simply stall.  Note that</span></span><br><span class="line"><span class="comment"> * if on-exit finalizers are enabled they&#x27;re run iff the shutdown is</span></span><br><span class="line"><span class="comment"> * initiated by an exit(0); they&#x27;re never run on exit(n) for n != 0 or in</span></span><br><span class="line"><span class="comment"> * response to SIGINT, SIGTERM, etc.</span></span><br><span class="line"><span class="comment"> * 译文: 实际的关闭顺序在这里定义。</span></span><br><span class="line"><span class="comment"> * 如果没有runFinalizersOnExit，这将是简单的——我们只需运行钩子，然后停止。相反，我们需要跟踪运行的是钩子还是终结器。</span></span><br><span class="line"><span class="comment"> * 在后一种情况下，终结器可以调用exit(1)来导致立即终止，而在前一种情况下，任何对exit(n)的进一步调用，对于任何n，</span></span><br><span class="line"><span class="comment"> * 都只是暂停。注意，如果启用了on-exit终结器，那么如果关闭由一个exit(0)启动，它们就会运行;它们永远不会在退出(n)时运行，</span></span><br><span class="line"><span class="comment"> * 因为n != 0或响应SIGINT、SIGTERM等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sequence</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">/* Guard against the possibility of a daemon thread invoking exit</span></span><br><span class="line"><span class="comment">         * after DestroyJavaVM initiates the shutdown sequence</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (state != HOOKS) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runHooks(); <span class="comment">// 核心 -- 执行钩子</span></span><br><span class="line">    <span class="type">boolean</span> rfoe;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        state = FINALIZERS;</span><br><span class="line">        rfoe = runFinalizersOnExit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rfoe) runAllFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.runHooks( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> slot, <span class="type">boolean</span> registerShutdownInProgress, Runnable hook)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hooks[slot] != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Shutdown hook at slot &quot;</span> + slot + <span class="string">&quot; already registered&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!registerShutdownInProgress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; RUNNING)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hooks[slot] = hook;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run all registered shutdown hooks*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SYSTEM_HOOKS; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable hook;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// acquire the lock to make sure the hook registered during shutdown is visible here.</span></span><br><span class="line">                currentRunningHook = i;</span><br><span class="line">                hook = hooks[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hook != <span class="literal">null</span>) hook.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ThreadDeath) &#123;</span><br><span class="line">                <span class="type">ThreadDeath</span> <span class="variable">td</span> <span class="operator">=</span> (ThreadDeath) t;</span><br><span class="line">                <span class="keyword">throw</span> td;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.run( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationShutdownHooks</span> &#123;</span><br><span class="line">    <span class="comment">/* The set of registered hooks */</span></span><br><span class="line">    <span class="comment">// IdentifyHashMap的解释: https://blog.csdn.net/f641385712/article/details/81880711</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Shutdown.add(<span class="number">1</span> <span class="comment">/* shutdown hook invocation order */</span>,</span><br><span class="line">                <span class="literal">false</span> <span class="comment">/* not registered if shutdown in progress */</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        runHooks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            hooks = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// application shutdown hooks cannot be added if</span></span><br><span class="line">            <span class="comment">// shutdown is in progress.</span></span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.runHooks() – 执行钩子任务的核心方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Iterates over all application hooks creating a new thread for each</span></span><br><span class="line"><span class="comment"> * to run in. Hooks are run concurrently and this method waits for</span></span><br><span class="line"><span class="comment"> * them to finish.</span></span><br><span class="line"><span class="comment"> * 译文: 遍历所有应用程序钩子，为每个要运行的钩子创建一个新线程。钩子任务是并发执行的，这个方法等待它们完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这行代码是钩子任务的灵魂，阻塞当前线程直到所有的钩子任务线程执行完毕。</span></span><br><span class="line">                <span class="comment">// 同时需要注意正是因为该行代码的存在导致在钩子任务中请勿执行耗时长的任务，否则会导致JVM进程长时间无法退出。</span></span><br><span class="line">                hook.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者在注入钩子时使用的<code>addShutdownHook()</code>方法，就是进行注册钩子。</p><p><strong>Runtime.addShutdownHook( )方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShutdownHook</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.add()方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(hooks == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line">    hooks.put(hook, hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，JVM进程正常结束时，注册钩子任务的执行流程源码分析就结束了，从开发者代码注入钩子到执行钩子的触发时机，每一步的对应源码分析都很仔细，后续再熟悉熟悉整个流程。</p><p><strong>Demo2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p><strong>System.exit ( )方法源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    Runtime.getRuntime().exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runtime.exit( )方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        security.checkExit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Shutdown.exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.exit( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by Runtime.exit, which does all the security checks.</span></span><br><span class="line"><span class="comment"> * Also invoked by handlers for system-provided termination events,</span></span><br><span class="line"><span class="comment"> * which should pass a nonzero status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">runMoreFinalizers</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>) runFinalizersOnExit = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:       <span class="comment">/* Initiate shutdown */</span></span><br><span class="line">                state = HOOKS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOOKS:         <span class="comment">/* Stall and halt */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINALIZERS: <span class="comment">// 如果是终结器</span></span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Halt immediately on nonzero status */</span></span><br><span class="line">                    halt(status); <span class="comment">// 关闭JVM</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* Compatibility with old behavior:</span></span><br><span class="line"><span class="comment">                     * Run more finalizers and then halt</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    runMoreFinalizers = runFinalizersOnExit;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runMoreFinalizers) &#123;</span><br><span class="line">        runAllFinalizers();</span><br><span class="line">        halt(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (Shutdown.class) &#123;</span><br><span class="line">        <span class="comment">/* Synchronize on the class object, causing any other thread</span></span><br><span class="line"><span class="comment">         * that attempts to initiate shutdown to stall indefinitely</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sequence(); <span class="comment">// 顺序关系方法，又回到上述正常关闭时执行钩子方法的逻辑了</span></span><br><span class="line">        halt(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，调用`System.exit(0)方法结束JVM进程时，还是会执行钩子任务的。</p><h3 id="JVM异常关闭-–-钩子生效"><a href="#JVM异常关闭-–-钩子生效" class="headerlink" title="JVM异常关闭 – 钩子生效"></a>JVM异常关闭 – 钩子生效</h3><p><strong>JVM进程在发生异常情况导致退出时，</strong>钩子还是会生效。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">at com.maple.system.Demo_System_Exit.main(Demo_System_Exit.java:17)</span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p>从debug可以看出，钩子的执行和JVM进程正常结束时是一样的：</p><img src="hook4.png" style="zoom:80%;"><h3 id="JVM强制关闭-–-钩子不生效"><a href="#JVM强制关闭-–-钩子不生效" class="headerlink" title="JVM强制关闭 – 钩子不生效"></a>JVM强制关闭 – 钩子不生效</h3><p><strong>JVM进程如果是被执行了<code>kill -9</code> 或 <code>Runtime.halt()</code>方法等强制关闭的场景下，</strong>钩子是不生效的。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    Runtime.getRuntime().halt(<span class="number">0</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p><strong>Runtime.halt( )方法分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">halt</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkExit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Shutdown.halt(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.halt( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The halt method is synchronized on the halt lock</span></span><br><span class="line"><span class="comment"> * to avoid corruption of the delete-on-shutdown file list.</span></span><br><span class="line"><span class="comment"> * It invokes the true native halt method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">halt</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (haltLock) &#123;</span><br><span class="line">        halt0(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">halt0</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p>底层直接调用了JNI方法实现JVM进程的强制关闭，整个链路中没有钩子任务的执行逻辑。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Saas</title>
      <link href="/maple/2023/05/08/%E6%B5%85%E6%9E%90Saas/"/>
      <url>/maple/2023/05/08/%E6%B5%85%E6%9E%90Saas/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析Saas"><a href="#浅析Saas" class="headerlink" title="浅析Saas"></a>浅析Saas</h1><h2 id="什么是SAAS平台？"><a href="#什么是SAAS平台？" class="headerlink" title="什么是SAAS平台？"></a>什么是SAAS平台？</h2><p>　　SaaS是随着互联网技术的发展和应用软件的成熟，在21世纪开始兴起的一种完全创新的软件应用模式。</p><p>　　软件运营服务是（Software as a Service，简称SaaS）让用户能够通过<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186?fromModule=lemma_inlink">互联网</a>连接和使用基于<a href="https://baike.baidu.com/item/%E4%BA%91/2363180?fromModule=lemma_inlink">云</a>的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink">应用程序</a>。常见示例有电子邮件、日历和办公工具。 它不需要用户将<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81/6800028?fromModule=lemma_inlink">软件产品</a>安装在自己的电脑或服务器上。</p><p>SaaS提供完整的软件解决方案，用户可以从<a href="https://baike.baidu.com/item/%E4%BA%91%E6%9C%8D%E5%8A%A1/7843499?fromModule=lemma_inlink">云服务</a>提供商处以即用即付方式进行购买。为组织租用应用，组织用户即可通过互联网连接到该应用（通常使用 Web浏览器）。所有<a href="https://baike.baidu.com/item/%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/22471639?fromModule=lemma_inlink">基础结构</a>、<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>、<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/216367?fromModule=lemma_inlink">应用软件</a>和应用数据都位于服务提供商的数据中心内。服务提供商负责管理硬件和软件，并根据适当的服务协议确保应用和数据的可用性和安全性。SaaS让组织能够通过最低前期成本的应用快速建成投产。 因为它不需要用户将软件产品安装在自己的电脑或服务器上。而是按某种服务水平协议（<a href="https://baike.baidu.com/item/SLA/2957862?fromModule=lemma_inlink">SLA</a>）直接通过网络向专门的提供商获取自己所需要的、带有相应软件功能的服务。 </p><h2 id="Saas平台的特点"><a href="#Saas平台的特点" class="headerlink" title="Saas平台的特点"></a>Saas平台的特点</h2><p><strong>可以使用先进的应用程序。</strong> 要向用户提供 SaaS 应用，无需购买、安装、更新或维护任何硬件、中间件或软件。SaaS让缺乏自行购买、部署和管理必需基础结构和软件所需资源的企业能够使用<a href="https://baike.baidu.com/item/ERP/22997?fromModule=lemma_inlink">ERP</a>和<a href="https://baike.baidu.com/item/CRM/165070?fromModule=lemma_inlink">CRM</a>等非常先进的企业应用程序。</p><p><strong>只为自己使用的东西付费。</strong>由于SaaS服务将根据使用水平自动扩展和收缩，还能节省费用。</p><p><strong>使用免客户端软件。</strong>用户可以从其Web浏览器直接运行大部分SaaS应用而无需下载和安装任何软件（部分应用需要插件）。这意味着无需为用户购买和安装特殊软件。</p><p><strong>轻松增强员工移动性。</strong>SaaS能够轻松增强员工“移动性”，因为用户可以从任何连接到 Internet 的计算机或移动设备访问SaaS应用和数据。无需考虑将应用开发为可在不同类型的计算机和设备上运行，因为服务提供商已经完成了这部分工作。此外，无需学习专业知识即可处理移动计算带来安全问题。无论使用数据的设备是什么类型，谨慎选择的服务提供商都将确保数据的安全。</p><p><strong>从任何位置访问应用数据。</strong>将数据存储到云后，用户即可通过任何连接到 Internet 的计算机或移动设备访问其信息。并且将应用数据存储到云后，用户的计算机或移动设备发生故障时不会丢失任何数据。</p><h2 id="SAAS平台架构分为哪些？"><a href="#SAAS平台架构分为哪些？" class="headerlink" title="SAAS平台架构分为哪些？"></a>SAAS平台架构分为哪些？</h2><h3 id="1、呈现层"><a href="#1、呈现层" class="headerlink" title="1、呈现层"></a>1、呈现层</h3><p>　　saas平台架构的呈现层可以使用的客户端可能都浏览器或本地客户端。如果是浏览器则需要Web界面技术、交互技术等技术(如：HTMl5技术、CSS3技术、Ajax技术等)的支持，如果是软件客户端则需要远程桌面技术、软件交互技术等技术支持。</p><h3 id="2、调度层"><a href="#2、调度层" class="headerlink" title="2、调度层"></a>2、调度层</h3><p>　　saas平台架构的调度层体现分布式系统的特性之一。调度层首先负责识别并通过AAA认证每个用户请求，然后根据业务处理器的负载、业务特征进行合理的调度。通过应用这样的架构SaaS平台可以横向扩展。此外在存储、缓存等方面为了满足平台的横向扩展需求，调度层也必须具有良好的可扩展性。</p><h3 id="3、业务层"><a href="#3、业务层" class="headerlink" title="3、业务层"></a>3、业务层</h3><p>　　saas平台架构的业务层负责接收调度层转发过来的请求，而且还要通过对接受到的请求执行真正的业务逻辑。一般来说业务逻辑的执行使用一台服务器就够了。因此业务层实际是由一排对等的服务器组成的，每台服务器都执行相同的业务逻辑。</p><h3 id="4、数据层"><a href="#4、数据层" class="headerlink" title="4、数据层"></a>4、数据层</h3><p>　　saas平台架构的数据库集群用于处理存储关系性很强并且对事务性要求很高的业务数据，这类数据目前还要用传统的数据库集群技术来解决，saas平台架构的数据库集群主要是根据业务特征制定数据拆分方案。同时分布式数据库用于存放海量但关系性不强的数据(如：用户的操作日志等)。</p><h2 id="SaaS产品的基本构成"><a href="#SaaS产品的基本构成" class="headerlink" title="SaaS产品的基本构成"></a>SaaS产品的基本构成</h2><p>一个SaaS产品通常由管理平台、租户实例、用户界面三个部分构成，分别对应SaaS产品的平台端、租户端、用户端三大功能模块。</p><img src="1672306672552_saas.png" alt="SaaS产品功能" style="zoom:67%;"><p>目前SaaS产品大多采用“Web+移动端”的用户端组合模式， 在使用体验上与普通的软件产品相似，使用者并不需要关心其是否SaaS系统。SaaS用户端又分为“隔离模式”和“互通模式”。</p><p>隔离模式：一个用户端只对应一个实例，不同实例之间完全隔离，不能互相切换(例如：WebOA、企业邮箱)。</p><img src="1672306162125_73.png" alt="1672306162140_73.png" style="zoom:67%;"><p>互通模式：同一用户端可关联多个实例，用户可在不同实例(企业)之间切换(例如：钉钉、企业微信)。</p><img src="1672306218900_74.png" alt="1672306218911_74.png" style="zoom:67%;"><p>SaaS产品由管理端进行角色权限配置和平台设置、用户管理、实例管理、数据管理等一系列操作。</p><p>用户端设置账号功能和业务化功能， 主要包括注册开通、登录， 实例切换和标准功能和定制化功能(按实例配置)。</p><p>租户端可以管理自身基本信息，如名称、Logo等，给予管理实例的操作账号和角色权限，可以管理租约，进行缴费和续费等操作。有具体的业务后台，可以查看相关的数据统计等。</p><p>持续完善…</p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.bilibili.com/read/cv18241782">一文看懂什么是SAAS平台 SAAS平台架构分为哪些？</a></p><p><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1/8904485?fromtitle=SaaS&fromid=6703273&fr=aladdin">软件运营服务</a></p><p><a href="http://cd.itheima.com/news/20221229/174603.html">SaaS产品的基本构成及主要功能有哪些？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Saas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析JWT</title>
      <link href="/maple/2023/05/05/JWT/"/>
      <url>/maple/2023/05/05/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析JWT"><a href="#浅析JWT" class="headerlink" title="浅析JWT"></a>浅析JWT</h1><p>随着移动互联网的兴起，传统基于session/cookie的web网站认证方式转变为了基于OAuth2等开放授权协议的单点登录模式（SSO），相应的基于服务器session+浏览器cookie的Auth手段也发生了转变，Json Web Token的出现成为了当前的热门的Token Auth机制。</p><blockquote><p>Cookie和Session相关概念请见博文：<a href="/maple/2023/05/05/Cookie-Session/">Cookie-Session</a></p></blockquote><h2 id="Json-Web-Token（JWT"><a href="#Json-Web-Token（JWT" class="headerlink" title="Json Web Token（JWT)"></a>Json Web Token（JWT)</h2><p>Json web token (JWT) 是目前最流行的跨域认证解决方案，JWT是一个开放标准 <a href="https://tools.ietf.org/html/rfc7519">(RFC 7519)</a>，它定义了一种紧凑且独立的方式，可以在客户端与服务器之间作为JSON对象安全地传输信息。</p><blockquote><p>官方定义：JSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties</p></blockquote><img src="jwt1.png" style="zoom:80%;"><p>现在网上大多数介绍JWT的文章实际介绍的都是JWS（JSON Web Signature），这也往往导致了大家对于JWT的误解，但是JWT并不等于JWS，JWS只是JWT的一种实现，除了JWS外，JWE（JSON Web Encryption）也是JWT的一种实现。</p><p>下面就来详细介绍一下JWS与JWE的两种实现方式：</p><h3 id="JSON-Web-Signature（JWS）"><a href="#JSON-Web-Signature（JWS）" class="headerlink" title="JSON Web Signature（JWS）"></a>JSON Web Signature（JWS）</h3><p>JSON Web Signature 是一个有着简单的统一表达形式的字符串。</p><img src="jwt2.png" style="zoom:60%;"><h4 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h4><p>头部用于描述关于该JWT的最基本的信息，例如：Token类型以及签名所用的算法等。</p><blockquote><p>JSON内容要经Base64 编码生成字符串才能成为Header。</p></blockquote><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;jwt&quot;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span> <span class="comment">//加密算法</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure><h4 id="载荷（PayLoad）"><a href="#载荷（PayLoad）" class="headerlink" title="载荷（PayLoad）"></a>载荷（PayLoad）</h4><p>payload的五个字段都是由JWT的标准所定义的。</p><ol><li>iss: 该JWT的签发者；</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方；</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的，即JWT生成的时间；</li></ol><p>还有一些其他的信息没有列举出来，也都是可以按需补充的。</p><blockquote><p>JSON内容要经Base64 编码生成字符串成为PayLoad。</p></blockquote><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Maple&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对其进行base64加密，得到JWT的第二部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ</span><br></pre></td></tr></table></figure><h4 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h4><p>这个部分是由base64加密后的header和base64加密后的payload，使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式，并使用密钥secret进行加密，生成签名。</p><p><strong>示例</strong></p><p>由上述base64加密的Header和PayLoad拼接并加密得到签名部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br></pre></td></tr></table></figure><p><strong>JWS的主要目的是保证了数据在传输过程中不被修改，验证数据的完整性。</strong></p><p>上述示例得到的完整的JWT整体格式为 <code>header.payload.signature</code> ，具体值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ.Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br></pre></td></tr></table></figure><h3 id="JSON-Web-Encryption（JWE）"><a href="#JSON-Web-Encryption（JWE）" class="headerlink" title="JSON Web Encryption（JWE）"></a>JSON Web Encryption（JWE）</h3><p>相对于JWS，JWE则同时保证了安全性与数据完整性。JWE由五部分组成：</p><img src="jwt3.png" style="zoom:80%;"><p>具体生成步骤为：</p><ol><li>JOSE含义与JWS头部相同。</li><li>生成一个随机的Content Encryption Key （CEK）。</li><li>使用RSAES-OAEP 加密算法，用公钥加密CEK，生成JWE Encrypted Key。</li><li>生成JWE初始化向量。</li><li>使用AES GCM加密算法对明文部分进行加密生成密文Ciphertext,算法会随之生成一个128位的认证标记Authentication Tag。</li><li>对五个部分分别进行base64编码。</li></ol><p>可见，JWE的计算过程相对繁琐，不够轻量级，因此适合数据传输而非token认证，但该协议也足够安全可靠，用简短字符串描述了传输内容，兼顾数据的安全性与完整性。</p><h2 id="JWT的使用"><a href="#JWT的使用" class="headerlink" title="JWT的使用"></a>JWT的使用</h2><blockquote><p>一般实际开发中说的JWT，实际上都是JWS，所以下述JWT默认就是JWS。</p></blockquote><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT?"></a>什么是JWT?</h3><p>json web token 通过<strong>数字签名</strong>的方法，以<strong>json对象</strong>为载体，在不同的服务器之间安全的传输信息。<br>简单来说：把信息进行安全的封装，以json的形式进行安全的网络传输。</p><h3 id="JWT的作用"><a href="#JWT的作用" class="headerlink" title="JWT的作用?"></a>JWT的作用?</h3><p>JWT最常见的场景就是<strong>授权认证</strong>，一旦用户进行了登录操作，服务端会返回一个JWT(token)给客户端，后续客户端的每个请求都在请求头中带上JWT(token)，系统在每次处理用户请求之前，都要先进行JWT安全校验，通过之后在进行处理。</p><p>用户在提交登录信息后，服务器校验数据后将通过密文的方式来生成一个字符串token返回给客户端，客户端在之后的请求会把token放在header里，在请求到达服务器后，服务器会检验和解密token，如果token被篡改或者失效将会拒绝请求，如果有效则服务器可以获得用户的相关信息并执行请求内容，最后将结果返回。</p><img src="jwt4.png" style="zoom:50%;"><h3 id="SpringCloud下如何使用JWT"><a href="#SpringCloud下如何使用JWT" class="headerlink" title="SpringCloud下如何使用JWT?"></a>SpringCloud下如何使用JWT?</h3><p>在微服务架构下,通常有单独一个服务Auth去管理相关认证，为了安全不会直接让用户访问某个服务，会开放一个入口服务作为网关gateway，所有请求首先访问gateway，由gateway将请求路由到各个服务，通常的做法在网关里进行请求拦截校验，来保证项目的安全性，下图是JWT在微服务中流程图（图中采用非对称加密算法，利用私钥在auth加密，公钥在网关gateway中解密，由此来减轻auth压力，此模型设计并不一定通用，架构设计主要根据实际场景和领域模型划分，可灵活设计并运用JWT）。</p><blockquote><p>针对非对称加密严格地说：公钥加密，私钥解密；私钥加签，公钥验签。</p></blockquote><img src="jwt5.png" style="zoom:80%;"><h2 id="关于JWT有效期与安全性"><a href="#关于JWT有效期与安全性" class="headerlink" title="关于JWT有效期与安全性"></a>关于JWT有效期与安全性</h2><p><strong>JWT如果使用不当，服务器如同裸奔~~~，在使用JWT是一定要注意。</strong></p><p>假如黑客监控电脑，抓包获取到JWT，伪造HTTP请求，对服务器是非常不安全的，常见的问题如下：</p><ul><li><strong>黑客修改HTTP中body的信息进行操作 - 篡改</strong>；<ul><li>修改body之后签名信息就不正确，然后就无法验证签名，说明数据被修改，数字签名的意义所在；</li></ul></li><li><strong>黑客伪造用户JWT进行访问和操作 - 伪造；</strong><ul><li>无法使用服务器的签名，所以在保证密钥不被泄露的情况下，不会被渗透；如果签名算法和秘钥泄露，那就是裸奔了；</li></ul></li><li><strong>黑客窃取JWT，模仿真实用户进行操作 - 冒充；</strong><ul><li>解决办法：<ul><li>对敏感api接口，采用https，https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。</li><li>或者在代码层面进行优化做安全检测：比如根据ip地址，设备码，一次性token机制，token时效期等措施来解决项目安全性问题等等</li></ul></li></ul></li></ul><h2 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此处只是一个Demo，在实际的开发中，还可以进行更个性化的封装，尤其是针对payload荷载部分，一般在开发中需要保存在JWT中的用户信息是一个POJO对象，而原生JWTBuilder中针对荷载部分的设置是使用 <code>claim()</code> 方法，用起来不是很方便，可以进行一个防腐层封装。</p><blockquote><p><strong>防腐层封装的个人思考</strong></p><p>JWT工具类的作用范围定位是全局，甚至是可以将其封装为一个基础的二方包，所以防腐层必须具有通用性，那么就不能使用POJO类型，因为无法确定需要支持的POJO的具体类型，可以考虑使用 Properties类型 、String类型、JSON串等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.lang.Collections;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;Maple&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     * 其中可选的参数是一些辅助性参数,在使用方可以用于一些校验.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> issuer    签发者|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject   JWT所面向的用户主体|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> audience  接收JWT的一方|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis 过期时间|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claimMap  载荷集合,就是需要加密的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String issuer, String subject, String audience, String key, <span class="type">long</span> ttlMillis, HashMap&lt;String, Object&gt; claimMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装自定义秘钥</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generateKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JWT自带的构造器构造一个jwt</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 封装header属性</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;AES&quot;</span>) <span class="comment">// 加密算法类型</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>) <span class="comment">// token类型</span></span><br><span class="line">                <span class="comment">// 封装payload属</span></span><br><span class="line">                .setId(UUID.randomUUID().toString()) <span class="comment">// JWT id,唯一标识</span></span><br><span class="line">                <span class="comment">// .setIssuer(issuer) // 签发者</span></span><br><span class="line">                <span class="comment">// .setSubject(subject) // 面向的用户主体</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// JWT创建时间</span></span><br><span class="line">                .setExpiration(now) <span class="comment">// JWT过期时间</span></span><br><span class="line">                .setAudience(audience) <span class="comment">// 接收JWT的一方</span></span><br><span class="line">                <span class="comment">// 构造signature部分</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装payload里的信息 使用claim方法</span></span><br><span class="line">        <span class="keyword">if</span> (!Collections.isEmpty(claimMap)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : claimMap.entrySet()) &#123;</span><br><span class="line">                builder.claim(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置JWT的过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (ttlMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">            builder.setExpiration(exp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt 待解析的JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Clamins, 即payload部分.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWTClaims</span><span class="params">(String key, String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parseJWT(key, jwt);</span><br><span class="line">        <span class="keyword">return</span> claimsJws.getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt 待解析的JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Jws&lt;Claims&gt;,包含Header,Clamins,Signature三个部分.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title function_">parseJWT</span><span class="params">(String key, String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generateKey(key);</span><br><span class="line">        <span class="comment">// 通过这个签名key对token进行解析</span></span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt);</span><br><span class="line">        <span class="keyword">return</span> claimsJws;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义字符串生成加密的秘钥|用于后续HS256加密加签.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title function_">generateKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringKey</span> <span class="operator">=</span> KEY_PREFIX + key;</span><br><span class="line">        <span class="comment">// base64 两种写法</span></span><br><span class="line">        <span class="type">byte</span>[] keySecretBytes = Base64.decodeBase64(stringKey);</span><br><span class="line">        <span class="comment">// byte[] keySecretBytes = DatatypeConverter.parseBase64Binary(stringKey);</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keySecretBytes, <span class="number">0</span>, keySecretBytes.length, SignatureAlgorithm.HS256.toString());</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Maple&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> createJWT(<span class="string">&quot;Maple&quot;</span>, <span class="string">&quot;Test&quot;</span>, <span class="string">&quot;Wuzi&quot;</span>, <span class="string">&quot;fjeoahgoeja&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>, map);</span><br><span class="line">  System.out.println(<span class="string">&quot;jwt = &quot;</span> + jwt);</span><br><span class="line">  Jws&lt;Claims&gt; claimsJws = parseJWT(<span class="string">&quot;fjeoahgoeja&quot;</span>, jwt);</span><br><span class="line">  System.out.println(claimsJws.getHeader().getAlgorithm());</span><br><span class="line">  System.out.println(claimsJws.getBody().getExpiration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwt = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ.Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br><span class="line">HS256</span><br><span class="line">Fri May 05 15:32:54 CST 2023</span><br></pre></td></tr></table></figure><p><font color="#dd0000"><strong>JWT的生成特点：可以重复请求，每次请求都会生成一个新的JWT，旧JWT依旧有效。</strong></font></p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.jianshu.com/p/50ade6f2e4fd">一篇文章带你分清楚JWT,JWS与JWE</a></p><p><a href="https://blog.csdn.net/han1725692339/article/details/126014021">JWT技术简介和使用</a></p><p><a href="https://blog.csdn.net/qq_40162735/article/details/105752127">JWT在微服务系统中的如何应用，如何保证安全性？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> 令牌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie &amp; Session</title>
      <link href="/maple/2023/05/05/Cookie-Session/"/>
      <url>/maple/2023/05/05/Cookie-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h1><p>Cookie和Session都是用来在浏览器中跟踪用户身份的会话方式，因为B to S的请求访问都是HTTP请求，而HTTP请求是无状态的，服务器端无法辨识请求是来自哪个客户端。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是一段保存在客户端的<strong>字符串</strong>，能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪用户的状态，一般一个 cookie存储的数据不超过3K。</p><h3 id="Cookie的工作原理："><a href="#Cookie的工作原理：" class="headerlink" title="Cookie的工作原理："></a>Cookie的工作原理：</h3><ol><li>浏览器第一次发送请求到浏览器端；</li><li>服务器端创建一个字符串Cookie，该Cookie中包含用户的信息，然后将该Cookie返回给浏览器端；</li><li>浏览器端再次访问服务器端时会在请求头中携带从服务器端获取的Cookie字符串；</li><li>服务器端通过Cookie中携带的数据便可以区分不同的用户；</li></ol><p>访问百度网站中浏览器中的Cookie示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cookie</span>:<span class="variable constant_">BIDUPSID</span>=7CA7EB951E290B33CA40110D9ED9C0D1; <span class="variable constant_">PSTM</span>=<span class="number">1587792871</span>; <span class="variable constant_">BD_UPN</span>=<span class="number">123253</span>;__yjs_duid=1_9d2ad8f9e190a6d780bbc7d44cd4d11c1620624931104; <span class="variable constant_">BAIDUID</span>=<span class="title class_">BE455C</span>05128<span class="attr">F1594C731E5B0B822F103</span>:<span class="variable constant_">SL</span>=<span class="number">0</span>:<span class="variable constant_">NR</span>=<span class="number">10</span>:<span class="variable constant_">FG</span>=<span class="number">1</span>;...</span><br></pre></td></tr></table></figure><p>PS：字符串很长，后面的省略了。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session是存储在服务器（应用服务器）上的<strong>对象</strong>，该对象由服务器创建并维护，Session存储的数据大小没有限制，服务器会为客户端与服务器的每一次会话过程都创建并维护一个Session对象。</p><h3 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h3><ol><li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session对象，同时会创建一个特殊的Cookie（是随机生成的一个标识Session对象的一个SessionId字符串），然后将该Cookie发送至浏览器端；</li><li>浏览器端发送第N（N&gt;1）次请求到服务器端，浏览器端访问服务器端的时候会在请求头中携带Cookie对象；</li><li>服务器端会根据Cookie的值去查询Session对象，从而区分不同的用户；</li></ol><p>简单的说，当你登陆一个网站的时候，如果web服务器端使用的是Session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话Sessionid（以Cookie的方式，Sessionid是服务器和客户端连接时候随机分配的），服务器根据当前Sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以客户端是无法伪造的。</p><p>如果浏览器使用的是Cookie，那么用户的所有数据都保存在浏览器端，比如：登陆以后，服务器设置了Cookie用户名，那么当再次请求服务器的时候，浏览器会将用户名一起发送给服务器，服务器会解析Cookie变量，所以只要不关闭浏览器，那么Cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的Cookie变量，然后伪造一个数据包发送过去，那么服务器会认为你是合法的。所以，使用Cookie被攻击的可能性比较大。</p><p>如果Cookie设置了有效期，那么Cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有Cookie，如果有的话，读取Cookie并发送给服务器。所以，如果你在个人PC上面保存了某个论坛Cookie，有效期是一年，如果有人入侵你的PC，将Cookie拷走，放在他的机器下面，那么他登陆该网站的时候就是用你的身份登陆的。当然，伪造的时候需要注意，直接Copy Cookie文件到 Cookie目录，浏览器是不认的，它有一个<code>index.dat</code> 文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 Cookie文件，并且要从保证时间上骗过浏览器。</p><p>两个都可以用来存用户数据，Session过期与否，取决于服务器的设定。Cookie过期与否，可以在Cookie生成的时候设置进去。</p><h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><h3 id="1、目标对象不同"><a href="#1、目标对象不同" class="headerlink" title="1、目标对象不同"></a>1、目标对象不同</h3><p><strong>Cookie</strong>：是针对每个网站的信息，每个网站只能对应一个，其他网站无法访问，这个文件保存在客户端，每次访问相应网站，浏览器都会查找该网站的 Cookies，如果有，则会将该文件发送出去。Cookies文件的内容大致上包括了诸如：用户名、密码、设置等信息。</p><p><strong>Session</strong>：是针对每个用户的，只有客户端才能访问，程序为该客户添加一个 Session。Session中主要保存用户的登录信息、操作信息等等。此 Session将在用户访问结束后自动消失。</p><h3 id="2、存储数据大小不同"><a href="#2、存储数据大小不同" class="headerlink" title="2、存储数据大小不同"></a>2、存储数据大小不同</h3><p><strong>Cookie</strong>：一个 Cookie存储的数据不超过3K。</p><p><strong>Session</strong>：Session存储在服务器上可以任意存储数据，当 Session存储数据太多时，服务器可选择进行清理。</p><h3 id="3、生命周期不同"><a href="#3、生命周期不同" class="headerlink" title="3、生命周期不同"></a>3、生命周期不同</h3><p><strong>Cookie</strong>：Cookie的生命周期当浏览器关闭的时候就消亡了，Cookie的生命周期是累计的，从创建时就开始计时，默认30min后Cookie生命周期结束，当然了，用户可以自定义有效时间。</p><p><strong>Session</strong>：Session的生命周期是间隔的，JSESSIONID的Cookie默认过期时间为-1，只需关闭浏览器当前窗口，该Session就会失效，因此Session不能长期有效。</p><h3 id="4、存储位置不同"><a href="#4、存储位置不同" class="headerlink" title="4、存储位置不同"></a>4、存储位置不同</h3><p><strong>Cookie</strong>：Cookie数据保存在客户端，不占用服务器资源。</p><p><strong>Session</strong>：Session数据保存在服务器端，如果数量过多很消耗大量内存空间。</p><h3 id="5、数据类型不同"><a href="#5、数据类型不同" class="headerlink" title="5、数据类型不同"></a>5、数据类型不同</h3><p>两者都是key-value结构，但针对value的类型是有差异的。</p><p><strong>Cookie</strong>：key是固定值：”Cookie”，value只能是ASCII字符串类型。</p><p><strong>Session</strong>：key是SessionId（名为JSESSIONID的一个Cookie），value是object类型。</p><h3 id="6、安全性不同"><a href="#6、安全性不同" class="headerlink" title="6、安全性不同"></a>6、安全性不同</h3><p>Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用Session。</p><h3 id="7、跨域支持"><a href="#7、跨域支持" class="headerlink" title="7、跨域支持"></a>7、跨域支持</h3><p>Cookie支持跨域访问；Session不支持跨域访问。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://worktile.com/kb/ask/28045.html">cookie与session区别</a></p><p><a href="https://blog.csdn.net/m0_65421722/article/details/127813102">Cookie和session的区别</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 1」-- 初识Sentinel &amp; Sentinel-Dashboard</title>
      <link href="/maple/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/"/>
      <url>/maple/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Sentinel-amp-Sentinle-Dashboard"><a href="#初识Sentinel-amp-Sentinle-Dashboard" class="headerlink" title="初识Sentinel &amp; Sentinle-Dashboard"></a>初识Sentinel &amp; Sentinle-Dashboard</h1><h2 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h2><h3 id="认识Sentinel"><a href="#认识Sentinel" class="headerlink" title="认识Sentinel"></a>认识Sentinel</h3><blockquote><p>官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p></blockquote><p><strong>Sentinel 具有以下特征:</strong></p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。只要是通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。常见的，可以使用方法签名，URL，甚至服务名称作为资源名来标识资源。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel可提供包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h2 id="Sentinel-功能和设计理念"><a href="#Sentinel-功能和设计理念" class="headerlink" title="Sentinel 功能和设计理念"></a>Sentinel 功能和设计理念</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><img src="sentinel1.png" style="zoom:40%;"><p>流量控制有以下几个角度:</p><ul><li><strong>资源的调用关系</strong>，例如：资源的调用链路，资源和资源之间的关系；</li><li><strong>运行指标</strong>，例如： QPS、线程池、系统负载等；</li><li><strong>控制的效果</strong>，例如：直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><h4 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h4><p>除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 <a href="https://github.com/Netflix/Hystrix/wiki#what-problem-does-hystrix-solve">Hystrix</a> 里面描述的问题是一样的。</p><img src="sentinel2.png" alt="sentinel2" style="zoom:40%;"><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，慢响应比例升高，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生服务雪崩。</p><blockquote><p><strong>服务雪崩</strong></p><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是服务雪崩。</p><p><strong>服务雪崩解决方案</strong></p><ul><li><strong>超时处理</strong>：设定资源请求的超时时间，请求时间超过阈值没有响应就返回错误信息，不会无休止等待。<ul><li>此种方式并不能从根本上解决问题，如果在超时之前有大量请求进来还是会造成请求堆积，仍然有节点崩溃的风险。而且超时时间的阈值不好确定，只能根据监控的RT统计数据给出一个相对合适的阈值。</li><li>个人理解：此方案只能适用于一些简单并且低流量的系统出现弱网或者网络抖动的场景；</li></ul></li><li><strong>线程隔离（也称为 舱壁模式）</strong>：常见的有两种实现为 <strong>线程池隔离</strong> 和 <strong>信号量隔离</strong>。<ul><li><strong>线程池隔离（Hystrix）</strong>：每个业务资源单独创建并分配一个线程池，将对业务资源的访问限制在线程池内，即使出现异常，最终也只是导致该线程池阻塞，不会影响其他业务资源。<ul><li>优点<ul><li>实现每个业务的完全隔离；</li><li>支持主动超时，即线程池中某个线程执行时间过长，可以主动关闭该线程；</li><li>支持异步调用，即利用线程池的异步特性实现异步调用；</li></ul></li><li>缺点：线程上下文的切换会消耗服务器的资源，极端情况下，服务器的CPU利用率飙升，但是处理能力却反而下降，因为服务器在忙着进行线程的上下文切换，而不是在执行业务。</li><li>场景：适合低扇出场景，即当前服务依赖的其他服务数量少，这样需要创建的线程池数量就少；</li></ul></li><li><strong>信号量隔离（Sentinel）</strong>：内部维护一个计数器，对每个调用的依赖服务的线程数进行统计，限制对依赖方的并发调用线程数；<ul><li>优点：轻量级，无额外开销；</li><li>缺点：<ul><li>不支持主动超时，信号量仅仅是一道控制开关的闸门，请求放行之后就无法控制了，请求的超时时间只能依赖RPC框架；</li><li>不支持异步调用，没有独立线程，无法实现异步调用；</li></ul></li><li>场景：适合高频调用、高扇出场景；</li></ul></li></ul></li><li><strong>熔断降级</strong>：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。<ul><li>内部会维护一个断路器，对单位时间内的业务执行异常比例、错误数量、慢调用比例等进行统计，并结合状态机模式实现断路器状态之间的切换，从而实现对目标场景的熔断降级。</li></ul></li><li><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。<ul><li>是一种<strong>故障预防</strong>方案。</li></ul></li></ul></blockquote><h4 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h4><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>（也称为 舱壁模式）的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（Java的线程映射LWP，所以Java的线程切换意味着用户态到内核态的切换和操作系统的线程调度，是一种很重的操作，会影响服务器的性能），还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li><strong>通过并发线程数进行限制</strong></li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，例如：响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li><strong>通过响应时间对资源进行降级</strong></li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h3 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h3><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2 id="Sentinel-是如何工作的"><a href="#Sentinel-是如何工作的" class="headerlink" title="Sentinel 是如何工作的"></a>Sentinel 是如何工作的</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如：该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>总体的框架如下:</p><img src="sentinel3.png" style="zoom:80%;"><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p>下面介绍一下各个 slot 的功能。</p><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><p>这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ContextUtil.enter(<span class="string">&quot;entrance1&quot;</span>, <span class="string">&quot;appA&quot;</span>);</span><br><span class="line"><span class="type">Entry</span> <span class="variable">nodeA</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;nodeA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeA != <span class="literal">null</span>) &#123;</span><br><span class="line">   nodeA.exit();</span><br><span class="line">&#125;</span><br><span class="line">ContextUtil.exit();</span><br></pre></td></tr></table></figure><p>上述代码通过 <code>ContextUtil.enter()</code> 创建了一个名为 <code>entrance1</code> 的上下文，同时指定调用发起者为 <code>appA</code>；接着通过 <code>SphU.entry()</code>请求一个 token，如果该方法顺利执行没有抛 <code>BlockException</code>，表明 token 请求成功。</p><p>以上代码将在内存中生成以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> machine-root</span><br><span class="line">           /     </span><br><span class="line">          /</span><br><span class="line">   EntranceNode1</span><br><span class="line">        /</span><br><span class="line">       /   </span><br><span class="line">DefaultNode(nodeA)</span><br></pre></td></tr></table></figure><p>注意：每个 <code>DefaultNode</code> 由资源 ID 和输入名称来标识。换句话说，一个资源 ID 可以有多个不同入口的 DefaultNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ContextUtil.enter(<span class="string">&quot;entrance1&quot;</span>, <span class="string">&quot;appA&quot;</span>);</span><br><span class="line"><span class="type">Entry</span> <span class="variable">nodeA</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;nodeA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeA != <span class="literal">null</span>) &#123;</span><br><span class="line">  nodeA.exit();</span><br><span class="line">&#125;</span><br><span class="line">ContextUtil.exit();</span><br><span class="line"></span><br><span class="line">ContextUtil.enter(<span class="string">&quot;entrance2&quot;</span>, <span class="string">&quot;appA&quot;</span>);</span><br><span class="line">nodeA = SphU.entry(<span class="string">&quot;nodeA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeA != <span class="literal">null</span>) &#123;</span><br><span class="line">  nodeA.exit();</span><br><span class="line">&#125;</span><br><span class="line">ContextUtil.exit();</span><br></pre></td></tr></table></figure><p>以上代码将在内存中生成以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            machine-root</span><br><span class="line">            /         \</span><br><span class="line">           /           \</span><br><span class="line">   EntranceNode1   EntranceNode2</span><br><span class="line">         /               \</span><br><span class="line">        /                 \</span><br><span class="line">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure><p>上面的结构可以通过调用 <code>curl http://localhost:8719/tree?type=root</code> 来显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EntranceNode: machine-root(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">-EntranceNode1: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">-EntranceNode2: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line"></span><br><span class="line">t:threadNum  pq:passQps  bq:blockedQps  tq:totalQps  rt:averageRt  prq: passRequestQps 1mp:1m-passed 1mb:1m-blocked 1mt:1m-total</span><br></pre></td></tr></table></figure><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。可通过如下命令查看某个资源不同调用者的访问情况：<code>curl http://localhost:8719/origin?id=caller</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: nodeA</span><br><span class="line">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class="line">1   caller1 0         0         0          0        0     0         0          0        </span><br><span class="line">2   caller2 0         0         0          0        0     0         0          0        </span><br></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p><ul><li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li><li><code>origin</code>：根据来自不同调用者的统计信息</li><li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li><li>入口的统计</li></ul><p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p><img src="51955215-0af7c500-247e-11e9-8895-9fc0e4c10c8c.png" alt="sliding-window-leap-array" style="zoom: 50%;"><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p><ul><li>指定应用生效的规则，即针对调用方限流的；</li><li>调用方为 other 的规则；</li><li>调用方为 default 的规则。</li></ul><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p><p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p><blockquote><p><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">Sentinel 核心类解析</a></p></blockquote><h2 id="服务保护框架对比"><a href="#服务保护框架对比" class="headerlink" title="服务保护框架对比"></a>服务保护框架对比</h2><p>常见的服务保护框架有：Sentinel 和 Hystrix（已经停止更新维护，从GitHub上看最后一次维护代码都是5、6年前了）</p><table><thead><tr><th>核心对比点</th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td><font color="#dd0000"><strong>隔离策略</strong></font></td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td><font color="#dd0000"><strong>熔断降级策略</strong></font></td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td><font color="#dd0000"><strong>限流</strong></font></td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td><font color="#dd0000"><strong>流量整形</strong></font></td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td><font color="#dd0000"><strong>控制台</strong></font></td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><blockquote><p>流量整形：将波动的请求流量整形为均匀的流量，避免尖峰流量对服务器的冲击。</p></blockquote><h2 id="Sentinel-Dashboard"><a href="#Sentinel-Dashboard" class="headerlink" title="Sentinel-Dashboard"></a>Sentinel-Dashboard</h2><p>Sentinel 控制台启动方式有两种：</p><ul><li>Sentinel官网提供了现成的sentinel-dashboard.jar包，down下来，通过<code>java -jar sentinel-dashboard.jar</code> 命令即可启动，默认端口为<code>8080；</code></li><li>下载Sentinel的源码，其中有Sentinel-Dashboard模块，使用Maven的<code>package</code> 命令打包，同样使用<code>java -jar xxx</code> 就可启动；</li></ul><p>启动之后，访问<code>localhost:8080</code>，进入Sentinel Dashboard界面，默认鉴权，账号和密码都为： sentinel</p><img src="dashboard1.png" style="zoom:40%;"><p>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar -Dserver.port=8090</span><br></pre></td></tr></table></figure><p>登录之后的主界面如下：</p><p><img src="dashboard2.png"></p><p>注：</p><ul><li>Sentinel 控制台需要有目标资源被调用，才会展示资源的相关配置模块，如果没有调用请求，控制台没有显示的。如上图中的<code>orderservice</code>就是因为已经有调用过该应用资源才会展示。</li><li>其中的流控规则-NACOS是利用Nacos作为注册中心对Sentinel的流控规则进行持久化的模块，需要对Sentinel源码进行修改。</li></ul><h2 id="控制台功能"><a href="#控制台功能" class="headerlink" title="控制台功能"></a>控制台功能</h2><p>根据上图可以清楚的看出Sentinel控制台提供的能力，本文结合个人实际开发中常用的一些功能模块进行介绍。</p><ul><li>实时监控</li><li>簇点链路</li><li>流控规则（嵌入后续对应模块中）</li><li>降级规则（嵌入后续对应模块中）</li><li>热点规则（嵌入后续对应模块中）</li><li>授权规则（嵌入后续对应模块中）</li></ul><h3 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h3><p>实时监控模块可以进行秒级的实时统计并展示。</p><p><img src="dashboard3.png"></p><h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>簇点链路就是项目内的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><p><img src="dashboard4.png"></p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防盗链</title>
      <link href="/maple/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/"/>
      <url>/maple/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h1><h2 id="防盗链的定义"><a href="#防盗链的定义" class="headerlink" title="防盗链的定义"></a>防盗链的定义</h2><p><strong>防盗链</strong>其实就是在网络服务器端进行个性化编程，通过URL过滤技术实现对目标资源控制访问。</p><p><strong>比如：</strong></p><p><code>file.maple.com/test.jpg</code>这个图片地址，如果没有装防盗链，那么任意用户都能通过该URL轻而易举的在他的网站上引用这个图片。如果对<code>file.maple.com</code> 这个地址进行服务器端编程，如给URL拼接参数，得到<code>file.maple.com/test.jpg?authcode=xxx&amp;ip=127.0.0.1</code>，自动拼接了ip参数，然后在对URL路由时针对IP参数进行个性化判断，就能实现只有<code>127.0.0.1</code>来访问这个链接，而其它的IP地址则无法访问该链接。</p><h2 id="防盗链的产生"><a href="#防盗链的产生" class="headerlink" title="防盗链的产生"></a>防盗链的产生</h2><p>一般我们在浏览网页时，一个完整的页面并不是客户端通过一次HTTP请求就将全部资源从服务器上拉取下来的，而是会分成很多次HTTP请求。如果客户端所浏览的页面带有图片或其它功能性信息，那么客户端的第一个HTTP请求就是想资源服务器端请求这个页面的文本信息，然后通过客户端的浏览器对服务器返回的数据进行解析，如果发现其中包含图片地址URL，那么客户端的浏览器会自动针对该图片URL再一次发送HTTP请求去获取目标图片并将其放置到目标位置，就这样一个完整的网络页面内部经过多次HTTP请求才能完整的展现出来。</p><p>基于此机制，就会产生盗链的问题。</p><blockquote><p><strong>个人理解</strong></p><p>盗链：全称应该是 盗取网络链接地址。</p></blockquote><p>如果一个网站中没有其页面中的图片信息，那么它完全可以链接访问到其他网站的图片信息。这样，没有任何资源的网站利用了其他网站的资源来展示给浏览者，提高了自己站点的访问量，而大部分浏览者又不会很容易地发现内部资源的调用过程，这样显然对于那些被利用了资源的网站是不公平的。一些不良网站为了不增加成本而扩充自己站点内容，经常盗用其他网站的链接。</p><h2 id="防盗链的实现"><a href="#防盗链的实现" class="headerlink" title="防盗链的实现"></a>防盗链的实现</h2><p>要实现防盗链，首先要理解盗链的实现原理，提到防盗链的实现原理就不得不从HTTP协议说起，在HTTP协议中，有一个表头字段叫 <code>referer</code>，其采用URL的格式来表示从哪儿链接到当前的网页或文件。换句话说，通过referer，网站可以检测到目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。有了<code>referer</code>跟踪来源就好办了，这时就可以通过技术手段来进行处理，一旦检测到来源不是期望的URL地址，那么就进行拦截或者返回降级页面和资源。 </p><p><strong>HTTP Headerss示例</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:authority: g.csdnimg.cn</span><br><span class="line">:method: GET</span><br><span class="line">:path: /static/logo/favicon32.ico</span><br><span class="line">:scheme: https</span><br><span class="line">accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">if-modified-since: Mon, 24 Apr 2023 09:23:28 GMT</span><br><span class="line">if-none-match: &quot;64464a90-10be&quot;</span><br><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?1</span><br><span class="line">sec-ch-ua-platform: &quot;Android&quot;</span><br><span class="line">sec-fetch-dest: image</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36</span><br></pre></td></tr></table></figure><p>其中refer为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br></pre></td></tr></table></figure><p>如果想对自己的网站进行防盗链保护，需要针对不同的情况进行区别对待。如果网站服务器用的是apache，那么使用apache自带Url Rewrite插件就可以很轻松实现各种防盗链，其原理是检查HTTP请求头中的refer属性值，如果refer的信息来自非目标站点则重定向到指定图片或网页上。还有很多其他的防盗链实现机制，总体上都换汤不换药，都是基于<code>refer</code>属性值进行个性化过滤。</p><hr><p><strong>参考文档：</strong></p><p><a href="http://www.zzbaike.com/wiki/%E9%98%B2%E7%9B%97%E9%93%BE">防盗链</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 协议</title>
      <link href="/maple/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/"/>
      <url>/maple/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2-0协议"><a href="#OAuth2-0协议" class="headerlink" title="OAuth2.0协议"></a><strong>OAuth2.0协议</strong></h1><h2 id="OAuth2-0-为何物"><a href="#OAuth2-0-为何物" class="headerlink" title="OAuth2.0 为何物"></a><strong>OAuth2.0 为何物</strong></h2><p>OAuth 简单理解就是一种授权机制，它是在客户端和资源所有者之间的授权层，用来分离两种不同的角色。在资源所有者同意并向客户端颁发令牌后，客户端携带令牌就可以访问资源所有者的资源。</p><blockquote><p>OAuth2.0 是OAuth 协议的一个版本，有2.0版本那就有1.0版本，有意思的是OAuth2.0 却不向下兼容OAuth1.0 ，相当于废弃了1.0版本。</p></blockquote><p>举个小栗子解释一下什么是 OAuth 授权？</p><p>订了个外卖，外卖小哥30秒火速到达了我家楼下，奈何有门禁进不来，可以输入密码进入，但出于安全考虑我并不想告诉他密码。此时外卖小哥看到门禁有一个高级按钮“一键获取授权”，只要我这边同意，他会获取到一个有效期 2小时的令牌（token）正常出入。</p><p>令牌（token）和 密码 的作用虽然相似都可以进入系统，但还有点不同。token 拥有权限范围，有时效性的，到期自动失效，而且修改无效。</p><p><strong>OAuth2.0中有四个重要角色：</strong></p><table><thead><tr><th align="center">角色</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">客户端</td><td align="center">本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，常见的就是用户常用的各种客户端，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</td></tr><tr><td align="center">资源拥有者</td><td align="center">通常为用户，也可以是应用程序，即该资源的拥有者。</td></tr><tr><td align="center">授权服务器（也称认证服务器）</td><td align="center">用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌 （access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。</td></tr><tr><td align="center">资源服务器</td><td align="center">存储资源拥有者所拥有的资源的服务器，比如：微信侧存储的用户信息。</td></tr></tbody></table><p><strong>拿微信授权其他平台登录为例，该角色在流程中对应关系如下：</strong></p><img src="auth1.png" style="zoom: 30%;"><h2 id="OAuth2-0-授权方式"><a href="#OAuth2-0-授权方式" class="headerlink" title="OAuth2.0 授权方式"></a><strong>OAuth2.0 授权方式</strong></h2><p>OAuth2.0 的授权简单理解其实就是获取令牌（token）的过程，OAuth 协议定义了四种获得令牌的授权方式（authorization grant ）如下：</p><ul><li><strong>授权码（<strong><strong>authorization-code</strong></strong>）</strong></li><li><strong>隐藏式（<strong><strong>implicit</strong></strong>）</strong></li><li><strong>密码式（<strong><strong>password</strong></strong>）：</strong></li><li><strong>客户端凭证（<strong><strong>client credentials</strong></strong>）</strong></li></ul><p>但值得注意的是，不管我们使用哪一种授权方式，在三方应用申请令牌之前，都必须在系统中去申请身份唯一标识：客户端 ID（client ID）和 客户端密钥（client secret）。这样做可以保证 token 不被恶意使用。</p><p>下面我们会分析每种授权方式的原理，在进入正题前，先了解 OAuth2.0 授权过程中几个重要的参数：</p><ul><li>response_type：code 表示要求返回授权码，token 表示直接返回令牌；</li><li>client_id：客户端身份标识；</li><li>client_secret：客户端密钥；</li><li>redirect_uri：重定向地址（用户同意授权之后，三方应用将返回的信息带回时调用的重定向地址，passport-third中三方登录接口的cap地址）；</li><li>scope：表示授权的范围，read只读权限，all读写权限；</li><li>grant_type：表示授权的方式，AUTHORIZATION_CODE（授权码）、password（密码）、client_credentials（凭证式）、refresh_token 更新令牌；</li><li>state：应用程序传递的一个随机数，用来防止CSRF攻击；</li></ul><blockquote><p>CSRF攻击 | 跨站请求伪造</p><p><a href="https://zhuanlan.zhihu.com/p/22521378">CSRF是什么？</a></p></blockquote><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a><strong>授权码</strong></h3><p>OAuth2.0四种授权中授权码方式是最为复杂，但也是安全系数最高的，比较常用的一种方式。这种模式是<strong>四种模式中最安全的一种模式</strong>。一般用于Web服务器端应用或第三方的原生App调用资源服务的时候。适用于兼具前后端的Web项目，因为有些项目只有后端或只有前端，并不适用授权码模式。</p><p>下图我们以用WX登录掘金为例，详细看一下授权码方式的整体流程。</p><img src="auth2.png" style="zoom:80%;"><p>用户选择WX登录掘金，掘金会向WX发起授权请求，接下来 WX询问用户是否同意授权（常见的弹窗授权）。response_type 为 code 要求返回授权码，scope 参数表示本次授权范围为只读权限，redirect_uri 重定向地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=code&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  </span></span><br><span class="line">scope=read</span><br></pre></td></tr></table></figure><p>用户同意授权后，WX 根据 redirect_uri重定向并带上授权码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//juejin.im/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>当掘金拿到授权码（code）时，带授权码和密匙等参数向WX申请令牌。grant_type表示本次授权为授权码方式 authorization_code ，获取令牌要带上客户端密匙 client_secret，和上一步得到的授权码 code。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token? </span></span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp; </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp; </span><br><span class="line">grant_type=authorization_code&amp; </span><br><span class="line">code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp; </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback</span></span><br></pre></td></tr></table></figure><p>最后 WX 收到请求后向 redirect_uri 地址发送 JSON 数据，其中的access_token 就是令牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;ACCESS_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">2592000</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;REFRESH_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="string">&quot;read&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  ...... </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Q：OAuth 2.0为什么不直接返回access_token?要设定为返回auth_code之后再去请求accessToken？</strong></p><p>主要出于安全方考虑，防止中间人攻击。假设第三方应用、授权服务不直接通信，中间隔了一层代理。且第三方应用采用HTTP协议，这样恶意代理就能窃取access token。因此，采用了通过code来交换access token的方式，来增加安全性。并且不能将access_token直接给到用户侧，相对于用户侧网络环境的复杂性，第三方应用自身服务端的网络环境相对更安全。</p><p>特别注意：对于授权码和access_token的篡改，在OAuth 1.0中是反复的对Code和Token进行签名，来保证Token不会被篡改，但是OAuth 2.0中却没有，因为OAuth 2.0是基于Https的，所以如果没有Https的支持OAuth 2.0可能还不如OAuth 1.0。在 OAuth 2.0 中，使用 HTTPS 可以说是必须的，而且 client 有义务验证证书的真假，防止中间人攻击，而 authorization server 和 resource server 都有义务申请可信任的第三方颁发的真实的 SSL 证书。</p></blockquote><h3 id="隐藏式（简化模式）"><a href="#隐藏式（简化模式）" class="headerlink" title="隐藏式（简化模式）"></a><strong>隐藏式（简化模式）</strong></h3><p>授权码模式：</p><img src="auth3.png" style="zoom:50%;"><p>简化版的授权码模式，跳过临时授权码的环节，只要用户一点击授权，就能直接返回access_token，而不是通过授权码code再次去获取。</p><img src="auth4.png" style="zoom:50%;"><blockquote><p>参数描述同授权码模式 ，注意response_type=token，说明是简化模式。</p></blockquote><p>上边提到有一些Web应用是没有后端的， 属于纯前端应用，无法用上边的授权码模式。令牌的申请与存储都需要在前端完成，跳过了授权码这一步。</p><p>前端应用直接获取 token，response_type 设置为 token，要求直接返回令牌，跳过授权码，WX授权通过后重定向到指定 redirect_uri 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=token&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  scope=read</span></span><br></pre></td></tr></table></figure><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a><strong>密码式</strong></h3><img src="auth5.png" style="zoom: 25%;"><p>密码模式比较好理解，用户在掘金直接输入自己的WX用户名和密码，掘金拿着信息直接去WX申请令牌，请求响应的 JSON结果中返回 token。grant_type 为 password 表示密码式授权。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?  </span></span><br><span class="line">grant_type=password&amp;  </span><br><span class="line">username=<span class="variable constant_">USERNAME</span>&amp;  </span><br><span class="line">password=<span class="variable constant_">PASSWORD</span>&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span></span><br></pre></td></tr></table></figure><p>这种授权方式简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下，或者第一方原生APP或第一方单页面应用。</p><h3 id="客户端凭证式"><a href="#客户端凭证式" class="headerlink" title="客户端凭证式"></a><strong>客户端凭证式</strong></h3><img src="auth6.png" style="zoom:25%;"><p>凭证式和密码式很相似，主要适用于那些没有前端的命令行应用，可以用最简单的方式获取令牌，在请求响应的 JSON 结果中返回 token。</p><p>grant_type 为 client_credentials 表示凭证式授权，client_id 和 client_secret 用来识别身份。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?  </span></span><br><span class="line">grant_type=client_credentials&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span></span><br></pre></td></tr></table></figure><h2 id="令牌的使用与更新"><a href="#令牌的使用与更新" class="headerlink" title="令牌的使用与更新"></a><strong>令牌的使用与更新</strong></h2><h3 id="1、令牌怎么用？"><a href="#1、令牌怎么用？" class="headerlink" title="1、令牌怎么用？"></a><strong>1、令牌怎么用？</strong></h3><p>拿到令牌可以调用 WX API 请求数据了，那令牌该怎么用呢？</p><p>每个到达WX的请求都必须带上 token，将 token 放在 http 请求头部的一个Authorization字段里。</p><p>如果使用postman 模拟请求，要在Authorization -&gt; Bearer Token 放入 token，注意：低版本postman 没有这个选项。</p><p><img src="auth7.png"></p><h3 id="2、令牌过期怎么办？"><a href="#2、令牌过期怎么办？" class="headerlink" title="2、令牌过期怎么办？"></a><strong>2、令牌过期怎么办？</strong></h3><p>token是有时效性的，一旦过期就需要重新获取，但是重走一遍授权流程，不仅麻烦而且用户体验也不好，那如何让更新令牌变得优雅一点呢？</p><p>一般在颁发令牌时会一次发两个令牌，一个令牌用来请求API，另一个负责更新令牌 refresh_token。grant_type 为 refresh_token 请求为更新令牌，参数 refresh_token 是用于更新令牌的令牌。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token?  </span></span><br><span class="line">grant_type=refresh_token&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;  </span><br><span class="line">refresh_token=<span class="variable constant_">REFRESH_TOKEN</span></span><br></pre></td></tr></table></figure><h3 id="3、令牌的维护"><a href="#3、令牌的维护" class="headerlink" title="3、令牌的维护"></a>3、令牌的维护</h3><p>因为各大三方开放平台，比如：支付宝、微信等等，access_token的特点是重复请求获取会刷新，每次请求获取access_token得到的都是不同的值，所以一般实际开发中，针对access_token会集中进行维护和管理，避免在多个应用中使用时会出现重新请求获取access_token导致旧access_token过期，从而三方业务请求失败，这种场景就是常说的：共享token问题。在实际开发中应尽量避免，因为一旦发生排查起来会很困难。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/327856449">OAuth2.0 的四种授权方式，值得一看</a></p><p><a href="https://blog.csdn.net/weixin_45525272/article/details/125920928">OAuth2.0 四种授权模式（图解）</a></p><p><a href="https://www.cnblogs.com/yakniu/p/16387713.html">OAuth 2.0 授权认证详解</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位枚举</title>
      <link href="/maple/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"/>
      <url>/maple/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="位枚举"><a href="#位枚举" class="headerlink" title="位枚举"></a>位枚举</h1><p>也称为 二进制枚举。</p><h2 id="什么是位枚举"><a href="#什么是位枚举" class="headerlink" title="什么是位枚举"></a>什么是位枚举</h2><p>位枚举也是一个枚举类，只不过其是利用二级制位运算来实现与枚举项的比较、包含、不包含等运算，其主要思想就是利用高性能的位运算操作来替换传统的大小比较，集合是否包含等方法，以此来进一步提高业务代码的性能。</p><p><strong>常见的使用场景：</strong></p><ul><li>标签字段</li><li>类型字段</li><li>等…</li></ul><p>位枚举并不复杂。下面以标签字段的应用场景分别使用传统的枚举操作和位枚举进行对比说明，加深对位枚举的理解和应用。</p><h2 id="传统枚举"><a href="#传统枚举" class="headerlink" title="传统枚举"></a>传统枚举</h2><p>枚举类定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标签枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderTagEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL_ORDER(<span class="number">1</span>, <span class="string">&quot;普通订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    SECKILL_ORDER(<span class="number">2</span>, <span class="string">&quot;秒杀订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    THIRD_SERVICE_ORDER(<span class="number">3</span>, <span class="string">&quot;三方服务订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    OrderTagEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderTagEnum <span class="title function_">getEnumByCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> tagEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库中的标签字段定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags<span class="type">varchar</span>(<span class="number">64</span>)<span class="keyword">null</span> comment <span class="string">&#x27;标签,List的json串&#x27;</span>,</span><br></pre></td></tr></table></figure><p>如此，当我们以传统形式的枚举去表示标签时，那么对应的数据库表中对应的字段存储的值形式会是下图这样的格式（在代码防腐层，保存前我们会将以<code>List&lt;Integer&gt;</code>集合形式存储的tags标签值转换为Json字符串），常用的序列化组件有：Jackson、Gson、Fastjson等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">tagsJson</span> <span class="operator">=</span> gson.toJson(Lists.newArrayList(OrderTagEnum.SECKILL_ORDER.getCode(), OrderTagEnum.THIRD_SERVICE_ORDER.getCode()));</span><br></pre></td></tr></table></figure><p>存储的结果如下图：</p><p><img src="enum1.png"></p><p>与保存时对应，当进行数据库查询时，我们去查询库表，同样在代码防腐层会进行发序列化处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">List&lt;Integer&gt; tagList = gson.fromJson(order.getTags(), <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;List&lt;Integer&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="传统枚举场景分析"><a href="#传统枚举场景分析" class="headerlink" title="传统枚举场景分析"></a>传统枚举场景分析</h3><h4 id="性能侧"><a href="#性能侧" class="headerlink" title="性能侧"></a>性能侧</h4><p>在以上使用传统枚举的过程中，保存数据库之前将标签字段序列化为Json串，查询数据库时再将Json串反序列化为List集合，在代码防腐层对标签字段的这两次序列化和反序列化操作，相比于标签字段直接存储，严格意义上来说是会存在一定的性能损耗，但是随着序列化组件性能的不断优化和服务器性能的提升，这两次序列化和反序列化操作对代码性能的影响可忽略不计，当然，这也不是位枚举的核心意义之所在。</p><h4 id="数据库侧"><a href="#数据库侧" class="headerlink" title="数据库侧"></a>数据库侧</h4><p><strong>增 | 改</strong> 都是针对数据库原数据新增和更新操作，剩下就是上述性能侧同样的问题。</p><p><font color="#dd0000"><strong>查 | 删</strong> </font>就会涉及到数据库原数据字段的业务操作，比如：查询、统计或者删除指定标签的记录，判断记录是否包含指定标签等场景。针对这些逻辑使用传统的枚举实现的步骤为：</p><ol><li><font color="\#00dd00">分页批量查询所有记录或者利用字符串模糊查询目标记录；</font></li><li>将tags字段反序列化为<code>List&lt;Integer&gt;</code>；</li><li><font color="\#00dd00">利用List集合的API方法，指定标签值；</font></li><li>进行后续逻辑处理；</li></ol><p>其中，<code>步骤1</code>和<code>步骤3</code>是整个业务链路中性能影响最明显的环节，同时，此环节也是<strong>位枚举的核心意义之所在</strong>。</p><h2 id="位枚举-1"><a href="#位枚举-1" class="headerlink" title="位枚举"></a>位枚举</h2><p>位枚举是指利用<strong>位运算实现的枚举类，枚举的code值必须是2的幂数，一般使用2^0，2^1，2^2，…依次递增</strong>。这样的话我们就可以利用位运算去快速的处理和枚举相关的业务。说到位运算大家第一反应应该都是<strong>速度嘎嘎快</strong>。</p><h3 id="位枚举的核心思想"><a href="#位枚举的核心思想" class="headerlink" title="位枚举的核心思想"></a>位枚举的核心思想</h3><ul><li><font color="#dd0000">枚举项的code值请以2的幂数递增，如: 1,2,4,8,16,32,64,128… </font></li><li><font color="#dd0000">任意两个整数m和n，如果m和n都是2的幂数，那么m和n进行按位<strong>或运算</strong>的结果就等于m和n的<strong>字面值相加</strong> </font> ，什么意思呢？<ul><li>即：m|n = m+n，如m=2，n=4，那么m|n = 6。此处等价于<strong>加法运算</strong>。</li></ul></li><li><font color="#dd0000">任意两个整数m和n，如果m和n都是2的幂数，p是m和n按位或的结果，那么就有p&amp;n=n，p&amp;m=m，类似于减法运算。 </font></li></ul><p><strong>位枚举定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标签位枚举.</span></span><br><span class="line"><span class="comment"> * ps: 枚举项的code值请以2的幂数递增，如: 1,2,4,8,16,32,64,128....</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderTagEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL_ORDER(<span class="number">1</span>, <span class="string">&quot;普通订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    SECKILL_ORDER(<span class="number">2</span>, <span class="string">&quot;秒杀订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    THIRD_SERVICE_ORDER(<span class="number">4</span>, <span class="string">&quot;三方服务订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    OrderTagEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过枚举项值获取对应的枚举项</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderTagEnum <span class="title function_">getEnumByCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(code)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> tagEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断入参tag是否包含tagEnum枚举项.</span></span><br><span class="line"><span class="comment">     * 一个整数 &amp; 枚举项code = 枚举项code,表示该整数包含枚举项.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag     多个标签的code累加和.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagEnum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isHasTag</span><span class="params">(Integer tag, OrderTagEnum tagEnum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tag) || Objects.isNull(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (tagEnum.getCode() &amp; tag) == tagEnum.getCode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取tag包含的所有标签枚举集合.</span></span><br><span class="line"><span class="comment">     * 传入给定整数和任意枚举项进行按位与运算,结果等于枚举项本身，说明给定整数包含此枚举项.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag 多个标签的code累加和.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderTagEnum&gt; <span class="title function_">getTagEnumList</span><span class="params">(Integer tag)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;OrderTagEnum&gt; tagList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((tagEnum.getCode() &amp; tag) == tagEnum.getCode()) &#123;</span><br><span class="line">                tagList.add(tagEnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tagList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举项集合按位或运算 得到所有爱好的整数结果.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagEnumList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">calculate</span><span class="params">(List&lt;OrderTagEnum&gt; tagEnumList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tagEnumList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : tagEnumList) &#123;</span><br><span class="line">            result |= tagEnum.getCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的数据库标签字段也修改为Long类型，而不再是Json字符串：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags<span class="type">bigint</span><span class="keyword">null</span> comment <span class="string">&#x27;标签&#x27;</span>,</span><br></pre></td></tr></table></figure><p>数据库标签字段存储变成了：</p><p><img src="enum2.png"></p><h3 id="位枚举场景分析"><a href="#位枚举场景分析" class="headerlink" title="位枚举场景分析"></a>位枚举场景分析</h3><p><strong>增 | 改</strong> 都是针对数据库原数据增加或者更新操作，代码防腐层不再需要序列化和反序列化操作。</p><p><font color="#dd0000"><strong>查 | 删</strong> </font> 同样是查询、统计或者删除指定标签的记录，判断记录是否包含指定标签等场景。步骤就变成了业务代码的位运算和SQL脚本的位运算。</p><p>如：查询三方服务标签和秒杀标签的记录。</p><p> 秒杀标签code | 三方服务标签code : 2 | 4 = 6，调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long tagValue = OrderTagEnum.calculate(Arrays.asList(OrderTagEnum.NORMAL_ORDER,OrderTagEnum.THIRD_SERVICE_ORDER));</span><br></pre></td></tr></table></figure><p>到SQL层面，入参#{tagValue}就为6，SQL层使用位与运算，就可以查询到所有包含三方服务标签和秒杀标签的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cloud_order.tb_order</span><br><span class="line"><span class="keyword">where</span> #&#123;tagValue&#125; <span class="operator">=</span>  tags <span class="operator">&amp;</span> #&#123;tagValue&#125;;</span><br></pre></td></tr></table></figure><p>tagValue为6时的结果：</p><p><img src="enum3.png"></p><p>查询到结果之后，在代码层调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderTagEnum&gt; tagList = OrderTagEnum.getTagEnumList(tagValue);</span><br></pre></td></tr></table></figure><p>得到目标值tagValue包含的所有标签枚举项列表。</p><blockquote><p>一般情况下，位枚举相关业务涉及到数据库的操作时，通常也需要结合SQL的位运算来支撑位枚举。</p></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1746867064605404073&wfr=spider&for=pc">位枚举应用</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
