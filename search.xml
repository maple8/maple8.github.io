<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库-一种通用配置表设计</title>
      <link href="/2024/05/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80%E7%A7%8D%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/05/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%B8%80%E7%A7%8D%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库-一种通用配置表设计"><a href="#数据库-一种通用配置表设计" class="headerlink" title="数据库-一种通用配置表设计"></a>数据库-一种通用配置表设计</h1><h2 id="配置表"><a href="#配置表" class="headerlink" title="配置表"></a>配置表</h2><p>通过配置表，可以灵活的实现对某些业务场景的配置。比如：开发中某些经常变更的参数值，使用配置。如 订单30分钟后失效，需求变更，要改为15分钟，那么直接改配置表内容就行，不用发版。某些关键的容易出错的逻辑，加上一个开关，比如： config_value 为 0或1，为1表示开，为0表示关。不需要的逻辑，可以及时用开关关掉。或者是逻辑复杂，开发环境造数据麻烦时，也可以用配置表配置开关，把前置条件关掉，方便验证数据。或者通过配置表实现各场景下的处理器组合（即各种职责链）等。</p><h3 id="配置表单表设计"><a href="#配置表单表设计" class="headerlink" title="配置表单表设计"></a>配置表单表设计</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `xxx_config` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `config_key` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置的KEY&#x27;</span>,</span><br><span class="line">  `config_value` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;配置值&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;状态：0-不可用；1-可用&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_config_key` (`config_key`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4  COMMENT<span class="operator">=</span><span class="string">&#x27;xxx配置表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>根据实际的业务场景，配置的粒度可以控制，一个配置可以拆分为多个<code>config_key</code>、<code>config_value</code>，也可以使用一个配置，将配置值封装为一个JSON字符串。</p><h3 id="通用配置表设计"><a href="#通用配置表设计" class="headerlink" title="通用配置表设计"></a>通用配置表设计</h3><p>通用的配置表设计，有一张<strong>配置字典表</strong>，字典表中记录各项配置的信息，另一张是<strong>配置信息表</strong>，记录着具体场景的配置值。<br>字典表的内容可以按照实际的业务增加更通用的字段，比如记录日志，是否需要权限校验等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `xxx_config_dic` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `config_key` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置名称，不能重复，唯一确定一项配置&#x27;</span>,</span><br><span class="line">  `config_type` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置类型&#x27;</span>,</span><br><span class="line">  `config_desc` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置说明&#x27;</span>,  </span><br><span class="line">  `default_value` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置的默认值&#x27;</span>,</span><br><span class="line">  <span class="comment">-- 这些都是通用的业务字段，视具体场景而定</span></span><br><span class="line">  `check_rule` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;校验配置项值的规则&#x27;</span>,  </span><br><span class="line">  `permission_enable` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否要校验权限&#x27;</span>,  </span><br><span class="line">  `operation_log` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否需要按该字段的内容日志&#x27;</span>,</span><br><span class="line">  <span class="comment">--</span></span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;状态：0-不可用；1-可用&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间（单位:毫秒）&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间（单位:毫秒）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;xxx配置字典表&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `xxx_config_info` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `config_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;config_dic表主键id&#x27;</span>,</span><br><span class="line">  `config_value` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;配置值&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">BIGINT</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间（单位:毫秒）&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">BIGINT</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间（单位:毫秒）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_ccftenant_config_info_user_id` (`user_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;xxx配置信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/sinat_32502451/article/details/133959699?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-133959699-blog-127112210.235%5Ev43%5Epc_blog_bottom_relevance_base2&spm=1001.2101.3001.4242.1&utm_relevant_index=1">java业务开发常用的配置表及代码</a></p><p><a href="https://blog.csdn.net/weixin_43554422/article/details/127112210">一种通用配置业务设计方式</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-表设计规范</title>
      <link href="/2024/05/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2024/05/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%A1%A8%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库-表设计规范"><a href="#数据库-表设计规范" class="headerlink" title="数据库-表设计规范"></a>数据库-表设计规范</h1><blockquote><p>数据库表设计是系统工程，影响业务功能和系统性能。设计时要规范命名，合理选择字段类型和长度，谨慎增加字段，设置主键，建立合理索引，避免使用外键，明确数据表约束，善用JSON，注意大字段，数据冷热分离，完善注释，统一同类字段。</p></blockquote><h3 id="一、规范命名"><a href="#一、规范命名" class="headerlink" title="一、规范命名"></a>一、规范命名</h3><p>表名、字段名和索引名的命名规范是数据库设计的第一步。</p><ul><li>名称要能见名知意，言简意赅，不宜过长。比如：用户表可以命名为<code>user</code>，而不是<code>u</code>或者<code>user_info_detail</code>。</li><li>多个单词间建议使用下划线分隔，统一使用全小写格式，如<code>order_detail</code>。</li><li>每个业务模块可使用统一前缀，如订单相关的表都以<code>order</code><em>为前缀。</em></li><li>时间字段可统一使用 <code>_time</code>结尾，如<code>create_time</code>。</li><li>主键索引以<code>pk_</code>开头,普通索引以<code>idx_</code>开头,唯一索引以<code>uk_</code>开头。条理清晰的命名规范是提高数据库可读性的基础。</li></ul><h3 id="二、选择合适的字段类型和长度"><a href="#二、选择合适的字段类型和长度" class="headerlink" title="二、选择合适的字段类型和长度"></a>二、选择合适的字段类型和长度</h3><p>字段的类型和长度要根据实际业务需求来选择，不能一味追求大而全。如用户名可以使用varchar(32)，评论内容可以使用varchar(512)。针对固定长度的内容，要优先考虑使用char型。日期时间毫秒精度可使用bigint存Unix时间戳。选择恰当的类型和长度，可以节省存储空间，提高查询效率。</p><blockquote><p><strong>数据库字段长度表示 字符长度 还是 字节长度？</strong></p><p>在mysql中，<code>varchar</code> 和 <code>char</code> 类型表示字符长度，而其他类型表示的长度都表示字节长度。也就是说，<code>varchar</code> 和 <code>char</code> 类型的实际存储空间（占用字节长度）和字符的字符集决定，不同字符集下每个字符占用的字节长度是不一样的。如： UTF8 编码 (3字节)、GBK 编码 (2字节) </p><table><thead><tr><th>数据类型</th><th>取值范围</th><th>描述</th></tr></thead><tbody><tr><td><code>CHAR</code></td><td><code>0~255</code>字符</td><td>CHAR 是用于存储固定长度的字符串的数据类型。它需要指定字符串的最大字符长度（可以使用 CHAR(M) 来指定最大字符长度，其中的 M 即为最大字符长度），取值范围为 0 ~ 255（当最大字符长度为 0 时，MySQL 允许你向该字段中插入值，但该操作并不会成功）。如果存储的字符串长度小于指定长度，MySQL 会在字符串末尾使用 空格 字符进行填充，以使其达到指定长度。这意味着 <strong>CHAR 类型的字段始终占用指定长度的存储空间，无论实际存储的字符串长度是多少。</strong></td></tr><tr><td><code>VARCHAR</code></td><td><code>0~65,535</code> 字符</td><td>VARCHAR 是用于存储可变长度的字符串的数据类型。它也需要指定字符串的最大长度，最大可为 65,535 个字符（可以使用 VARCHAR(M) 来指定最大字符长度，其中的 M 即为最大字符长度）。与 CHAR 不同，<strong>VARCHAR 只会占用实际存储的字符长度（单个字符所占据的存储空间由其使用的字符集决定）加上一定的额外字节（一或两个字节）</strong>，而不会固定占用指定长度的存储空间。</td></tr></tbody></table><ul><li><p>char(10) 表示字符长度是10。实际存储空间 = 10 * 当前字符集下字符的字节数</p></li><li><p>bigint(4) 表示<strong>显示长度</strong>是4个字节，但是bigint类型是8个字节，所以bigint(4) 的实际存储空间长度是8个字节。</p></li><li><p>int(10) 和 bigint(10)能存储的数据大小一样吗？<strong>不一样</strong>，具体原因如下：</p><p>int 能存储4字节有符号整数。bigint 能存储8字节有符号整数。所以能存储的数据大小不一样，其中的数字 10  代表的只是数据的<strong>显示宽度</strong>。显示宽度指明Mysql最大可能显示的数字个数，数值的位数小于指定的宽度时数字左边会用空格填充，空格不容易看出。如果插入了大于显示宽度的值，只要该值不超过该类型的取值范围，数值依然可以插入且能够显示出来。建表的时候指定 zerofill 选项，则不足显示宽度的部分用 0 填充，如果是 1 会显示成 0000000001。如果没指定显示宽度， bigint 默认宽度是 20 ，int默认宽度 11。</p></li></ul></blockquote><h3 id="三、谨慎增加字段"><a href="#三、谨慎增加字段" class="headerlink" title="三、谨慎增加字段"></a>三、谨慎增加字段</h3><p>表中字段数目并非越多越好，<strong>建议单表字段数不超过20个</strong>。如字段过多时要考虑垂直拆分，将不常用的字段拆到扩展表中。对于一些可选字段，如用户的昵称、头像等，更建议单独建立一张用户扩展信息表。必要时也可以通过冗余字段来提高查询效率，如在订单表中冗余用户名称。在充分考虑实际需求的前提下，尽可能保持表的字段数精简。</p><ul><li>查询效率：当表中保存的数据数量很大时，查询操作需要检索的数据也会随之增加。 如果表的字段数过多，查询操作就需要读取更多的数据，这会导致查询效率变慢。</li><li>存储空间：表的字段数越多，每一行数据占用的存储空间也就越大。对于大型数据库来说，这可能会导致磁盘空间的浪费。</li><li>数据库设计复杂性：当表的字段数过多时，数据库的设计和维护变得更加复杂。 这可能涉及到索引和关联表的设计，以确保数据的完整性和一致性。</li></ul><h3 id="四、主键不可或缺"><a href="#四、主键不可或缺" class="headerlink" title="四、主键不可或缺"></a>四、主键不可或缺</h3><p>每张表都必须有主键，并且要尽量使用单一主键。因为<strong>主键查询效率最高</strong>，是天然的聚簇索引。常见的主键设置方式有以下几种：自增长型(auto_increment)、全局唯一ID(UUID)、雪花算法(SnowFlake)等。尽量不要使用联合主键，因为其不仅占用更多空间，还会影响查询性能。另外<strong>主键要避免存储业务相关的值</strong>，如学号、员工号等，以便日后业务变动时更易调整。</p><h3 id="五、合理添加索引"><a href="#五、合理添加索引" class="headerlink" title="五、合理添加索引"></a>五、合理添加索引</h3><p>合理的索引设计可以大幅提升数据查询效率。但索引并非越多越好，<strong>因其会占用额外的存储空间，并影响写操作的效率</strong>。<strong>单表索引数建议控制在5个以内</strong>。针对区分度不高的字段如性别，不建议单独创建索引。针对多个查询条件，可通过建立联合索引来减少索引数量。联合索引还需要考虑字段顺序，遵循最左前缀原则。必要时还可针对字符串采用前缀索引等高级索引技术。</p><h3 id="六、NULL值要明确"><a href="#六、NULL值要明确" class="headerlink" title="六、NULL值要明确"></a>六、NULL值要明确</h3><p>建表时就要明确每个字段是否可空。对可为空的字段一定要在创建表时显式指定为NULL，否则字段将隐式地被指定为NOT NULL。选择NULL还是NOT NULL要根据实际的业务语义。比如用户的邮箱字段可以为NULL，但性别字段可能就不允许为NULL值。NOT NULL字段在保存时可以少一个字节的存储空间，且NULL值会导致索引失效。因此除非有很明确的业务需求，否则尽量将字段都设置为NOT NULL。</p><p>如果没有特殊的理由， 一般都建议将字段定义为NOT NULL。为什么呢？<br>首先，NOT NULL可以防止出现空指针问题<br>其次，NULL值存储也需要额外的空间的，它也会导致比较运算更为复杂，使优化器难以优化SQL，NULL值有可能会导致索引失效，所以不能在NULL的字段上添加索引<br>如果将字段默认设置成一个空字符串或常量值并没有什么不同，且都不会影响到应用逻辑， 那就可以将这个字段设置为NOT NULL。</p><h3 id="七、不需要严格守3NF，通过业务字段余来减少表关联"><a href="#七、不需要严格守3NF，通过业务字段余来减少表关联" class="headerlink" title="七、不需要严格守3NF，通过业务字段余来减少表关联"></a>七、不需要严格守3NF，通过业务字段余来减少表关联</h3><p>简单来说就是<strong>反范式设计</strong>。 常见形式是在第三范式(3NF)的基础上，进一步进行冗余，从而减少表关联。</p><blockquote><p>回顾下什么是数据库三范(3NF)?<br>第一范式：对属性的原子性，要求属性具有原子性， 不可再分解；<br>第二范式：对记录的唯一性，要求记录有唯一标识， 即实体的唯一性，即不存在部分依赖；<br>第三方式：对字段的余性， 要求任何字段不能由其他字段派生出来，它要求字段没有余，即不存在传递依赖；</p></blockquote><p>假设需要设计一个产品订单表，包含以下字段： 订单ID、 用户ID、 订单日期、 产品名称、 产品价格、产品数量以及订单总价。 正常情况下，可能会分别设计订单表和产品表，并使用外键进行关联，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">order</span>(</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO INCREMENT,</span><br><span class="line">  user_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  order_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  product_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  quantity <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (product_id) <span class="keyword">REFERENCES</span> product(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product(</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO INCREMENT,</span><br><span class="line">  name <span class="type">Varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>这个设计方式符合范式要求， 但在查询时需要进行表关联操作， 可能会降低查询效率。为了提高查询效率，我们可以使用反范式的设计方式，将订单表中的产品名称、 产品价格 和 订单总价 余存储到订单表中，从而避免关联查询。 例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">order</span>(</span><br><span class="line">  id <span class="type">int</span>(<span class="number">11</span>） <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO INCREMENT,</span><br><span class="line">  userid <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  order_date <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  product_name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  product_price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  quantity <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  total_price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>通过这种反范式的设计方式， 我们可以避免关联操作，提高查询效率。 但同时也带来了一些缺点，例如数据冗余、 数据更新困难等。 因此， 在实际应用中需要根据具体情况进行选择。 </p><h3 id="八、外键须谨慎"><a href="#八、外键须谨慎" class="headerlink" title="八、外键须谨慎"></a>八、外键须谨慎</h3><p>在数据库设计中，使用外键关联是一种良好的实践，可以确保数据的完整性和一致性。 外键关联可以帮助维护表之间的关系，防止无效或不一致的数据插入、 更新或删除操作。然而，在某些情况下，也存在一些缺点，这可能是导致现在不太推荐使用外键关联的原因之一。 以下是一些这种情况：</p><ul><li><p> 可能会导致性能问题，无其是在对大型数据集进行操作时。这是因为每次插入、 更新或删除操作都需要进行约束检查，这可能会导致额外的开销和延退。</p></li><li><p>可能会限制数据库的灵活性和可扩展性。 例如，如果需要对数据库进行分区或垂直分割，外键关联可能会导致额外的复杂性和限制</p></li><li><p>可能会导致死锁和死循环， 特别是在进行并发操时。这可能会导致数据库出现不稳定的状态，从而影响系统的性能和可用性</p></li><li><p>可能会导致数据库的维护和管理成本的增加。 这是因为外键关联需要额外的管理和维护工作，例如添加、 修改或删除外键约束时需要额处的测试和验证</p></li></ul><p>因此，在决定是否使用外键关联时， 需要考虑实际业务需求和场景，并进行权衡和决策。 在某些情况下，可以采用其他方法来保证数据的完整性和一致性，例如使用应用程序逻辑或数据库触发器来实现约束检查和数据操作。同时，需要注意数据库设计的基本原则和最佳实践， 例如避免数据余、 遵循规范化原则和正常化理论等。 因此实际项目中往往在程序层面来保证数据的一致性，很少使用外键这种强约束。同理像触发器、存储过程等也要尽量避免使用。</p><h3 id="九、时间的类型选择"><a href="#九、时间的类型选择" class="headerlink" title="九、时间的类型选择"></a>九、时间的类型选择</h3><p>时间类型的选择一般都要好好考虑，因为不同的类型存储的格式不同。对于MySQL来说， 主要有<code>date</code>、 <code>datetime</code>、 <code>time</code>、 <code>timestamp</code>和<code>year</code></p><ul><li><p>date：表示的日期值，格式yyyy-mm-dd范围1000-01-01 到9999-12-31，3字节</p></li><li><p>time：表示的时间值，格式hhmm:ss，范围-838:59:59到838:59:59，3字节</p></li><li><p>datetime: 表示的日期时间值，格式yyyy-mm-ddhh:mm:ss，范围1000-01-0100:00:00到9999-12-3123:59:59 8字节，跟时区无关</p></li><li><p>timestamp: 表示的时间值，格式为yyyymmddhhmmss，范围1970-01-01 00:00:01到2038-01-19 03:14:07，4字节，跟时区有关</p></li><li><p>year: 年份值，格式为yyyy。 范围1901到2155，1字节</p></li></ul><p>推荐优先使用datetime类型来保存日期和时间， 因为存储范围更大， 且跟时区无关。</p><h3 id="十、冷热分离"><a href="#十、冷热分离" class="headerlink" title="十、冷热分离"></a>十、冷热分离</h3><p>对于一些历史归档数据，如過期的订单、日志等，可以定期从主表中移出，存入单独的历史表。历史表可以采用分区、分表等技术，并适当降低其维护成本。冷热数据分离不仅可以控制主表的数据量，还能提高线上查询的效率。冷热表还可根据各自的特点来设置不同的存储介质、备份策略等。</p><h3 id="十一、注释要完善"><a href="#十一、注释要完善" class="headerlink" title="十一、注释要完善"></a>十一、注释要完善</h3><p>表和字段都要添加清晰、准确的注释说明,这是软件工程的基本要求。注释要用通俗易懂的语言描述其业务含义，避免使用拼音、拼音首字母缩写等。如果某个字段存在枚举值，一定要将每个值所代表的含义都列出来。注释要与时俱进，代码有改动时要同步更新注释，否则就是无效注释。完善的注释是保证系统可维护性的重要一环。</p><h3 id="十二、优先考虑逻辑删除，而不是物理删除"><a href="#十二、优先考虑逻辑删除，而不是物理删除" class="headerlink" title="十二、优先考虑逻辑删除，而不是物理删除"></a>十二、优先考虑逻辑删除，而不是物理删除</h3><p>物理删除：把数据从硬盘中删除， 可释放存储空间<br>逻辑删除：给数据添加一个字段，比如<code>is_deleted</code> 以标记该数据已经逻辑删除。</p><p>为什么推荐用逻辑删除， 不推荐物理删除呢？<br>数据恢复困难，物理删除会导致索引树重构 。</p><h3 id="十三、每个都需要添加通用字"><a href="#十三、每个都需要添加通用字" class="headerlink" title="十三、每个都需要添加通用字"></a>十三、每个都需要添加通用字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id: 主键，一个表必须得有主键</span><br><span class="line">...</span><br><span class="line">remark：数据记录备注</span><br><span class="line">creator：创建人</span><br><span class="line">updator：修改人</span><br><span class="line">create_time：创建时间</span><br><span class="line">update_time：修改时间，必须，夏更新记录时，需要更新</span><br></pre></td></tr></table></figure><blockquote><p><strong>SQL编写的一些优化经验：</strong></p><ul><li>避免使用SELECT*FROM语句，应该只选择需要的列，以减少网络传输和提高查询性能</li><li>使用索引来提高查询速度，特别是在对大型表进行查询时</li><li>避免使用外键约束，因为它们可能会导致性能问题，特别是在对大型表进行插入、 更新和删除操作时</li><li>使用LIMIT1来限制查询结果只有一条记录</li><li>避免在where子句中使用OR采连接条件，应使用UNION来连接查询</li><li>注意优化LIMIT深分页问题，可以使用OFFSET来替代LIMIT</li><li>使用where条件限制要查询的数据，避免返回多余的行</li><li>尽量避免在索引列上使用MySQL的内置函数，这可能导致索引失效</li><li>应尽量避免在where子句中对字段进行表达式操作，这可能导致索引失效</li><li>应尽量避免在where子句中使用！=或&lt;&gt;操作符，这可能导致索引失效</li><li>使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则</li></ul></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1795596115622932537&wfr=spider&for=pc">优雅永不过时：数据库表设计的12个关键点</a></p><p><a href="https://www.bilibili.com/read/cv30824561/?jump_opus=1">mysql数据库表如何设计？</a></p><p><a href="https://blog.csdn.net/qq_44879989/article/details/130772295">存储之道：MySQL 中的字符串数据类型之 CHAR 与 VARCHAR</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之Modifier</title>
      <link href="/2024/05/23/Java%E4%B9%8BModifier/"/>
      <url>/2024/05/23/Java%E4%B9%8BModifier/</url>
      
        <content type="html"><![CDATA[<h1 id="修饰器-Modifier"><a href="#修饰器-Modifier" class="headerlink" title="修饰器 Modifier"></a>修饰器 Modifier</h1><p>Java 中常见的修饰器：public、private、protected、static、final、…等等。</p><p>Java中的属性、方法、构造器、内部类等等都需要使用修饰器进行修饰，所以通过反射可以获取对应的Field对象、Method对象、等等。</p><p>Modifier的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory.GetReflectionFactoryAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Modifier</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PUBLIC</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PRIVATE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROTECTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STATIC</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FINAL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNCHRONIZED</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOLATILE</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSIENT</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NATIVE</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERFACE</span> <span class="operator">=</span> <span class="number">512</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ABSTRACT</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STRICT</span> <span class="operator">=</span> <span class="number">2048</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BRIDGE</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VARARGS</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SYNTHETIC</span> <span class="operator">=</span> <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ANNOTATION</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ENUM</span> <span class="operator">=</span> <span class="number">16384</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MANDATED</span> <span class="operator">=</span> <span class="number">32768</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CLASS_MODIFIERS</span> <span class="operator">=</span> <span class="number">3103</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERFACE_MODIFIERS</span> <span class="operator">=</span> <span class="number">3087</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTRUCTOR_MODIFIERS</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">METHOD_MODIFIERS</span> <span class="operator">=</span> <span class="number">3391</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FIELD_MODIFIERS</span> <span class="operator">=</span> <span class="number">223</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PARAMETER_MODIFIERS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ACCESS_MODIFIERS</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Modifier</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPublic</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrivate</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">2</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isProtected</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">4</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isStatic</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">8</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isFinal</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">16</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSynchronized</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">32</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVolatile</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">64</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isTransient</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">128</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNative</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">256</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterface</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">512</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAbstract</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">1024</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isStrict</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">2048</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSynthetic</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="number">4096</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMandated</span><span class="params">(<span class="type">int</span> var0)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (var0 &amp; <span class="string">&#x27;耀&#x27;</span>) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">classModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3103</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">interfaceModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3087</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">constructorModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">methodModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3391</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fieldModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">223</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parameterModifiers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，修饰器中的针对公共常量的处理采用了二进制枚举的思想。</p><p>Java实例中的属性或者方法的修饰器都由JVM控制，在其对应的Field对象、Method对象、Constructor对象等等，其内部都维护了一个<code>private int modifiers;</code>属性值，用于记录修饰器的类型。</p><p>根据二进制枚举的思想，将所有的修饰器的值都累加到<code>modifiers</code>属性值上，判断是否包含某种修饰器时，也是通过位运算实现，效率极高。</p><blockquote><p>二进制枚举请见博文：<a href="/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE">二进制枚举/位枚举</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 修饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之static属性的自动注入</title>
      <link href="/2024/05/23/Spring%E4%B9%8Bstatic%E5%B1%9E%E6%80%A7%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/05/23/Spring%E4%B9%8Bstatic%E5%B1%9E%E6%80%A7%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring之static属性的自动注入"><a href="#Spring之static属性的自动注入" class="headerlink" title="Spring之static属性的自动注入"></a>Spring之static属性的自动注入</h1><blockquote><p>结论：Spring不支持static属性的自动注入！</p></blockquote><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><h3 id="静态属性和非静态属性的区别："><a href="#静态属性和非静态属性的区别：" class="headerlink" title="静态属性和非静态属性的区别："></a>静态属性和非静态属性的区别：</h3><p>1、在内存中存放位置不同  所有带static修饰符的属性或者方法都存放在内存中的方法区 而非静态属性存放在内存中的堆区<br>2、出现时机不同  静态属性或方法在没创建对象之前就已经存在 而非静态属性在创建对象之后才存在<br>3、静态属性是在某个类中的所有对象是共享的<br>4、生命周期不同 静态属性在类消失之后才销毁 而非静态属性在对象销毁之后就销毁</p><h3 id="静态属性在内存中的分布图"><a href="#静态属性在内存中的分布图" class="headerlink" title="静态属性在内存中的分布图"></a>静态属性在内存中的分布图</h3><p><img src="795484-20180401170355025-1926457359.png" alt="img"></p><h2 id="Spring依赖注入源码"><a href="#Spring依赖注入源码" class="headerlink" title="Spring依赖注入源码"></a>Spring依赖注入源码</h2><p>Spring在创建一个bean的时候，还要去填充bean的属性，大致流程如下：</p><ol><li>反射创建bean      // createBeanInstance</li><li>填充bean            // populateBean</li><li>初始化bean        // initializeBean（包括前、后置增强）</li><li>注册bean的销毁方法     // registerDisposableBeanIfNecessary</li></ol><p>自动注入逻辑在<code>populateBean</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">        <span class="comment">// 自动注入</span></span><br><span class="line">        <span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          <span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">            applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>而除了applyPropertyValues可以填充bean的属性外，更多的填充逻辑（自动注入）是在<code>InstantiationAwareBeanPostProcessor</code>中的<code>postProcessProperties</code>里面，字段注入就是常用的<code>@Autowired</code>、<code>@Resource</code>注解。</p><p><code>InstantiationAwareBeanPostProcessor</code>是一个接口，它的子类中实现<code>@Autowired</code>注入的是<code>AutowiredAnnotationBeanPostProcessor</code>，实现<code>@Resource</code>注入的是<code>CommonAnnotationBeanPostProcessor</code>。</p><p>接下来分析一下<code>AutowiredAnnotationBeanPostProcessor</code>是怎么进行字段注入的。流程就是先找到需要通过<code>findAutowiringMetadata</code>找到需要Autowired的元数据（字段、方法） ，然后再inject。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">   <span class="comment">// 寻找待注入的元数据</span></span><br><span class="line"><span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 自动注入</span></span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找bean对象中被@Autowired注解修饰并等待注入的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> &#123;</span><br><span class="line">  <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">  <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">  <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">  <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">      metadata = <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">      <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">          metadata.clear(pvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构建被@Autowired修饰并待注入的元数据</span></span><br><span class="line">        metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">        <span class="built_in">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的地方来了，接下来会 <strong>判断这个字段是不是static的，如果是，那么会发出日志提醒，并且直接返回，不进行注入了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, <span class="built_in">this</span>.autowiredAnnotationTypes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> InjectionMetadata.EMPTY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 属性处理</span></span><br><span class="line">    ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">      <span class="comment">// 查询@Autowired注解</span></span><br><span class="line">      MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断属性的修饰器，如果为static，跳过，不进行注入</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">        currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredFieldElement</span>(field, required));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法处理</span></span><br><span class="line">    ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">      <span class="type">Method</span> <span class="variable">bridgedMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">      <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 查询@Autowired注解</span></span><br><span class="line">      MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">      <span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">        <span class="comment">// 判断方法的修饰器，如果为static，跳过，不进行注入</span></span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">                        method);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">        <span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">        currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredMethodElement</span>(method, required, pd));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">    <span class="comment">// 获取父类，嵌套处理</span></span><br><span class="line">    targetClass = targetClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (targetClass != <span class="literal">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动Spring容器的时候，console管理台会打印出相关日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2024-05-23 10:44:10.552  INFO 76746 --- [main] f.a.AutowiredAnnotationBeanPostProcessor : Autowired annotation is not supported on static fields: private static com.example.demo.DemoService com.example.demo.SpringContextUtils.demoService</span><br></pre></td></tr></table></figure><p>总的来说，就一句话，<strong>spring在使用自动注入对静态属性进行注入时，会忽略掉这个属性，不去注入</strong>，也就是说Spring是有能力去注入静态字段的，但是Spring没有选择注入，为什么呢？</p><p>可能是因为Spring的设计理念是管理bean对象，只有属于对象的属性Spring才去进行管理，如果是static的话，那么这个属性就是属于类了，这个时候Spring去进行管理貌似不符合它的设计理念，所以Spring直接忽略掉了；另外如果一个bean修改了这个属性值，那么所有bean的这个属性值都会受到影响，因为这个属性是属于类的，这个时候可能就会问题。</p><p>那么有没有办法实现静态字段注入呢？</p><p>可以的，常见的有以下几种方式：</p><h3 id="方式一：将-Autowired加到构造方法上"><a href="#方式一：将-Autowired加到构造方法上" class="headerlink" title="方式一：将@Autowired加到构造方法上"></a>方式一：将@Autowired加到构造方法上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">    Test.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    userService.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：用-PostConstruct注解"><a href="#方式二：用-PostConstruct注解" class="headerlink" title="方式二：用@PostConstruct注解"></a>方式二：用@PostConstruct注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService2;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeInit</span><span class="params">()</span> &#123;</span><br><span class="line">    userService = userService2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    userService.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三：手动注入ApplicationContext"><a href="#方式三：手动注入ApplicationContext" class="headerlink" title="方式三：手动注入ApplicationContext"></a>方式三：手动注入ApplicationContext</h3><p>ApplicationContextAware接口能够轻松感知并在Spring中获取应用上下文，进而访问容器中的其他Bean和资源，这增强了组件间的解耦，了代码的灵活性和可扩展性，是Spring框架中实现高级功能的关键接口之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Spring应用上下文  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当Spring容器创建该类的实例时，会自动调用此方法，注入应用上下文  </span></span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">    SpringContextUtil.applicationContext = context;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个静态方法，返回应用上下文  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getApplicationContext</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> applicationContext;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个获取Bean的静态方法  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; beanClass)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (applicationContext != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> applicationContext.getBean(beanClass);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;ApplicationContext is not initialized yet!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过SpringContextUtil获取userService实例  </span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> SpringContextUtil.getBean(UserService.class);</span><br><span class="line">    userService.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式四：在方法上使用-Autowired注解，在方法里面去对静态字段进行赋值"><a href="#方式四：在方法上使用-Autowired注解，在方法里面去对静态字段进行赋值" class="headerlink" title="方式四：在方法上使用@Autowired注解，在方法里面去对静态字段进行赋值"></a>方式四：在方法上使用@Autowired注解，在方法里面去对静态字段进行赋值</h3><blockquote><p>注意：这个方法也不能是静态的，否则也会被spring会忽略掉。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService2)</span> &#123;</span><br><span class="line">    Test.userService = userService2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>参考文档：</strong></p><p><a href="https://www.cnblogs.com/nianzhilian/p/8687277.html">静态属性和静态方法 </a></p><p><a href="https://blog.csdn.net/2301_79456272/article/details/136207116">为什么不支持static字段的注入？</a></p><p><a href="https://blog.csdn.net/u011974797/article/details/89704358">Spring Boot中静态方法获取bean的三种方式</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之ApplicationContextAware</title>
      <link href="/2024/05/23/Spring%E4%B9%8BApplicationContextAware/"/>
      <url>/2024/05/23/Spring%E4%B9%8BApplicationContextAware/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring之ApplicationContextAware"><a href="#Spring之ApplicationContextAware" class="headerlink" title="Spring之ApplicationContextAware"></a>Spring之ApplicationContextAware</h1><h3 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h3><p><code>ApplicationContextAware</code>接口能够轻松感知并在Spring中获取应用上下文，进而访问容器中的其他Bean和资源，这增强了组件间的解耦，增加了代码的灵活性和可扩展性，是Spring框架中实现高级功能的关键接口之一。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><code>ApplicationContextAware</code>是Spring框架提供的一个特殊的回调接口，用于帮助对象（特别是普通的Java Bean）访问到Spring的应用上下文<code>ApplicationContext</code>。</p><p>当在自己的类中实现<code>ApplicationContextAware</code>接口时，可以通过Spring提供的回调机制访问到Spring的应用上下文，从而获得Spring IoC容器中的bean实例、配置信息以及进行国际化操作、事件发布等操作。</p><p>在<code>ApplicationContextAware</code>接口中定义了一个<code>setApplicationContext</code>方法，当类实现了该接口之后，Spring IoC容器会自动调用该方法并将当前的<code>ApplicationContext</code>注入到所实现的<code>setApplicationContext</code>方法中，这样就可以在该类中使用Spring的应用上下文了。</p><p>在一些开源的Spring工具库中会看到这种技术的使用，因为这些库往往需要与Spring容器交互，比如读取容器的配置，访问其他的bean等等，通过实现<code>ApplicationContextAware</code>接口就可以非常方便地完成这些工作。</p><blockquote><p>但注意，一般不推荐在的业务代码中使用，因为这样会增加代码与Spring的耦合性，违反了“依赖于抽象，而非依赖于具体实现”的面向对象设计原则。业务代码应当尽可能减少对具体框架的依赖，以提高代码的通用性和可移植性。</p></blockquote><h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><p>下面是一个简单的代码案例，展示了如何使用<code>ApplicationContextAware</code>接口来创建一个能够访问Spring应用上下文的类，如下代码：</p><p>首先，创建一个实现<code>ApplicationContextAware</code>接口的类：</p><blockquote><p>设计到Spring对static属性的注入问题，请见博文：<a href="/2024/05/23/Spring%E4%B9%8Bstatic%E5%B1%9E%E6%80%A7%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5/">Spring之static属性的自动注入</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringContextUtil</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Spring应用上下文  </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当Spring容器创建该类的实例时，会自动调用此方法，注入应用上下文  </span></span><br><span class="line">  <span class="meta">@Override</span>  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException &#123;  </span><br><span class="line">    SpringContextUtil.applicationContext = context;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个静态方法，返回应用上下文  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getApplicationContext</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> applicationContext;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个获取Bean的静态方法  </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; beanClass)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (applicationContext != <span class="literal">null</span>) &#123;  </span><br><span class="line">      <span class="keyword">return</span> applicationContext.getBean(beanClass);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;ApplicationContext is not initialized yet!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，定义一个简单的服务类作为Spring Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoService</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello from DemoService!&quot;</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端代码中，我们可以通过<code>SpringContextUtil</code>类来获取<code>DemoService</code>的实例并调用其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationClient</span> &#123;  </span><br><span class="line">  <span class="comment">// 通过SpringContextUtil获取DemoService实例  </span></span><br><span class="line">  <span class="type">DemoService</span> <span class="variable">demoService</span> <span class="operator">=</span> SpringContextUtil.getBean(DemoService.class);  </span><br><span class="line">  <span class="comment">// 调用DemoService的sayHello方法  </span></span><br><span class="line">  System.out.println(demoService.sayHello());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码展示了如何通过<code>SpringContextUtil</code>访问Spring的应用上下文，并获取其中的一个bean（<code>DemoService</code>）。</p><p><code>ApplicationClient</code>类是客户端代码的入口点，它初始化了一个<code>AnnotationConfigApplicationContext</code>，通过它Spring可以创建和管理beans，随后客户端代码使用<code>SpringContextUtil.getBean</code>静态方法来获取<code>DemoService</code>的实例，并调用它的<code>sayHello</code>方法。</p><h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><p><code>ApplicationContextAware</code>接口是Spring框架中用于让Bean感知到Spring应用上下文<code>ApplicationContext</code>的存在的一个标记接口。</p><p>当Spring容器创建一个实现了<code>ApplicationContextAware</code>接口的Bean时，它会自动调用该Bean的<code>setApplicationContext</code>方法，并将当前的<code>ApplicationContext</code>作为参数传入，这使得Bean能够访问到Spring容器的上下文，进而可以获取容器中的其他Bean、资源、配置信息等。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><strong>标记接口</strong>: <code>ApplicationContextAware</code>接口本身并没有定义任何具体的业务逻辑，它只是一个标记接口，用于告诉Spring容器这个Bean需要特殊处理。</li><li><strong>容器回调</strong>: 当Spring容器初始化一个Bean时，如果这个Bean实现了<code>ApplicationContextAware</code>接口，Spring容器会调用该Bean的<code>setApplicationContext</code>方法，并将当前的<code>ApplicationContext</code>对象作为参数传入。</li><li><strong>内部状态保存</strong>: 实现<code>ApplicationContextAware</code>接口的Bean通常会在其内部保存这个传入的<code>ApplicationContext</code>引用，以便后续使用。</li><li><strong>使用上下文</strong>: 一旦Bean保存了<code>ApplicationContext</code>的引用，它就可以使用这个上下文来访问容器中的其他Bean，或者获取容器的其他服务。</li></ol><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li><strong>Bean创建</strong>: 当Spring容器根据配置信息创建一个Bean实例时，它会检查这个Bean是否实现了任何<code>Aware</code>接口（包括<code>ApplicationContextAware</code>）。</li><li><strong>Aware接口处理</strong>: 如果Bean实现了<code>Aware</code>接口，Spring容器会调用相应的<code>set*</code>方法，注入相应的依赖，对于<code>ApplicationContextAware</code>，容器会调用<code>setApplicationContext</code>方法。</li><li><strong>依赖注入</strong>: 在调用<code>setApplicationContext</code>方法时，Spring容器会将当前的<code>ApplicationContext</code>对象注入到Bean中，这个注入过程是通过Java反射机制实现的。</li><li><strong>使用ApplicationContext</strong>: 一旦Bean被初始化并注入了<code>ApplicationContext</code>，它就可以使用这个上下文来执行各种操作，比如获取其他Bean、访问资源、读取配置等。</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><code>ApplicationContextAware</code>接口允许开发者在Bean中轻松获取到应用上下文<code>ApplicationContext</code>，这使得Bean能够灵活地访问Spring容器中的其他Bean和资源，增强了组件间的解耦和可扩展性。但是，过度使用<code>ApplicationContextAware</code>可能导致代码与Spring容器紧密耦合，降低了代码的可移植性和可测试性。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1792933358078512908&wfr=spider&for=pc">Spring揭秘：ApplicationContextAware应用场景及实现原理</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ApplicationContextAware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-索引表设计</title>
      <link href="/2024/05/07/%E7%B4%A2%E5%BC%95%E8%A1%A8%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/05/07/%E7%B4%A2%E5%BC%95%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库-索引表设计"><a href="#数据库-索引表设计" class="headerlink" title="数据库-索引表设计"></a>数据库-索引表设计</h1><h2 id="索引表模式"><a href="#索引表模式" class="headerlink" title="索引表模式"></a>索引表模式</h2><p>基于数据存储中经常由查询引用的字段创建索引。 此模式可让应用程序更快地找到要从数据存储中检索的数据，从而提高了查询性能。</p><h2 id="上下文和问题"><a href="#上下文和问题" class="headerlink" title="上下文和问题"></a>上下文和问题</h2><p>许多数据存储使用主键组织实体集合的数据。 应用程序可以使用此键来查找和检索数据。 下图显示了一个保存客户信息的数据存储示例。 主键为“客户 ID”。 该图显示按主键（“客户 ID”）组织的客户信息。</p><p><img src="index-table-figure-1.png" alt="图 1 - 按主键（“客户 ID”）组织的客户信息。"></p><p>尽管主键对于基于此键值提取数据的查询很有作用，但如果应用程序需要基于其他某个字段检索数据，则可能无法使用主键。 在客户示例中，如果应用程序只是通过引用其他某个属性（例如，客户所在的城镇）的值查询数据，则无法使用“客户 ID”主键来检索客户。 若要执行此类查询，应用程序可能需要提取并检查每条客户记录，而这是一个缓慢的过程。</p><p>许多关系数据库管理系统支持辅助索引。 辅助索引是按一个或多个非主键（辅助键）字段组织的独立数据结构，指示每个索引值的数据的存储位置。 辅助索引中的项通常已按辅助键的值排序，以便快速查找数据。 这些索引通常由数据库管理系统自动维护。</p><p>可以根据需要创建任意数目的辅助索引来支持应用程序执行的不同查询。 例如，在关系数据库中“客户 ID”是主键的“客户”表中，如果应用程序经常根据客户所在的城镇查找客户，则基于城镇字段添加一个辅助索引会很有作用。</p><p>尽管辅助索引在关系数据库系统中很常见，但云应用程序使用的部分 NoSQL 数据存储并不提供等效的功能。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如果数据存储不支持辅助索引，你可以通过创建自己的索引表来手动模拟辅助索引。 索引表按指定的键组织数据。 根据所需的辅助索引数目以及应用程序执行的查询性质，我们通常可以使用三种策略来构建索引表。</p><p>第一种策略是复制每个索引表中的数据，但按不同的键（完全非规范化）组织这些数据。 下图显示了按“城镇”和“姓氏”组织相同客户信息的索引表。</p><blockquote><p>规范化：关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件，其中最基本的一条就是，关系的每一个分量必须是一个不可分割的数据项，也就是说，不允许表中有表。<br>ps：这个事实表已然是非规范化的，用户信息分量中包含了太多维度的信息了，是一个可分割的数据项。</p></blockquote><p><img src="index-table-figure-2.png" alt="图 2 - 已复制每个索引表中的数据"></p><p>如果相对于使用每个键查询数据的次数而言数据较为静态，则此策略适用。 如果数据较为动态，则维护每个索引表所产生的处理开销会变得过大，因此，此方法并不有效。 此外，如果数据量极大，存储重复数据所需的空间量也很大。</p><p>第二种策略是创建按不同键组织的规范化索引表，并使用主键来引用原始数据，而不是复制数据，如下图所示。 原始数据称为事实数据表。</p><p><img src="index-table-figure-3.png" alt="图 3 - 数据由每个索引表引用"></p><p>此方法可节省空间，并减少维护重复数据所产生的开销。 其缺点在于，应用程序必须使用辅助键执行两项查找操作才能找到数据。 应用程序必须在索引表中查找数据的主键，然后使用主键来查找事实数据表中的数据。</p><p>第三种策略是创建按不同键组织的、可复制经常检索的字段的部分规范化索引表。 引用事实数据表即可访问不经常访问的字段。 下图显示了如何在每个索引表中复制经常访问的数据。</p><p><img src="index-table-figure-4.png" alt="图 4 - 在每个索引表中复制经常访问的数据。"></p><p>如果使用此策略，可以在前两种方法之间取得平衡。 可以使用单个查找操作快速检索用于常见查询的数据，同时，空间和维护开销不如复制整个数据集那么大。</p><p>如果应用程序经常通过指定值的组合（例如，“查找居住在 Redmond，且姓氏为 Smith 的所有客户”）查询数据，则你可以针对索引表中的项实现“城镇”属性与“姓氏”属性串联形式的键。 下图显示了基于组合键的索引表。 这些键先按“城镇”排序，然后，针对具有相同“城镇”值的记录按“姓氏”排序。</p><p><img src="index-table-figure-5.png" alt="图 5 - 基于组合键的索引表"></p><p>索引表可以加速分片数据的查询操作，当分片键已经过哈希处理时特别有用。 下图显示了将“客户 ID”哈希用作分片键的示例。 索引表可按未经哈希处理的值（“城镇”和“姓氏”）组织数据，并提供经过哈希处理的分片键作为查找数据。 这样，在应用程序需要检索处于某个范围内的数据，或者需要根据未经哈希处理的键的顺序提取数据时，就无需反复计算哈希键（此操作的开销较高）。 例如，通过在索引表中找到匹配项（所有项存储在相邻的块中），可以快速解决类似于“查找居住在 Redmond 的所有客户”的查询。 然后，可以使用索引表中存储的分片键，遵循对客户数据的引用进行操作。</p><p><img src="index-table-figure-6.png" alt="图 6 - 提供快速分片数据查找的索引表"></p><h2 id="问题和注意事项"><a href="#问题和注意事项" class="headerlink" title="问题和注意事项"></a>问题和注意事项</h2><p>在决定如何实现此模式时，请考虑以下几点：</p><ul><li>维护辅助索引所产生的开销可能很大。 必须分析并了解应用程序使用的查询。 仅当应用程序定期使用索引表时，才创建索引表。 不要创建推理索引表来支持应用程序不会执行或只是偶尔执行的查询。</li><li>复制索引表中的数据可能会明显增大存储成本方面的开销，以及维护多个数据副本所需的工作量。</li><li>将索引表实现为引用原始数据的规范化结构需要应用程序执行两项查找操作才能找到数据。 第一项操作搜索索引表以检索主键，第二项操作使用主键提取数据。</li><li>如果系统基于极大型数据集整合了许多索引表，则可能很难维持索引表与原始数据之间的一致性。 也许可以围绕最终一致性模型设计应用程序。 例如，若要插入、更新或删除数据，应用程序可以向队列发布一条消息，让单独的任务执行该操作，并维护以异步方式引用此数据的索引表。 有关实施最终一致性的详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/previous-versions/msp-n-p/dn589800(v=pandp.10)">数据一致性入门</a>。</li><li>索引表本身可能已分区或分片。</li></ul><h2 id="何时使用此模式"><a href="#何时使用此模式" class="headerlink" title="何时使用此模式"></a>何时使用此模式</h2><p>如果应用程序经常需要使用除主键（或分片键）以外的某个键检索数据，则使用此模式可提高查询性能。</p><p>在以下情况下，此模式可能不起作用：</p><ul><li>数据是易失性的。 索引表可能很快过时，因此变得低效，或者维护索引表所产生的开销超过了它所带来的成本节省。</li><li>选作索引表辅助键的字段没有辨别性，可能只包含少量的值（例如性别）。</li><li>选作索引表辅助键的字段的数据值平衡性极度偏斜。 例如，如果 90% 的记录包含某个字段中的相同值，那么，基于此字段创建并维护用于查找数据的索引表所产生的开销，可能比依序搜索整个数据更高。 但是，如果查询经常性地以剩余 10% 的记录中的值为目标，则此索引可能非常有用。 应该了解应用程序执行的查询以及执行这些查询的频率。</li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://learn.microsoft.com/zh-cn/azure/architecture/patterns/index-table">索引表模式</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析收单业务</title>
      <link href="/2024/04/25/%E6%B5%85%E6%9E%90%E6%94%B6%E5%8D%95%E4%B8%9A%E5%8A%A1/"/>
      <url>/2024/04/25/%E6%B5%85%E6%9E%90%E6%94%B6%E5%8D%95%E4%B8%9A%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>收单业务</p><p>在收单的结算流程中，很容易出现一种“单边账”的情况，单边账，即一方的账目发生变化，而另一方没有，那么随之而来的就是，钱，哪去了?<br>在此之前，先介绍两个概念，即长款和短款（只按照POSP系统的数据归纳概念）<br>长款：上游给我的款项比我给下游的多（在不考虑分润及跳码的情况下）<br>短款：上游给我的款项比我给下游的少（同上）</p><p>单边账有百分之九十九点九九是长款，如果出现了短款情况，就是灾难，建议彻查POSP系统日志，仔细排查上下游对账单，先说下长款和短款：<br>（1）支付长款：银行钱多了就是长款，即金额差错时，订单金额 &lt; 对账文件金额，或者单边帐订单无对账文件有。<br>（2）支付短款：银行少钱了就是短款，即金额差错时，订单金额 &gt; 对账文件金额，或者单边帐订单有对账文件无。</p><p>上面说了，其实长款和短款也要分两种情况，一是对账的时候订单和资金对账文件都有，<strong>金额差异造成长款和短款</strong>；二是对账的时候订单和资金对账文件一边有一边无，即所谓的<strong>单边帐造成的长短款</strong>。</p><p>第一种情况很少遇到，一般情况下支付联机时实际支付金额和联机银行回显金额不相等，订单就支付失败了，也不会拿去对资金账。如果联机时两边金额是相等的，而在T+1对账时对出金额差异，这一般就是银行的问题了。线下找银行去。</p><p>第二种情况，先说短款，T+1对账时，对出订单有对账文件无，一般不会立即出短款，而是先标记为“存疑”，因为有的银行会在T+2时提供对账文件。待T+2的对账文件来了，再把之前存疑的订单拿来对。万一到了设定了时间点，还是订单存疑的话，那么就要确认为短款了。（银行估计早就要来找你了）；再说长款，T+1对账时对出订单无支付文件有时，这会立即出长款的。这时候要进行补单的操作，所谓补单即通过支付流水关联全局的订单，关联到了，将订单的支付状态改为支付成功，更新银行回写时间等等。如果没关联到，确实没有订单，那么要线下找银行去处理了。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/qq827245563/article/details/78479361">银行卡收单对账长短款差错处理</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息触达</title>
      <link href="/2024/04/22/%E6%B6%88%E6%81%AF%E8%A7%A6%E8%BE%BE/"/>
      <url>/2024/04/22/%E6%B6%88%E6%81%AF%E8%A7%A6%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="消息触达"><a href="#消息触达" class="headerlink" title="消息触达"></a>消息触达</h1><p>消息触达是指在应用程序或系统中，将信息传递给用户或其他系统的过程。在云计算领域，消息触达通常涉及到事件通知、消息队列、实时通信等方面。</p><h3 id="消息触达的应用场景"><a href="#消息触达的应用场景" class="headerlink" title="消息触达的应用场景"></a>消息触达的应用场景</h3><p>消息触达在各种应用场景中都有广泛应用，例如：</p><ul><li>实时通信：在聊天应用、社交媒体、在线游戏等场景中，需要实时传递消息和通知。</li><li>事件驱动架构：在事件发生时，需要通知其他系统或服务。</li><li>数据处理：在大数据处理、机器学习等场景中，需要处理大量的实时消息和数据。</li></ul><h3 id="消息触达的优势"><a href="#消息触达的优势" class="headerlink" title="消息触达的优势"></a>消息触达的优势</h3><p>消息触达具有以下优势：</p><ul><li>异步通信：消息触达可以实现异步通信，降低系统之间的耦合度。</li><li>可扩展性：消息触达可以水平扩展，以满足大量用户和消息的需求。</li><li>容错性：消息触达可以保证消息的可靠传递，即使出现故障也不会影响整个系统。</li></ul><h3 id="消息触达的分类"><a href="#消息触达的分类" class="headerlink" title="消息触达的分类"></a>消息触达的分类</h3><p>消息触达可以分为以下几类：</p><ul><li>点对点消息：一对一的消息传递。</li><li>发布/订阅消息：一对多的消息传递。</li><li>消息队列：异步消息传递，可以保证消息的顺序和可靠传递。</li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://cloud.tencent.com.cn/developer/information/%E6%B6%88%E6%81%AF%E8%A7%A6%E8%BE%BE">消息触达</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息触达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令</title>
      <link href="/2024/04/18/Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/04/18/Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><p>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目<a href="https://baike.baidu.com/item/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/2511538?fromModule=lemma_inlink">版本管理</a>。</p><h2 id="Git仓库及命令执行的数据流图"><a href="#Git仓库及命令执行的数据流图" class="headerlink" title="Git仓库及命令执行的数据流图"></a>Git仓库及命令执行的数据流图</h2><img src="git1.png" style="zoom:70%;"><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><p>初始化一个Git仓库，在一个目录下执行该指令，表示将该目录初始化成一个Git本地工作区。</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add ."></a>git add .</h4><p>添加本地工作区下所有文件添加到到暂存区。</p><h4 id="git-commit-m-xxx"><a href="#git-commit-m-xxx" class="headerlink" title="git commit -m xxx"></a>git commit -m xxx</h4><p>将工作区的文件提交至本地仓库，并描述本次提交信息。</p><h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>从远程仓库获取最新版本数据到本地仓库，但不会自动merge到暂存区。最常见的场景如取回origin主机的master 分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure><p>取回更新后，会返回一个<code>FETCH_HEAD</code> ，指的是fetch的branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro passport % git log -p FETCH_HEAD</span><br><span class="line">commit 2a89dc68df05b8e538daaad5e63083fbcf20f685 (origin/master, origin/HEAD)</span><br><span class="line">Merge: f74c0c3 d6e16b5</span><br><span class="line">Author: scmgit &lt;scmgit@geely.com&gt;</span><br><span class="line">Date:   Tue May 26 11:11:58 2020 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;merge_20200522_145657&#x27; into &#x27;master&#x27;</span><br><span class="line">    </span><br><span class="line">    after release merge to maste</span><br><span class="line">    </span><br><span class="line">    See merge request j-farmer/passport!58</span><br><span class="line"></span><br><span class="line">commit d6e16b528e0bf80dd4c06619dc6f7160e2a65612</span><br><span class="line">Author: scmgit &lt;scmgit@geely.com&gt;</span><br><span class="line">Date:   Fri May 22 15:17:35 2020 +0800</span><br><span class="line"></span><br><span class="line">    scm_change_version</span><br><span class="line"></span><br><span class="line">diff --git a/api/pom.xml b/api/pom.xml</span><br><span class="line">index cf78d01..e9483a7 100644</span><br><span class="line">--- a/api/pom.xml</span><br><span class="line">+++ b/api/pom.xml</span><br><span class="line">@@ -5,7 +5,7 @@</span><br><span class="line">     &lt;parent&gt;</span><br><span class="line">         &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">         &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">-        &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+        &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">     &lt;/parent&gt;</span><br><span class="line">     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">diff --git a/pom.xml b/pom.xml</span><br><span class="line">index 7716b9c..b020af7 100644</span><br><span class="line">--- a/pom.xml</span><br><span class="line">+++ b/pom.xml</span><br><span class="line">@@ -3,7 +3,7 @@</span><br><span class="line">   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">   &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">-  &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+  &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">   &lt;modules&gt;</span><br><span class="line">     &lt;module&gt;start&lt;/module&gt;</span><br><span class="line">     &lt;module&gt;service&lt;/module&gt;</span><br><span class="line">diff --git a/service/pom.xml b/service/pom.xml</span><br><span class="line">index 96feaea..6af8f12 100644</span><br><span class="line">--- a/service/pom.xml</span><br><span class="line">+++ b/service/pom.xml</span><br><span class="line">@@ -4,7 +4,7 @@</span><br><span class="line">     &lt;parent&gt;</span><br><span class="line">         &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">         &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">-        &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+        &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">     &lt;/parent&gt;</span><br><span class="line">     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">diff --git a/start/pom.xml b/start/pom.xml</span><br><span class="line">index e704136..1fdccae 100644</span><br><span class="line">--- a/start/pom.xml</span><br><span class="line">+++ b/start/pom.xml</span><br><span class="line">@@ -5,7 +5,7 @@</span><br><span class="line">     &lt;parent&gt;</span><br><span class="line">         &lt;artifactId&gt;passport&lt;/artifactId&gt;</span><br><span class="line">         &lt;groupId&gt;com.caocao&lt;/groupId&gt;</span><br><span class="line">-        &lt;version&gt;1.6.0.0&lt;/version&gt;</span><br><span class="line">+        &lt;version&gt;1.6.1.2&lt;/version&gt;</span><br><span class="line">     &lt;/parent&gt;</span><br><span class="line">     &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"> </span><br><span class="line">diff --git a/test/pom.xml b/test/pom.xml</span><br></pre></td></tr></table></figure><p>可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 </p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>从远程仓库拉取内容到本地，该命令的作用相当于下面两个命令的组合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master // 从远程主机的master分支拉取最新内容 </span><br><span class="line">git merge FETCH_HEAD    // 将拉取下来的最新内容合并到当前所在的分支中</span><br></pre></td></tr></table></figure><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>查看当前仓库的状态，即对是否哪些文件进行了修改|删除|增加等操作；</p><h4 id="git-diff-fileName"><a href="#git-diff-fileName" class="headerlink" title="git diff [fileName]"></a>git diff [fileName]</h4><p>查看所有文件[目标文件]在仓库中修改的具体信息（如果是新创建文件则无法查看修改），在第一次提交之后才能查看修改；如果输出信息太多自动分页，按 <code>q</code> 退出；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git diff</span><br><span class="line">diff --git a/test.json b/test.json</span><br><span class="line">index 5171a05..31fd6a8 100644</span><br><span class="line">--- a/test.json</span><br><span class="line">+++ b/test.json</span><br><span class="line">@@ -1 +1,4 @@</span><br><span class="line">-&#123;&quot;name&quot;:&quot;Maple&quot;&#125;</span><br><span class="line">+&#123;</span><br><span class="line"></span><br><span class="line">+   &quot;name&quot;:&quot;Maple&quot;,</span><br><span class="line">+   &quot;age&quot;:27</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure><h4 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h4><p>查看从近到远的提交日志信息，包含提交时的commit描述信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git log</span><br><span class="line">commit 7620e300373622ed19d784e37bbbea82a48678a6 (HEAD -&gt; master)</span><br><span class="line">Author: maple8 &lt;790379323@qq.com&gt;</span><br><span class="line">Date:   Tue May 26 17:43:10 2020 +0800</span><br><span class="line"></span><br><span class="line">test1</span><br><span class="line"></span><br><span class="line">commit 74a85ad5cf670782f6df6a3f1a57cf7c0e42e41a</span><br><span class="line">Author: maple8 &lt;790379323@qq.com&gt;</span><br><span class="line">Date:   Tue May 26 17:37:53 2020 +0800</span><br><span class="line"></span><br><span class="line">test</span><br></pre></td></tr></table></figure><h4 id="git-log-–pretty-oneline"><a href="#git-log-–pretty-oneline" class="headerlink" title="git log –pretty=oneline"></a>git log –pretty=oneline</h4><p>仅显示一行提交的日志;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git log --pretty=oneline</span><br><span class="line">7620e300373622ed19d784e37bbbea82a48678a6 (HEAD -&gt; master) test1</span><br><span class="line">74a85ad5cf670782f6df6a3f1a57cf7c0e42e41a test</span><br></pre></td></tr></table></figure><p>其中: 7620e300373622ed19d784e37bbbea82a48678a6 称为提交版本号</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交7620e30…，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code>。</p><h4 id="git-reset-–hard-提交的版本号"><a href="#git-reset-–hard-提交的版本号" class="headerlink" title="git reset –hard [提交的版本号]"></a>git reset –hard [提交的版本号]</h4><p>版本回退到最新的一次提交（就是最近的一次提交），也可以通过指定版本号进行回退。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git reset --hard HEAD^</span><br><span class="line">HEAD is now at 74a85ad test</span><br></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当回退版本时，Git仅移动HEAD指针即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br><span class="line">改为指向add distributed：</span><br><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure><p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令。</p><h4 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h4><p>记录每一次提交的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git reflog</span><br><span class="line">74a85ad (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">7620e30 HEAD@&#123;1&#125;: commit: test1</span><br><span class="line">74a85ad (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): test</span><br></pre></td></tr></table></figure><p>从输出可知，append GPL的commit id是7620e30，现在，你又可以乘坐时光机回到未来了。回退到原始版本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git reset --hard 7620e30</span><br><span class="line">HEAD is now at 7620e30 test1</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><p>查看本地所有分支：<code>git branch</code></p></li><li><p>查看远程所有分支：<code>git branch -r</code></p></li><li><p>查看本地和远程的所有分支：<code>git branch -a</code> </p></li><li><p>创建本地分支：<code>git branch &lt;name&gt;</code></p></li><li><p>重命名本地分支：<code>git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;</code></p></li><li><p>切换分支：<code>git checkout &lt;name&gt; 或者 git switch &lt;name&gt;</code></p></li><li><p>创建 + 切换分支：<code>git checkout -b &lt;name&gt; 或者 git switch -c &lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>在merge的过程中可能会出现Conflict冲突，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">...</span><br><span class="line">当前分支上的内容</span><br><span class="line">=========</span><br><span class="line">...</span><br><span class="line">master分支合过来的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;master</span><br></pre></td></tr></table></figure></li><li><p>删除本地分支：<code>git branch -d &lt;name&gt;</code></p></li><li><p>删除远程分支：<code>git push origin --delete &lt;branchname&gt;</code> 或 <code>git branch -d -r &lt;branchname&gt;</code></p></li><li><p>本地分支推送至远程服务器：<code>git push origin &lt;branchname&gt;</code></p></li><li><p>查看远程仓库的信息 | 加上 -v 参数，查看更详细的信息：git remote<code>或</code>git remote -v`</p></li><li><p>新建本地分之并关联远程已存在的分支：<code>git checkout -b &lt;branchname&gt; origin/&lt;branchname&gt;</code></p></li></ul><h3 id="Git信息设置"><a href="#Git信息设置" class="headerlink" title="Git信息设置"></a>Git信息设置</h3><h4 id="设置git全局的名称和邮箱"><a href="#设置git全局的名称和邮箱" class="headerlink" title="设置git全局的名称和邮箱"></a>设置git全局的名称和邮箱</h4><p>查看当前应用git的提交名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>修改命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;新名称&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><h4 id="设置单个项目提交用户名和邮箱"><a href="#设置单个项目提交用户名和邮箱" class="headerlink" title="设置单个项目提交用户名和邮箱"></a>设置单个项目提交用户名和邮箱</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;新名称&quot;</span><br><span class="line">git config user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>之后可以打开当前项目的 <code>.git/config</code> 文件看配置生效如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">        name = 新名称</span><br><span class="line">        email = 邮箱地址</span><br></pre></td></tr></table></figure><h4 id="配置文件优先级及路径基本语法"><a href="#配置文件优先级及路径基本语法" class="headerlink" title="配置文件优先级及路径基本语法"></a>配置文件优先级及路径基本语法</h4><p>Git支持多级配置，分别是 <strong>system(系统级</strong>)、<strong>global（用户级）</strong>、<strong>local（项目级）</strong>和 <strong>worktree（工作区级）</strong><br>配置优先级： <strong><font color="green">worktree &gt; local &gt; global &gt; system</font></strong></p><ul><li><strong>system系统级（安装路径/etc/gitconfig）</strong>： 系统级配置文件，对系统中所有用户都普遍适用的配置。使用 <code>git config --system</code>读写的就是这个文件</li><li><strong>global用户级（C:/Users/用户名/.gitconfig）</strong>： 用户级配置文件，用户目录下的配置文件只适用于该用户。使用 <code>git config --global</code>读写的就是这个文件。</li><li><strong>local项目级（某仓库的本地路径/.git/config）</strong>： 项目级配置文件，当前项目的 git仓库目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）,这里的配置仅仅针对当前项目有效。使用 <code>git config [--local]</code>读写的就是这个文件。</li><li><strong>worktree工作区级</strong>： 工作区级配置，此配置仅仅针对当前工作区有效。使用 <code>git config --worktree</code>进行配置。</li></ul><p>每一个级别高的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。针对单个项目的配置同样会覆盖全局的配置。</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><hr><h3 id="Git-新建本地分支，且关联已存在的远程分支"><a href="#Git-新建本地分支，且关联已存在的远程分支" class="headerlink" title="Git 新建本地分支，且关联已存在的远程分支"></a>Git 新建本地分支，且关联已存在的远程分支</h3><ul><li><p>先在远程仓库点击 <code>New Branch</code> 新建一个远程分支</p></li><li><p>拉取远程的分支到本地暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure></li><li><p>新建本地分支并关联远程分支，只是建立了连接通道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;本地分支名&gt; &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li><li><p>拉取远程分支内容到本地分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Git-终端新建本地分支和远程分支，且关联起来"><a href="#Git-终端新建本地分支和远程分支，且关联起来" class="headerlink" title="Git 终端新建本地分支和远程分支，且关联起来"></a>Git 终端新建本地分支和远程分支，且关联起来</h3><ul><li>在本地新建分支并切换</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>将本地分支提交到远程仓库，此过程会在远程仓库中创建一个名为 <code>&lt;本地分支名&gt;</code>的远程分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><ul><li>本地分支与远程分支关联</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/远程分支名</span><br></pre></td></tr></table></figure><hr><h3 id="Git-创建本地仓库关联远程仓库"><a href="#Git-创建本地仓库关联远程仓库" class="headerlink" title="Git 创建本地仓库关联远程仓库"></a>Git 创建本地仓库关联远程仓库</h3><p>本地创建了一个project，并在码云上创建了一个同名仓库，将本地的仓库链接到远程仓库。如果本地分支已经关联了远程的分支，在使用本地分支关联其他远程分支的时候会出现以下异常:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists</span><br></pre></td></tr></table></figure><p>这种场景下需要先删除当前项目中本地连接已关联的远程分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><ul><li>step1: 初始化本地仓库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>step2: 添加远程仓库地址：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure><ul><li>step3: 拉取远程仓库内容到本地</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>可能会出现下面的异常信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro elastic-job % git pull origin master</span><br><span class="line">remote: Enumerating objects: 3, done.</span><br><span class="line">remote: Counting objects: 100% (3/3), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From https://gitee.com/maple_eitba/elastic-job</span><br><span class="line"></span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">   error: The following untracked working tree files would be overwritten by merge:</span><br><span class="line">        .gitignore</span><br><span class="line">   Please move or remove them before you merge.</span><br><span class="line">   Aborting</span><br></pre></td></tr></table></figure><p>这是由于在远程创建仓库的时候有一个<code>.gitignore</code>文件,而是用<code>git init</code>命名也会在本地生成一个<code>.gitignore</code> 文件，所以出现了冲突；解决方法就是看需要保留哪一份，把不需要的删除即可，一般都是删除掉远程仓库中的<code>.gitignore</code> 文件。当然了，如果在开发者确定远程仓库中的内容是没用的前提下可以直接使用强制推送，直接对远程仓库进行覆盖，并进行本地和远程分支master的关联(这种操作仅限自己的项目,不能对工作项目使用强制推送):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f --set-upstream origin master</span><br></pre></td></tr></table></figure><blockquote><p>这个强制覆盖的命令在团队开发的时候不要用，嘎嘎危险！！！</p></blockquote><ul><li>step4: 添加本地工作区的修改到暂存区</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><ul><li>step5: 将暂存区的信息提交到本地仓库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交的信息备注&quot;</span><br></pre></td></tr></table></figure><ul><li>step6: 推送本地仓库中的内容到远程仓库，并建立本地master分支和远程master分支的关联关系</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>or: 这个命令不好使，终端会提示需要使用<code>--set-upstream origin master</code>;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><hr><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li>丢弃暂存区的修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- fileName</span><br></pre></td></tr></table></figure><p><strong>Demo：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">maple@qixudongdeMacBook-Pro Test % git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   test.json</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">maple@qixudongdeMacBook-Pro Test % git checkout -- test.json </span><br><span class="line"></span><br><span class="line">maple@qixudongdeMacBook-Pro Test % git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">maple@qixudongdeMacBook-Pro Test % </span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- test.json</code>意思就是，把<code>test.json</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是<code>test.json</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>test.json</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</li></ul><p>总之，就是<strong>让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态</strong>。</p><blockquote><p>git checkout – file命令中的<code>--</code>很重要，没有<code>--</code>就变成了<code>切换到另一个分支</code>的命令。</p></blockquote><hr><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;fileName&gt;</span><br></pre></td></tr></table></figure><p>这个时候Git知道你删除了文件，因为工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>现在有两个选择:</p><p>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉版本库中的文件，并且<code>git commit</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> test.txt</span></span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span></span><br><span class="line">[master d46f35e] remove test.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 test.txt</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><blockquote><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><p> 命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p></blockquote><hr><h3 id="强制覆盖本地代码（与git远程仓库保持一致）"><a href="#强制覆盖本地代码（与git远程仓库保持一致）" class="headerlink" title="强制覆盖本地代码（与git远程仓库保持一致）"></a>强制覆盖本地代码（与git远程仓库保持一致）</h3><p>git强制覆盖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>git强制覆盖本地命令（单条版本）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master &amp;&amp; git pull</span><br></pre></td></tr></table></figure><p>解释:<br>第一个是：拉取远程仓库中的所有更新和不同步；<br>第二个是：本地代码同步线上最新版本(会覆盖本地所有与远程仓库上同名的文件)；<br>第三个是：再更新一次（其实也可以不用，第二步命令做过了其实）;</p><hr><h3 id="git存储"><a href="#git存储" class="headerlink" title="git存储"></a>git存储</h3><p><strong>Git Stash 命令的使用</strong></p><p>（1）<strong>git stash</strong> [save “save message”] : 执行存储时，添加备注，方便查找，只有<code>git stash</code>也是可以的，但查找时不方便识别。</p><p>（2）<strong>git stash list</strong> ：查看stash了哪些存储。</p><p>（3）<strong>git stash show</strong> ：显示做了哪些改动，默认show第一个存储，如果要显示其他存储，后面加<code>stash@&#123;$num&#125;</code>，如：第二个 <code>git stash show stash@&#123;1&#125;</code></p><p>（4）<strong>git stash show -p</strong> : 详细地显示第一个存储的改动，如果想显示其他存存储，命令：<code>git stash show stash@&#123;$num&#125; -p</code> ，</p><p>  比如第二个：<code>git stash show stash@&#123;1&#125; -p</code>。</p><p>（5）<strong>git stash apply</strong> : 应用某个存储，将存储的代码应用到当前分支代码中，但不会把存储从存储列表中删除，默认使用第一个存储，即<code>stash@&#123;0&#125;</code>，</p><p>​      如果要使用其他存储，使用<code>git stash apply stash@&#123;$num&#125;</code> ， 比如第二个：<code>git stash apply stash@&#123;1&#125;</code> 。</p><p>（6）<strong>git stash pop</strong> ：恢复存储，将对应修改应用到当前代码, 并将缓存堆栈中的stash删除, 默认为第一个stash，即<code>stash@&#123;0&#125;</code>，如果要应用并删除其他stash，</p><p>​     命令：<code>git stash pop stash@&#123;$num&#125;</code> ，比如：应用并删除第二个：<code>git stash pop stash@&#123;1&#125;</code>。</p><p>（7）<strong>git stash drop</strong> stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储。</p><p>（8）<strong>git stash branch <name></name></strong> ：根据最近的 stash 创建一个新的分支.</p><p>（9）<strong>git stash clear</strong> ：删除所有缓存的stash。</p><h3 id="Git-终端新建本地分支和远程分支，且关联起来-1"><a href="#Git-终端新建本地分支和远程分支，且关联起来-1" class="headerlink" title="Git 终端新建本地分支和远程分支，且关联起来"></a>Git 终端新建本地分支和远程分支，且关联起来</h3>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白话DDD入门</title>
      <link href="/2024/04/09/%E7%99%BD%E8%AF%9DDDD%E5%85%A5%E9%97%A8/"/>
      <url>/2024/04/09/%E7%99%BD%E8%AF%9DDDD%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>白话DDD入门</p><h3 id="一个维护中的业务系统引出的思考"><a href="#一个维护中的业务系统引出的思考" class="headerlink" title="一个维护中的业务系统引出的思考"></a>一个维护中的业务系统引出的思考</h3><p>这几年维护的一个带货类的项目，这个项目用了最传统的三层模型来搭建，大概是如下的模型：</p><img src="640.jpeg" alt="img" style="zoom:40%;"><p>当这个项目维护几年之后，逐渐出些了一些有意思的情况，如下：</p><p><strong>情况 1（代码层面）：</strong>少部分代码可读性在长期不同人员的修改下变得越来越差。如：某个带货的核心 rpc 逻辑没有任何嵌套，平铺在一个函数里，单函数代码行数达到几百行，可读性和维护性极差，成功化身为“技术护城河”。</p><p><strong>情况 2（微服务层面）：</strong> 某些微服务初始职能划分较为简单，导致少量模块在后续快速的迭代中迅速膨胀。如：其中的 mp 模块，原本职能是用来承接 B 端门户的功能，当我们决定拆分这个庞大的模块时，这个模块已经承载了 204 个 rpc。过多的能力承担让它编译变慢、变成链路单点、改动较多、一旦出现问题影响较大。</p><p><strong>情况 3（业务团队层面）：</strong>带货项目会使用一些其他业务系统的接口和数据结构，当这些业务系统想要修改这些接口和数据结构的时候 ，偶尔可能没有察觉这里的依赖导致线上问题， 或者沟通过来发现耦合处比较多不容易改动。</p><p>对这个项目的维护引出了一些思考，在一个复杂业务系统中：代码结构要如何设计、微服务的横/纵向职能要如何划分、业务团队之间如何交互，才能持续在长期快速、多人协作的迭代中保证系统可维护性、拓展性、高内聚低耦合和稳定性。</p><p>而传统的开发模式不管是<strong>面向过程（POP）</strong>还是<strong>面向对象（OOP）</strong>的思维，都没办法从微服务层面指导我们找到这些问题的答案。这时想到了领域驱动设计（DDD）。</p><h3 id="DDD-的分层架构"><a href="#DDD-的分层架构" class="headerlink" title="DDD 的分层架构"></a><strong>DDD 的分层架构</strong></h3><p>DDD 最有标志性的一点，就是将传统软件设计三层模型转化为了四层模型，这个转化如下图所示：</p><img src="640-20240409112814048.jpeg" alt="img" style="zoom:50%;"><p>乍看之下，四层架构引入了很多概念，如：领域服务、领域对象、 DTO、仓储等等。我们先不用在意这些细节概念，先关注这几个关键的层：<strong>用户界面层、应用层、领域层、基础设施层</strong>。我们来看下他们的职能分工：</p><ul><li>用户界面层：网络协议的转化/统一鉴权/Session 管理/限流配置/前置缓存/异常转换</li><li>应用层：<strong>业务流程编排（仅编排，不能存在业务逻辑）</strong>/ DTO 出入转化</li><li>领域层：领域模型/领域服务/仓储和防腐层的接口定义</li><li>基础设施层：仓储和防腐层接口实现/存储等基础层能力</li></ul><p>这里必须要说的是，<strong>这四层不一定是指物理四层，也可以在一个微服务中拆分逻辑四层</strong>。四层架构有很多变种，如六边形架构、洋葱架构、整洁架构、清晰架构等等。这些繁多的概念我们这里不过多讨论，仅以洋葱架构为例，着重强调 DDD 中的<strong>依赖倒置（DIP）</strong>，以便后面更容易介绍仓储/防腐层等概念。</p><blockquote><p>依赖倒置(DIP)：<br>1.高级模块不应依赖于低级模块。两者都应依赖抽象。<br>2.抽象不应依赖细节。细节应依赖于抽象。</p></blockquote><img src="640-20240409112856427.jpeg" alt="img" style="zoom:40%;"><p>如上，洋葱架构越往里依赖越低，越是核心能力。基础设施层在最外面，依赖其他层，这是是因为 DDD 中其他层等需要定义自己需要的基础能力接口，而基础设施层负责依赖并实现这些接口，从而实现整体依赖倒置。这体现了 DDD 的由全局入细微、自顶层向下层的设计思维。</p><h3 id="3-DDD-的概念和实践"><a href="#3-DDD-的概念和实践" class="headerlink" title="3.DDD 的概念和实践"></a><strong>3.DDD 的概念和实践</strong></h3><h4 id="1）战略和战术"><a href="#1）战略和战术" class="headerlink" title="1）战略和战术"></a>1）战略和战术</h4><p>DDD 的落地过程，其实就是<strong>战略建模</strong>和<strong>战术建模</strong>。</p><p><strong>战略建模</strong>，是指：通过 DDD 的理论，对业务需求进行拆解分析，划分子域，梳理限界上下文，通过领域语言从战略层面进行领域划分以及构建领域模型。并且在在构建领域模型的过程中梳理出业务对应的聚合、实体、以及值对象。</p><p><strong>战术建模</strong>，是指：以领域模型基础，通过限界上下文作为服务划分的边界进行微服务拆分，在每个微服务中进行领域分层，实现领域服务，从而实现领域模型对于代码映射目的，最终实现 DDD 的落地实施。</p><img src="640-20240409112939665.jpeg" alt="img" style="zoom:50%;"><p>当然，战略和战术的建模除了要考虑业务形态，还要考虑到组织架构，就如同<strong>康威定律</strong>中的表达，<strong>沟通架构会影响技术架构</strong>。</p><blockquote><p>康威定律：任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。</p></blockquote><h4 id="2）领域"><a href="#2）领域" class="headerlink" title="2）领域"></a>2）领域</h4><p>DDD 在解决复杂的问题的时候，使用的是分而治之的思想。而这个分而治之的思想，就是从领域开始，一个领域就是一个问题空间，而我们在拆分这个问题空间的时候，也就是在划分子领域和寻找它的解系统的过程。</p><p><strong>实践例子：</strong></p><p>如我们某个新的增值业务，就是看成是的大的增值业务域，接下来我们通过 DDD 来指导拆分它。</p><img src="640-20240409113015146.jpeg" alt="img" style="zoom:33%;"><h4 id="3）子域"><a href="#3）子域" class="headerlink" title="3）子域"></a><strong>3）子域</strong></h4><p>如果一个领域太大太复杂，涉及到的业务规则、交互流程、领域概念太多，就不能直接针对这个大的领域进行建模。这时就需要将领域进行拆分，本质上就是把大问题拆分为小问题，把一个大的领域划分为了多个小的领域（子域）。</p><p>子域可以分为三类：</p><p><strong>核心子域：</strong>业务成功的核心竞争力。</p><p><strong>通用子域：</strong>不是核心，但被整个业务系统所使用 。</p><p><strong>支撑子域：</strong>不是核心，不被整个系统使用，完成业务的必要能力。</p><p>子域的划分除了分治了大的问题空间，也划定了工作的优先级。我们应该给予核心域最高的优先级和最大的资源。在实施 DDD 的过程中，我们也是主要关注于核心域。</p><p><strong>实践例子：</strong></p><p>子域的划分，需要比较强的业务知识和产品研发集体讨论，准确和深入的业务见解在这一阶段尤为重要。这里我们不对业务知识深入讨论，仅展示下我们的对增值业务域的拆解结果。</p><img src="640-20240409113038722.jpeg" alt="img" style="zoom:50%;"><p>这里要说的是，套餐域在实现的过程中由于产品需求变化概念被废弃了，但是由于我们的子域拆分，套餐域和其他域实现上没有任何耦合，所以废弃套餐域概念的废弃就像拆掉一个积木一样，对整套系统没有任何影响，也不会遗留任何不必要的包袱代码。</p><h4 id="4）限界上下文"><a href="#4）限界上下文" class="headerlink" title="4）限界上下文"></a><strong>4）限界上下文</strong></h4><p>要理解限界上下文，首先要先介绍通用语言。通用语言是 DDD 非常重要的一点。比如商品这个概念，在商品域里是指备上架的商品， 包含了 id、介绍、文档等。在交易域里其实是指订单中被交易的实体，关注的是 id、成交时刻的售价等参数、成交数量。而如果不能明确这些概念和他们的关系就会让开发人员的实现变的随心所欲和模糊。</p><p>而限界上下文是就是划分一个边界，当领域模型被一个显示的边界所包围时，其中每个概念的含义应该是明确且有唯一的含义。</p><p>我觉得初学者最常碰到的问题，肯定”明明已经有子域了，为什么还会有限界上下文这个概念”。子域是一个子问题空间，而限界上下文的作用是指导如何设计这个问题空间的解系统。换句话说，限界上下文才是真正用来指导微服务划分。一般来说一个子域对应一个或多个限界上下文。</p><p>划分限界上下文可以参考如下的规则：1） 概念是否有歧义：如果一个模型在一个上下文里面有歧义，就说明可以继续拆分限界上下文。</p><p>2）外部系统：可以把与外部系统交互的那部分拆分出去降低外部系统对我们我们的核心业务逻辑的影响。</p><p>3）组织架构：不同团队最好在不同的限界上下文里面开发，避免沟通不顺畅、集成困难等问题。可以参考上述”<strong>康威定律</strong>“。</p><p><strong>实践例子 1：</strong></p><p>如上所述，商品<strong>这个概念，是需要用限界上下文在不同场景区分开的。当然这也会导致两个限界上下文之间会有依赖。通过 DDD 的概念可以指导我们进行如下实现。</strong></p><img src="640-20240409113113094.jpeg" alt="img" style="zoom:50%;"><p><strong>其中 gateway/gatewayimpl 是防腐层的实现，DTO 是指数据传输对象，APP 是指商品应用层。两个不同颜色的商品是指两个上下文中分别进行定义的不同的实体或值对象。</strong></p><p><strong>实践例子 2：</strong></p><p>交易域中，有两个订单的概念，其中第一个订单的概念是指业务层订单， 第二个订单的概念是指内部基础层订单。业务订单更关注发生交易的成交商品信息，这个订单是用户需要的。基础层订单更关注交易底层的过程信息，这个订单更多是我们内部人员需要的，用户不理解。</p><p>当时有个思路是想让基础层团队的同学额外开发直接支持基础层订单存储业务信息，这明显是不符合 DDD 限界上下文划分规则 1）和 3）的，是需要通过限界上下文解耦开的。所以我们在交易域中拆分两个上下文，后续从微服务层面也是相互独立的微服务，各自管理各自的领域实体和值对象。</p><img src="640-20240409113132990.jpeg" alt="img" style="zoom:50%;"><h4 id="5）防腐层"><a href="#5）防腐层" class="headerlink" title="5）防腐层"></a><strong>5）防腐层</strong></h4><p>当两个限界上下文相互调用的时候，需使用防腐层（ACL）来进行两个限界上下文的隔离，并实现 value object 的转换。避免不同上下文直接互相调用，不然一旦被调用上下文被修改则可能产生较大影响。</p><p><strong>实践例子：</strong></p><p>实现链路可以参考 3.4 的例子 1，在商品域中，我们的防腐层是按照如下的目录方式实现的， 领域层来定义领域层需要的防腐接口，基础设施层继承并实现防腐接口，在基础设施层直接调用其他限界上下文。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">productdomainsvr（商品限界上下文）</span><br><span class="line">├──domain（领域层）</span><br><span class="line">│├──aggregate</span><br><span class="line">││├──spu.cpp//1)spu领域对象需要调用其他限界上下文生成id</span><br><span class="line">││└──spu.h</span><br><span class="line">│└──gateway</span><br><span class="line">│└──gen_id_gateway.h//2)领域层定义调用其他限界上下文生成id的防腐接口</span><br><span class="line">├──infrastructure（基础设施层）</span><br><span class="line">│└──gatewayimpl</span><br><span class="line">│└──acl（防腐层）</span><br><span class="line">│├──gen_id_gateway_impl.cpp//3)基础设施层实现领域层定义的防腐接口，真实调用其他上下文</span><br><span class="line">│└──gen_id_gateway_impl.h</span><br></pre></td></tr></table></figure><h4 id="6）领域事件"><a href="#6）领域事件" class="headerlink" title="6）领域事件"></a><strong>6）领域事件</strong></h4><p>两个限界上下文除了通过使用防腐层直接调用，更多的时候是通过领域事件来进行解耦。</p><p>并不是所有领域中发生的事情都需要被建模为领域事件，我们只关注有业务价值的事情。领域事件是领域专家所关心的（需要跟踪的、希望被通知的、会引起其他模型对象改变状态的）发生在领域中的一些事情。</p><p>其实，领域事件的本质就是事件，我们常见的 kafka、wq 等都可以作为领域事件的实现基建。通过领域事件，可以把很轻松两个限界上下文解耦</p><p><strong>实践例子：</strong></p><p>在我们的增值业务中，交易域的”支付成功”就是一个领域事件，计费域订阅这个领域事件，从而可以根据这个事件调整客户的计费资源包实体。</p><img src="640-20240409113326891.jpeg" alt="img" style="zoom:50%;"><p>可以想象，如果这里没有采用领域事件， 而是交易域直接调用计费域的 rpc 通知交易成功，那么当后续有其他域需要接受“支付成功”这个事件，或者，计费域被调用的接口出现故障。都会让交易域陷入麻烦，前者需要交易域不停的堆叠调用外部 rpc 的代码并让系统变得不稳定，后者则直接会让计费域的故障影响到用户交易。</p><h4 id="7）实体-值对象"><a href="#7）实体-值对象" class="headerlink" title="7）实体/值对象"></a><strong>7）实体/值对象</strong></h4><p><strong>实体是指上下文中唯一的且可持续变化的基础单元，在其生命周期中可以通过稳定的唯一 id 来标识。实体在我们代码中以领域对象的形态存在，同时具备属性和方法，实体是 DDD 用来实现充血编程、解决贫血症的关键。</strong></p><p><strong>与实体相对应的就是值对象，如果没有唯一标识就是值对象。值对象一般是嵌套在实体里面的。</strong></p><p><strong>实践例子：</strong></p><p>商品域中的实体和值对象如下</p><table><thead><tr><th align="left"><strong>实体</strong></th><th align="left"><strong>描述</strong></th><th align="left"><strong>关键值对象</strong></th></tr></thead><tbody><tr><td align="left">SPU</td><td align="left">指一个被上架的服务。</td><td align="left">spu_id, spu_type，状态等。</td></tr><tr><td align="left">SKU</td><td align="left">指一个服务具体的单项套餐。</td><td align="left">sku_id, 规格，价格等。</td></tr><tr><td align="left">折扣</td><td align="left">自定义折扣。</td><td align="left">折扣 id，折扣类型，折扣比例等。</td></tr></tbody></table><h4 id="8）聚合-聚合根"><a href="#8）聚合-聚合根" class="headerlink" title="8）聚合/聚合根"></a><strong>8）聚合/聚合根</strong></h4><p>把关系紧密的实体放到一个聚合中，每个聚合中有一个实体作为聚合根，所有对于聚合内对象的访问都通过聚合根来进行，外部对象只能持有对聚合根的引用。每个聚合都可以有一个独立的上下文边界。</p><p>聚合应划分的尽量小，一个聚合只包含一个聚合根实体和密不可分的实体，实体中只包含最小数量的属性。设计这样的小聚合有助于进行后续微服务的拆分。</p><p>如果一个 rpc 所实现的功能是跨聚合的，那跨聚合的编排协调工作应该放在应用层来实现。</p><p><strong>实践例子：</strong></p><p>我们可以在 6)中的例子划分如下的聚合。</p><table><thead><tr><th align="left"><strong>聚合</strong></th><th align="left"><strong>实体</strong></th><th align="left"><strong>是否是根</strong></th></tr></thead><tbody><tr><td align="left">聚合 1</td><td align="left">服务 SPU</td><td align="left">是</td></tr><tr><td align="left">服务 SKU</td><td align="left">否</td><td align="left"></td></tr><tr><td align="left">聚合 2</td><td align="left">折扣</td><td align="left">是</td></tr></tbody></table><p>在底层存储落表上， spu 实体/折扣实体作为表的一行， 而 sku 实体在这种聚合建模的指引下我们设计成 spu 聚合根的一列。</p><p>在微服务拆分上，如果想拆到最细粒度， 可以把两个聚合按照各自上下文拆成独立的微服务。当然这种落地实现并不是 DDD 强行要求的，我认为一些时候我们也可以从开发维护效率的角度考虑， 将一些有关联的小上下文放在一个为微服务上。我们在处理商品域上选择了后者。</p><h4 id="9）DTO-领域对象-Data-object"><a href="#9）DTO-领域对象-Data-object" class="headerlink" title="9）DTO/领域对象/Data object"></a><strong>9）DTO/领域对象/Data object</strong></h4><p>当一个请求进入 DDD 所设计的系统中，这个请求的形态会根据所在的层级发生如下变换，DTO&lt;-&gt;领域对象&lt;-&gt;Data object。</p><p>DTO 是指对外传输的其他服务需要理解的结构，领域对象是指同时包含了属性和方法的领域实体封装，Data object 则是真正用于最终存储的数据结构。</p><img src="640-20240409113416809.jpeg" alt="img" style="zoom:50%;"><p>这里其实很容易发现，DTO 的存在虽然符合其他调用方<strong>最少知识原则（LKP）</strong>，但如果连最简单的查询请求都需要做这三级的转换，那无疑是会加重开发的复杂度，变成为了设计模式而设计模式。</p><blockquote><p>最少知识原则(迪米特法则，LKP):一个软件实体应当尽可能少地与其他实体发生相互作用。这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。</p></blockquote><p>所以 DDD 在这里一般会使用 CQRS（读写责任分离）架构，来保证一些简单的查询请求不会因为领域建模而变得过于复杂。CQRS（读写责任分离）基于 CQS（读写分离），使用了 CQRS 的 DDD 对象转换流程如下：</p><img src="640-20240409113458599.jpeg" alt="img" style="zoom:50%;"><p><strong>实践例子：</strong></p><p>我们的实现是在领域对象中封装了转换的 convert 函数（当然也可以在基础设施层将 convert 方法拆分出来做单独的封装），用于将 DTO 转换为领域对象，或者将领域对象转换为 DO。下面是我们明细域的实际转换代码和转换过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.领域对象中定义convert方法</span></span><br><span class="line">classDetailRecord&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">intConvertFromDTO(constgoogle::protobuf::Message&amp;oDto);</span><br><span class="line">intConvertToDO(detailrecordinfrastructure::DetailRecordDO&amp;oDo);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.应用层调用方法将DTO转化为领域对象，然后调用仓储接口进行持久化</span></span><br><span class="line">intDetailrecordApplication::InsertDetailRecord(unsignedinthead_uin,constInsertDetailRecordReq&amp;req,InsertDetailRecordResp*resp)&#123;</span><br><span class="line">intiRet=<span class="number">0</span>;</span><br><span class="line">classDetailRecordoRecord;</span><br><span class="line">iRet=oRecord.ConvertFromDTO(req);<span class="comment">//生成领域对象，可以同时利用领域对象的方法进行自检等操作</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">iRet=m_oDetailRecordGateway-&gt;Save(oRecord);<span class="comment">//调用仓储接口进行持久化</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">returniRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.在仓储中将领域对象转化为Dataobject，进行落存储操作，并发布领域事件</span></span><br><span class="line">intDetailRecordGatewayImpl::Save(DetailRecord&amp;oEntity)&#123;</span><br><span class="line">detailrecordinfrastructure::DetailRecordDOoDo;</span><br><span class="line">intiRet=oEntity.ConvertToDO(oDo);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">iRet=oKvMapper.insert(oDo);<span class="comment">//实际落存储</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">iRet=oEventMapper.publish(oDo);<span class="comment">//发送领域事件</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">returniRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10）仓储"><a href="#10）仓储" class="headerlink" title="10）仓储"></a><strong>10）仓储</strong></h4><p><strong>仓储</strong>是领域层由定义接口，它抽象了业务逻辑中对实体的访问（包括读取和存储）的技术细节。它的作用就是通过隔离具体的存储层技术实现来保证业务逻辑的稳定性。注意，<strong>仓储只是接口的定义是在领域层，但是它的实现是在基础设施层</strong>。</p><p>仓储不是数据库 Dao！！！</p><p>仓储不是数据库 Dao！！！</p><p>仓储不是数据库 Dao！！！</p><p>重要的事情说三遍，仓储是从业务逻辑的角度抽象出来的接口，所以仓储的接口在实现上，一般是一个聚合对应一个仓储实现，仓储的需要用领域对象做参数。仓储接口的命名也可以取 save 这种更业务的命名， 而避免传统 dao 的 insert/set 等这种明明。</p><p><strong>实践例子：</strong></p><p>通过 3.9 的例子，我们可以发现，仓储用于持久化的接口里，不但包含了写 kv 的操作，还包含了发布领域事件等操作，这就是因为仓储是从业务逻辑角度抽象出来的接口，领域层只需要理解 save 这个业务操作，而不应该理解 save 的过程包含了落存储、发布领域事件等具体流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.领域层定义DetailRecord仓储的接口</span></span><br><span class="line">classDetailRecordGateway&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">virtualintSave(DetailRecord&amp;oEntity)=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.基础设施层继承领域层的仓储接口进行实现</span></span><br><span class="line">classDetailRecordGatewayImpl:publicDetailRecordGateway&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">virtualintSave(DetailRecord&amp;oEntity);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.仓储save接口具体实现</span></span><br><span class="line">intDetailRecordGatewayImpl::Save(DetailRecord&amp;oEntity)&#123;</span><br><span class="line">detailrecordinfrastructure::DetailRecordDOoDo;</span><br><span class="line">intiRet=oEntity.ConvertToDO(oDo);</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">iRet=oKvMapper.insert(oDo);<span class="comment">//实际落存储</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">iRet=oEventMapper.publish(oDo);<span class="comment">//发布领域事件</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">returniRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11）领域服务"><a href="#11）领域服务" class="headerlink" title="11）领域服务"></a><strong>11）领域服务</strong></h4><p>当一些能力不适合放在某个领域对象中实现，又因为过于复杂不应该放在应用层来实现。可以把这些操作封装成领域服务的中方法，由应用层编排领域层的领域对象和领域服务方法来完成具体的业务功能。</p><h3 id="4-DDD-的代码脚手架"><a href="#4-DDD-的代码脚手架" class="headerlink" title="4.DDD 的代码脚手架"></a><strong>4.DDD 的代码脚手架</strong></h3><p>我们基于对 DDD 的理解和 WXG 的 svrkit 框架，设定我们的代码脚手架。脚手架的目录如下所示，希望可以给想一起实践的同事抛砖引玉，也欢迎大家来找我们一起讨论：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">项目目录</span><br><span class="line">├──adapter（物理用户界面模块）</span><br><span class="line">├──domainsvr（领域微服务）</span><br><span class="line">│├──detailrecorddomainsvr（明细域微服务）</span><br><span class="line">││├──adapter（用户界面层）</span><br><span class="line">││├──application（应用层）</span><br><span class="line">│││├──detailrecord_application.cpp（应用层方法）</span><br><span class="line">││├──domain（领域层）</span><br><span class="line">│││├──aggregate（聚合根）</span><br><span class="line">││││├──detail_record.cpp（领域对象）</span><br><span class="line">││││└──detailrecordaggregate.proto（聚合根的值对象）</span><br><span class="line">│││├──entity（非根实体）</span><br><span class="line">││││└──detailrecordentity.proto（非根实体的值对象）</span><br><span class="line">│││├──gateway</span><br><span class="line">││││└──detail_record_gateway.h（仓储接口）</span><br><span class="line">│││└──detailrecord_domain_service.cpp（领域服务）</span><br><span class="line">││├──infrastructure（基础设施层）</span><br><span class="line">│││├──gatewayimpl</span><br><span class="line">││││├──acl（防腐层实现）</span><br><span class="line">││││└──detail_record_gateway_impl.cpp（仓储实现）</span><br><span class="line">│││└──detailrecordinfrastructure.proto（Dataobject定义）</span><br><span class="line">││└──detailrecord.proto（DTO定义)</span><br><span class="line">└──infrastructuresvr（物理基础设施模块）</span><br></pre></td></tr></table></figure><hr><p><strong>参考文档：</strong></p><p><a href="http://www.yitb.com/article-41463">后台开发进阶：白话DDD从入门到实践</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> OOA&amp;OOD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类间关系</title>
      <link href="/2024/03/18/UML%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/"/>
      <url>/2024/03/18/UML%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="UML类间关系"><a href="#UML类间关系" class="headerlink" title="UML类间关系"></a>UML类间关系</h1><h2 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h2><p>在UML类图中，常见的有以下几种关系：</p><ul><li><strong>泛化/继承（Generalization）</strong></li><li><strong>实现（Realization | Implementation）</strong></li><li><strong>关联（Association)</strong></li><li><strong>聚合（Aggregation）</strong></li><li><strong>组合(Composition)</strong></li><li><strong>依赖(Dependency)</strong></li></ul><h3 id="泛化-继承（Generalization）"><a href="#泛化-继承（Generalization）" class="headerlink" title="泛化/继承（Generalization）"></a>泛化/继承（Generalization）</h3><p>【泛化关系】：是一种<strong>继承</strong>关系，表示<strong>一般与特殊</strong>的关系。它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。<br>【关系描述】：”is a” relationship<br>【箭头指向】：带空三角箭头的实线，箭头指向父类；<br>【示例解析】：Apple（子类） 继承了 Fruit（父类）；</p><img src="image-20240318113802885.png" alt="image-20240318113802885" style="zoom:30%;"><h3 id="实现（Realization-Implementation）"><a href="#实现（Realization-Implementation）" class="headerlink" title="实现（Realization | Implementation）"></a>实现（Realization | Implementation）</h3><p>【实现关系】：是一种<strong>类与接口</strong>的关系，表示类是接口所有特征和行为的实现。<br>【箭头指向】：带三角箭头的虚线，箭头指向接口；<br>【示例解析】：BattleState（实现类） 实现了 State（接口 | 抽象类）；</p><img src="image-20240318134118035.png" alt="image-20240318134118035" style="zoom:30%;"><h3 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h3><p>【组合关系】：是 <strong>[强]整体与部分的关系，且部分不能离开整体而单独存在，不可分离</strong> 。如公司和部门是整体和部分的关系，没有公司就不存在部门。<br>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中 <strong>代表整体的对象负责代表部分的对象的生命周期</strong> 。强耦合关系<br>【代码体现】：成员变量；<br>【箭头及指向】：带实心菱形的实线，菱形指向整体；<br>【示例解析】：将 部门 组合到 公司 中；</p><img src="image-20240318134424429.png" alt="image-20240318134424429" style="zoom:30%;"><h3 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h3><p>【聚合关系】：是<strong>整体与部分的关系，且部分可以离开整体而单独存在，可分离</strong>。如：车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。<br>聚合关系是关联关系的一种，是一种强关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br>【关系描述】：”has a” relationship<br>【代码体现】：成员变量；<br>【箭头及指向】：带空心菱形的实心线，菱形指向整体；<br>【示例解析】：将 Wheel 聚合到 Car 中；</p><img src="image-20240318134354221.png" alt="image-20240318134354221" style="zoom:30%;"><h3 id="关联（Association"><a href="#关联（Association" class="headerlink" title="关联（Association)"></a>关联（Association)</h3><p>【关联关系】：是一种<strong>拥有</strong>的关系，它使一个类知道另一个类的属性和方法；关联具有导向性：即双向关系 或 单向关系。如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。<br>【代码体现】：成员变量；<br>【箭头指向】：带普通箭头的实心线，双向关联是有两个箭头 或 没有箭头的实线，单向的关联有一个箭头，指向被拥有者。<br>【示例解析】：老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。<br>下图为自身关联：</p><img src="image-20240318134318679.png" alt="image-20240318134318679" style="zoom:30%;"><h3 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h3><p>【依赖关系】：是一种<strong>使用</strong>的关系，即：一个类的实现需要另一个类的协助，所以要尽量不使用双向的依赖，会导致循环依赖。<br>【代码表现】：局部变量、方法的参数或者对静态方法的调用；<br>【箭头及指向】：带箭头的虚线，指向被使用者；<br>【示例解析】：BattleState（依赖者） 依赖 Weapon（被依赖者），即：BattleState类中使用到了Weapon类对象；<br>【使用方法】：</p><ul><li>类中使用到了另一个类的实例对象；</li><li>类中的方法使用到了另一个类的实例对象；</li><li>某类的实例作为另一个类的成员属性；</li><li>某个类作为另一个类中方法的入参类型；</li><li>某个类作为另一个类中方法的返回值类型；</li></ul><img src="image-20240318134458387.png" alt="image-20240318134458387" style="zoom:30%;"><h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><p>各种关系的强弱顺序：<br><strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong></p><hr><h2 id="封装、继承、聚合"><a href="#封装、继承、聚合" class="headerlink" title="封装、继承、聚合"></a>封装、继承、聚合</h2><h3 id="封装：封装的是属性，封：private-装：set、get"><a href="#封装：封装的是属性，封：private-装：set、get" class="headerlink" title="封装：封装的是属性，封：private　　装：set、get"></a>封装：封装的是属性，封：private　　装：set、get</h3><p>可以看做将属性和get/set方法捆绑的过程。</p><p>优点：<br>1、防止对封装数据进行未经授权的访问，提高安全性。使用者只能通过事先预定好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作；<br>2、有利于保证数据的完整性；<br>3、便于修改，增加代码的可维护性；<br>4、隐藏一个类的实现细节。</p><p>强内聚弱耦合 | 高内聚低耦合<br>一个类通常就是一个小的模块，我们应该让模块<strong>仅仅公开必须要让外界知道的内容，而隐藏其他一切内容。</strong>我们在进行程序的详细设计时，尽量避免一个模块直接修改或操作另一个模块的数据。<br>高内聚：让一个类功能尽量强大；<br>低耦合：如果多个类通信，尽量单线联系；</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类的（非私有）属性、方法，不继承构造器，实现对类的复用；<br>所有的类的最根源的父类是Object。</p><p><strong>Object类下的通用方法（所有类都有这些方法）：</strong></p><ul><li>clone克隆：创建一个和自己一样的对象，深度克隆，但是如果是嵌套的对象，每一层对象类都需要实现Cloneable接口并重写Object的clone()方法，比较繁琐，这种场景推荐使用序列化和反序列化；</li><li>toString：变成字符串</li><li>finalize：垃圾回收，他是最后一道防线轮询堆地址是否有栈在调用。　　　　　　</li><li>wait：让当前线程等候</li><li>notify：唤醒被等待的线程</li><li>getClass：得到当前对象的运行时类</li><li>hashCode：这是当前对象的hash码。让当前对象唯一，便于查找。</li><li>notifyAll：唤醒全部线程。</li><li>equals：判断堆的值是否相等。</li></ul><blockquote><p><strong>Java中继承为单继承，可多实现。</strong></p></blockquote><h3 id="聚合-组合（为了不使用继承，组合聚合复合原则）"><a href="#聚合-组合（为了不使用继承，组合聚合复合原则）" class="headerlink" title="聚合|组合（为了不使用继承，组合聚合复合原则）"></a>聚合|组合（为了不使用继承，组合聚合复合原则）</h3><p>组合（composite）、聚合（aggregation）：如果想复用一个类，除了继承以外，还可以把该类当做另一个类的组成部分，从而允许新类直接复用该类的public方法，不管是继承还是组合、聚合，都允许在新类中直接复用旧类的方法。<br>组合、聚合 是直接把旧类对象作为新类的属性嵌入，用于实现新类的功能，通常需要在新类里使用private修饰符嵌入该类对象。 并在构造器中实现对该对象成员变量的实例化。<br>组合和聚合从复合原则上是一样的，都是将复用类作为一个另一个类的组成部分。不同之处在于组合的限制更严格，复用类的生命周期追随调用类的生命周期，复用类对象无法单独存在，当调用类对象消失时复用类也要消失；而聚合中复用类可以单独存在。在实际开发中多使用聚合，此处使用聚合为例。</p><h3 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h3><p>常见的封装有两种实现方式：</p><ul><li><strong>继承</strong></li><li><strong>聚合</strong></li></ul><p>继承有封装的作用，通过子类的public方法进行暴露。如果父类中的属性和方法很多，使用继承会导致子类过多的暴露父类的方法，包括不需要暴露的内容，这样就降低了封装性。此时可以考虑使用静态内部类，将待继承的父类收敛到子类中，<strong>在外部类中定义一个静态内部类来继承目标父类，并在外部类中创建静态内部类的对象，用于执行具体的操作，而外部类只定义必须暴露的public方法，这样就有效提升了外部类的封装性</strong>，暴露的方法都是必须要暴露的，没有多余不受控制的public方法。<br>阅读JDK源码，其实发现很多源码都是这么玩的，都是定义一个静态内部类去继承目标父类，然后在外部类中使用该静态内部类对象继承的方法，确实是高度封装外部类的好玩法！！！<br>其实对于继承父类并保证高封装性的平衡有两种方式或者说两种场景：</p><ol><li>单个类需要使用目标父类的方法：类中定义静态内部类来继承目标父类；</li><li>多个类需要使用目标父类的方法：单独定义一个类用于继承目标父类，提高复用性；</li></ol><p><strong>Demo</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedHashLRUCache中定义的方法的底层实现都是LinkedHashMap,没有直接选择继承LinkedHashMap类进行方法暴露的原因如下一段文档注释.</span></span><br><span class="line"><span class="comment"> * This class is not thread-safe class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashLRUCache</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">LRUCache</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLRUCache&lt;K, V&gt; internalLRUCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashLRUCache</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        Preconditions.checkArgument(limit &gt; <span class="number">0</span>, <span class="string">&quot;The limit big than zero.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.internalLRUCache = <span class="keyword">new</span> <span class="title class_">InternalLRUCache</span>&lt;&gt;(limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.internalLRUCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.internalLRUCache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.internalLRUCache.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.internalLRUCache.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.internalLRUCache.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> internalLRUCache.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处定义了一个内部类来继承LinkedHashMap,而不是在外部类上直接继承LinkedHashMap,因为如果在外部类上直接继承LinkedHashMap,</span></span><br><span class="line"><span class="comment">     * 那么调用方就可以看见LinkedHashMap的所有方法,这样就降低了代码的封装性,我只希望调用者看见我定义的public方法.所以考虑使用聚合</span></span><br><span class="line"><span class="comment">     * 方式引入LinkedHashMap的子类对象,通过自定义的public方法进行暴露.</span></span><br><span class="line"><span class="comment">     * 又因为这个LinkedHashMap的子类只在当前类中被访问,所以就直接定义成当前类的静态内部类,更能体现良好的封装性.而没有定义成单独类.</span></span><br><span class="line"><span class="comment">     * 如果有很多地方就要聚合LinkedHashMap的子类,那么就要考虑将其定义为一个单独的外部类,方便调用.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InternalLRUCache</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">InternalLRUCache</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size() &gt; limit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是针对一个类进行封装，如果有多个外部类需要进行封装，考虑将继承了父类的静态内部类单独定义成一个基类，然后让所有的外部类都继承这个基类，这样可以提升多个外部类的封装性。</p><hr>]]></content>
      
      
      <categories>
          
          <category> OOA&amp;OOD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解</title>
      <link href="/2024/03/15/Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/03/15/Java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 | Annotation"></a>注解 | Annotation</h2><p>Annotation就是代码里的特殊标记，这些标记可以在编译期、类加载期和运行时 被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变代码原有逻辑的前提下，在源文件中嵌入一些补充信息。<br>Annotation可以像修饰符一样被使用，可用于修饰 包、类、构造器、方法、成员变量、方法参数、局部变量 的声明，这些信息被保存在Annotation的<code>&quot;name = value&quot;</code>键值对中。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责定义其他注解，Java定义了4个标准的<code>meta-annotation</code> 元注解类型，它们用于提供对其他<code>annotation</code>类型进行说明，这些元注解都在<code>java.lang.annotation</code>包中。</p><h4 id="Target：用于修饰一个Annotation的作用目标，用于描述注解的使用范围。"><a href="#Target：用于修饰一个Annotation的作用目标，用于描述注解的使用范围。" class="headerlink" title="@Target：用于修饰一个Annotation的作用目标，用于描述注解的使用范围。"></a>@Target：用于修饰一个Annotation的作用目标，用于描述注解的使用范围。</h4><ul><li><p><strong>@Target(ElementType.TYPE)  – 接口、类、枚举、注解</strong></p></li><li><p><strong>@Target(ElementType.FIELD)   – 字段、枚举的常量</strong></p></li><li><p><strong>@Target(ElementType.METHOD)  – 方法</strong></p></li><li><p>@Target(ElementType.PARAMETER)  – 方法参数</p></li><li><p>@Target(ElementType.CONSTRUCTOR)  – 构造函数</p></li><li><p>@Target(ElementType.LOCAL_VARIABLE) – 局部变量</p></li><li><p>@Target(ElementType.ANNOTATION_TYPE)  – 注解</p></li><li><p>@Target(ElementType.PACKAGE)  – 包</p></li></ul><h4 id="Retention-用于修饰一个Annotation的声明周期，-Retention包含一个RetentionPolicy类型的成员变量，使用-Retention时必须为该value成员变量指定值。"><a href="#Retention-用于修饰一个Annotation的声明周期，-Retention包含一个RetentionPolicy类型的成员变量，使用-Retention时必须为该value成员变量指定值。" class="headerlink" title="@Retention : 用于修饰一个Annotation的声明周期，@Retention包含一个RetentionPolicy类型的成员变量，使用@Retention时必须为该value成员变量指定值。"></a>@Retention : 用于修饰一个Annotation的声明周期，@Retention包含一个RetentionPolicy类型的成员变量，使用@Retention时必须为该value成员变量指定值。</h4><ul><li><p>RetentionPolicy.SOURCE : 在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注解；</p></li><li><p>RetentionPolicy.CLASS【默认值】 : 在class文件中有效（即class保留），当运行Java程序时，JVM不会保留注解；</p></li><li><p><strong>RetentionPolicy.RUNTIME</strong> : 在运行时有效（即运行时保留），当运行Java程序时，JVM会保留注解，程序可以通过反射获取注解的内容；</p></li><li><p>Source(源代码) &lt; Class(类) &lt; <strong>Runtime(运行时)</strong></p></li><li><p><strong>@Retention</strong>：注解的保留位置</p></li><li><ul><li><strong>@Retention(RetentionPolicy.SOURCE)</strong>  //注解仅存在于源码中，在class字节码文件中不包含;</li><li><strong>@Retention(RetentionPolicy.CLASS)</strong>   // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得;</li><li><strong>@Retention(RetentionPolicy.RUNTIME)</strong> // 注解会在class字节码文件中存在，在运行时可以通过反射获取到;</li></ul></li><li><p>@Document : 说明该注解将被包含在javadoc中</p></li><li><p>@Inherited : 子类可以继承父类的注解</p></li></ul><p>todo…</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL重复插入处理</title>
      <link href="/2024/03/15/MySQL%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E5%A4%84%E7%90%86/"/>
      <url>/2024/03/15/MySQL%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL重复插入处理"><a href="#MySQL重复插入处理" class="headerlink" title="MySQL重复插入处理"></a>MySQL重复插入处理</h1><h2 id="实际开发中常见的重复插入场景："><a href="#实际开发中常见的重复插入场景：" class="headerlink" title="实际开发中常见的重复插入场景："></a>实际开发中常见的重复插入场景：</h2><ul><li>前端未做防抖，重复调用insert方法</li><li>业务内部多次调用insert方法</li><li>高并发</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><ol><li><strong>Java业务代码层面</strong> 使用唯一性索引 和 <code>try...catch...</code></li><li><strong>SQL脚本层面</strong> 使用唯一性索引/主键索引 和 <code>on duplicate update key ...</code></li><li><strong>幂等校验</strong> 在执行insert之前，先查询数据记录是否已存在</li></ol><h2 id="使用唯一性索引-和-try…catch…"><a href="#使用唯一性索引-和-try…catch…" class="headerlink" title="使用唯一性索引 和 try…catch…"></a>使用唯一性索引 和 try…catch…</h2><p>选取数据表中合适的字段，创建唯一性索引，一般都是联合唯一索引。这样当出现两次插入相同的数据时就会抛出异常，然后在调用方法中使用<code>try...catch...</code>对异常进行捕获，并在catch中进行异常对应的处理。</p><p><strong>异常类型</strong>：<code>org.springframework.dao.DuplicateKeyException</code><br>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInsertController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CPConfigEntityMapper cpConfigEntityMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">insert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CPConfigEntity</span> <span class="variable">cpConfigEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CPConfigEntity</span>();</span><br><span class="line">        cpConfigEntity.setActiveTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        cpConfigEntity.setAuditing((<span class="type">byte</span>) <span class="number">2</span>);</span><br><span class="line">        cpConfigEntity.setContent(<span class="string">&quot;测试insert&quot;</span>);</span><br><span class="line">        cpConfigEntity.setExpireTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        cpConfigEntity.setModule(<span class="string">&quot;module&quot;</span>);</span><br><span class="line">        cpConfigEntity.setStatus((<span class="type">byte</span>) <span class="number">1</span>);</span><br><span class="line">        cpConfigEntity.setId(<span class="number">66L</span>);</span><br><span class="line">        cpConfigEntity.setCustomerNo(<span class="number">888L</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cpConfigEntityMapper.insertSelective(cpConfigEntity);</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DuplicateKeyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MySQL重复插入异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用主键索引（or-唯一索引）-on-duplicate-update-key"><a href="#使用主键索引（or-唯一索引）-on-duplicate-update-key" class="headerlink" title="使用主键索引（or 唯一索引）+ on duplicate update key"></a>使用主键索引（or 唯一索引）+ on duplicate update key</h2><p>这是利用MySQL的特性进行自动收敛重复插入异常，该语句的意思是：当 <strong>主键</strong> or <strong>唯一性索引</strong> 出现相同的内容时，自动触发后续的更新操作以<strong>收敛异常</strong>。<br><strong>位置</strong> ：在insert语句的最后面添加下面的语句。<br><strong>语法</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> duplicate <span class="keyword">update</span> column1<span class="operator">=</span>xxx[, column2 <span class="operator">=</span> xxx, ...];</span><br></pre></td></tr></table></figure><p>功能相当于将插入的重复语句变成了update语句，具体update的就是： <code>column1=xxx[,column2=xxx,...];</code> 指定的字段。<br><strong>示例</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> update_time <span class="operator">=</span> now();</span><br></pre></td></tr></table></figure><p><strong>完整SQL代码:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> id<span class="operator">=</span>&quot;insertSelective&quot; parameterType<span class="operator">=</span>&quot;com.maple.model.UicAuthorization&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> uic_authorization</span><br><span class="line">    <span class="operator">&lt;</span>trim prefix<span class="operator">=</span>&quot;(&quot; suffix<span class="operator">=</span>&quot;)&quot; suffixOverrides<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;id != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            id,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;uid != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            uid,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;parentAuthType != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            parent_auth_type,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;parentAuthValue != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            parent_auth_value,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;authType != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            auth_type,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;authValue != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            auth_value,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;createTime != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            create_time,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;updateTime != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            update_time,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>trim<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">    <span class="operator">&lt;</span>trim prefix<span class="operator">=</span>&quot;(&quot; suffix<span class="operator">=</span>&quot;)&quot; suffixOverrides<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;id != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;id&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;uid != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;uid&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;parentAuthType != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;parentAuthType&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;parentAuthValue != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;parentAuthValue&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;authType != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;authType&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;authValue != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;authValue&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;createTime != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;createTime&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">        <span class="operator">&lt;</span>if test<span class="operator">=</span>&quot;updateTime != null&quot;<span class="operator">&gt;</span></span><br><span class="line">            #&#123;updateTime&#125;,</span><br><span class="line">        <span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>trim<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> update_time <span class="operator">=</span> now();</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">insert</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Generator配置</title>
      <link href="/2024/03/14/Mybatis-Generator%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/03/14/Mybatis-Generator%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-Generator【MBG】配置"><a href="#Mybatis-Generator【MBG】配置" class="headerlink" title="Mybatis Generator【MBG】配置"></a>Mybatis Generator【MBG】配置</h1><h2 id="MBG插件配置"><a href="#MBG插件配置" class="headerlink" title="MBG插件配置"></a>MBG插件配置</h2><p>Step1：使用MBG的前提是需要在项目中添加MBG插件。<br>在项目的pom文件中添加以下插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--=====================================================================================================--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis-generator 逆向工程插件配置 | 如果不配置该插件,逆向工程构件时会报异常--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--控制台打印执行过程中的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--重复生成时覆盖之前的文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定xml配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--=====================================================================================================--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MBG的内容配置"><a href="#MBG的内容配置" class="headerlink" title="MBG的内容配置"></a>MBG的内容配置</h2><p>Step2：在项目的<code>resource</code>目录下的新增MBG配置文件，如： <code>generatorConfig.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--逆向工程,只能适用于单表操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库驱动:选择本地硬盘上的数据库驱动包 | 可以在pom.xml中配置mbg时不用添加数据库连接驱动的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span></span></span><br><span class="line"><span class="tag">            <span class="attr">location</span>=<span class="string">&quot;/Users/maple/Maple/Tools/Maven/repository/mysql/mysql-connector-java/8.0.21/mysql-connector-java-8.0.21.jar&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- strategyContext 是逆向工程的主要配置信息 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：起个名字 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetRuntime：设置生成的文件适用的 mybatis 版本 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;strategyContext id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成的Java文件的编码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化java代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javaFormatter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化XML代码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xmlFormatter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- beginningDelimiter和endingDelimiter：指明数据库中用于标记数据库对象名的符号，比如O:MYSQL默认是反引号`；ORACLE就是双引号&quot;， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--在创建class时，对注释进行控制--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注释生成的时间戳 true: 否 ; false: 是--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ; false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 数据库链接URL，用户名、密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1/Mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;nba106118&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--非必须，类型处理器，在数据库类型和java类型之间进行转换控制 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认情况下数据库中的 decimal，bigInt 在 Java 对应是 sql 下的 BigDecimal 类, 而不是 double 和 long 类型 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用常用的基本类型代替 sql 包下的引用类型 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认值为false--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成模型的包名和位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：生成的实体类所在的包 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：生成的实体类所在的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.maple.shudong.modal&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否允许子包 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否清理从数据库中查询出的字符串左右两边的空白字符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否对modal添加全参构造函数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;constructorBased&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 建立modal对象是否不可改变 即生成的modal对象不会有setter方法，只有构造方法 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;immutable&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成映射文件的包名和位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage：生成的实体类所在的包 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：生成的实体类所在的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对数据库的一个配置，是否把 schema 作为子包名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成Mapper的包名和位置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetPackage 和 targetProject：生成的 Mapper 文件的包和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.maple.shudong.dao&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 针对 oracle 数据库的一个配置，是否把 schema 作为字包名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- tableName是数据库中的表名或视图名，domainObjectName是生成的JAVA模型名，后面的参数不用改，</span></span><br><span class="line"><span class="comment">        要生成更多的表就在下面继续加table标签 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        Mapper中的方法可以通过方法名进行设置: 默认所有配置为true;可按需配置为false;</span></span><br><span class="line"><span class="comment">           enableCountByExample=&quot;true&quot; : countByExample() 方法</span></span><br><span class="line"><span class="comment">           enableUpdateByExample=&quot;true&quot; : updateByExample() + updateByExampleSelective() 方法</span></span><br><span class="line"><span class="comment">           enableDeleteByExample=&quot;true&quot; : deleteByExample() 方法</span></span><br><span class="line"><span class="comment">           enableSelectByExample=&quot;true&quot; : selectByExample() 方法</span></span><br><span class="line"><span class="comment">           enableDeleteByPrimaryKey=&quot;true&quot; : deleteByPrimaryKey() 方法</span></span><br><span class="line"><span class="comment">           enableInsert=&quot;true&quot; : insert() + insertSelevtive() 方法</span></span><br><span class="line"><span class="comment">           enableSelectByPrimaryKey=&quot;true&quot; : selectByPrimaryKey() 方法</span></span><br><span class="line"><span class="comment">           enableUpdateByPrimaryKey=&quot;true&quot; : updateByPrimaryKeySelective() + updateByPrimaryKey() 方法</span></span><br><span class="line"><span class="comment">           --&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!--不做处理--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;table tableName=&quot;sd_user&quot; domainObjectName=&quot;SdUser&quot;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--       delimitIdentifiers=&quot;true&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;MYSQL&quot; identity=&quot;true&quot; type=&quot;post&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/table&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--个性化处理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;sd_click_record&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;SdClickRecord&quot;</span> <span class="attr">delimitIdentifiers</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主键回填--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generatedKey</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">sqlStatement</span>=<span class="string">&quot;MYSQL&quot;</span> <span class="attr">identity</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;post&quot;</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--忽略列 | 生成modal时会忽略该字段值--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;ignoreColumn column=&quot;create_time&quot;/&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;ignoreColumn column=&quot;update_time&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="MBG启动配置"><a href="#MBG启动配置" class="headerlink" title="MBG启动配置"></a>MBG启动配置</h2><p>Step3：MBG的启动方式使用Maven命令行，在IDEA下的配置如图：</p><img src="image-20240314111429641.png" alt="image-20240314111429641" style="zoom:40%;"><p>Maven命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis-generator:generate -e</span><br></pre></td></tr></table></figure><p>上述命令可能会抛以下异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] Could not find goal &#x27;gererate&#x27; in plugin org.mybatis.generator:mybatis-generator-maven-plugin</span><br></pre></td></tr></table></figure><p>此时，使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dmybatis.generator.overwrite=true mybatis-generator:generate</span><br></pre></td></tr></table></figure><h2 id="MBG运行"><a href="#MBG运行" class="headerlink" title="MBG运行"></a>MBG运行</h2><p>Step4：在IDEA的启动配置框中选择上述创建的启动配置，点击运行即可。</p><img src="image-20240314112146548.png" alt="image-20240314112146548" style="zoom:70%;"><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MBG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用接口超时处理</title>
      <link href="/2023/12/28/%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/"/>
      <url>/2023/12/28/%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="调用接口超时处理"><a href="#调用接口超时处理" class="headerlink" title="调用接口超时处理"></a>调用接口超时处理</h1><blockquote><p>待完善…</p></blockquote><p><strong>1.增加超时时间|增加接口的超时时间</strong></p><p>假设A系统有个方法methodA，会调用B系统的methodB这个http接口，如果mehodA不追求超快的响应速度，那么你在调用methodB这个http接口时，可以增长超时时间，例如10秒超时。因为经常在某些时刻，由于网络原因或者系统原因，调用method会超时的。</p><p><strong>2.尝试多调用一次|超时重试,从概率角度去进行估算超时异常的概率</strong></p><p>需要考虑超时时间的设置,请求超时的概率来设置重试的次数,不一定是重试一次,可以是多次.</p><p>如果第一次调用methodB超时了，那么你可以尝试多调用一次。当然前提是，methodA不追求超快的响应时间。注意：调用多次不代表重复调用 制造脏数据;</p><p>但是这种方案的前提时间也是以调用方能够接收到的最长时间为前提,就是所有调用次数的时间加起来不能超过这个大前提;</p><p><strong>3.使用待处理队列|延迟队列</strong></p><p>如果methodA需要很快的响应速度，那么当调用methodB接口超时时，可以使用一个队列存储本次失败的记录，然后使用一个job每隔一段时间去扫这个队列，看看是否有待处理的数据。</p><p>备注：如果对方系统挂掉了，使用待处理队列的方式，比较合适。</p><p>这个只适合返回的结果不依赖超时的这个环节,否则该方案行不通.</p><p><strong>4.回滚数据</strong></p><p>catch这个超时异常，然后记录日志后，抛出这个异常，并把之前的数据回滚。让对方的系统重新调用。</p><p>备注:宁愿没有数据，也不要存储脏数据。</p><p><strong>5.使用异步机制|异步线程池</strong></p><p>如果你的业务方法中，需要调用对方的http接口，如果这个http接口不影响主流程的，那么可以使用一个线程，异步调用对方的http接口，并把超时时间设置长一些。由于使用了异步，主流程会立刻继续走的。</p><p>将耗时的请求使用异步线程单独的去执行,并将结果单独的存放在一个结果表中,然后在需要的地方去查询耗时线程的执行结果.如果这个耗时请求在业务上是串行的,可以让主业务线程在需要耗时线程结果的地方去查询结果表,然后进行主业务,这样就是在主业务一开始就执行异步线程,然后想尽量利用在调用异步线程结果之前的这段代码的执行时间,在这一段时间并行执行,这样可以减少主线程的等待时间.</p><p>但是这种改造的成本比较大,相当于新增一个单独的耗时任务的接口,上游业务方调用也会多一层.</p><p>todo…</p>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 接口超时 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户中心的设计与实践</title>
      <link href="/2023/12/28/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/12/28/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="亿级用户中心的设计与实践"><a href="#亿级用户中心的设计与实践" class="headerlink" title="亿级用户中心的设计与实践"></a>亿级用户中心的设计与实践</h1><p>用户中心是互联网最为基础的核心系统，随着业务和用户的增长，势必会带来不断的挑战。如何在亿级的情况下保证系统的高可用，高性能以及高安全，本文能够给你一套实践方案。</p><blockquote><p>本文讨论的是微服务框架下的用户中心，不涉及授权等功能；</p></blockquote><p>用户中心，顾名思义就是管理用户的地方，几乎是所有互联网公司最为核心的子系统之一。它的核心功能是登录与注册，主要功能是修改密码、换绑手机号码、获取用户信息、修改用户信息和一些延伸服务，同时还有登录之后生成Token以及校验Token的功能。下面我们从几个维度来拆解用户中心。</p><h2 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h2><p>用户中心既需要为用户提供服务，也会承担其他业务的频繁调用；既然需要为用户提供服务，它就会自带一些业务逻辑，比如用户在登录过程中需要风控或短信的校验，那么就会存在不可用的风险。而比如获取用户信息的接口，则没有那么多的依赖，可能只需要调用数据库或者缓存就可以。获取用户信息接口要求稳定，而核心的登录注册接口也需要稳定，但是当我们在接口层面加一些策略或者修改的时候，不希望因为上线问题导致整个服务不可用，而且上线后，需要对整个服务功能做全量的回归，导致资源严重浪费。</p><p>因此，基于业务特性，我们可以将用户中心拆成3个独立的微服务: 网关服务，核心服务，异步消费者服务。网关服务，提供http服务，聚合了各种业务逻辑和服务调用，比如登录时候需要校验的风控或者短信；核心服务，处理简单的业务逻辑以及数据存储，核心服务处在调用链路的终端，几乎不依赖调用其他服务，比如校验Token或者获取用户信息，他们就只依赖于redis或者数据库；而异步消费者服务，则处理并消费异步消息。下文会详细介绍。</p><img src="image-20231228105854049.png" alt="image-20231228105854049" style="zoom:50%;"><p>这样的设计之后，当有新功能上线时，核心服务和异步消费服务几乎不需要重新发布，只需要发布网关服务，依赖我们核心服务的第三方非常放心，层级也非常的清晰。当然，这样做的代价就是服务的调用链路变长了。由于涉及到网关和核心服务，就需要发布两个服务，而且要做兼容性测试。</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>用户中心的接口涉及到用户的核心信息，安全性要求高；同时，承接了较多第三方的调用，可用性要求也高。因此，对用户中心的接口做以下设计：</p><p>首先，接口可以拆分为面向Web和面向App的接口。Web接口需要做到跨域情况下的单点登录，加密、验签和token校验的方式也同App端的不一样。</p><p>其次，对核心接口做特殊处理。比如登录接口，在逻辑和链路上做了一些优化。为什么要对这些接口做特殊处理呢？假如用户不能登录，用户会非常恐慌，客诉量会立马上来。</p><p>那怎么做呢？</p><p>一方面，我们将用户核心信息表做简单。用户的信息当中会包含userId、手机号码、密码、头像、昵称等字段，假如把用户的这些所有信息都保存在一张表中，那么这张表将会异常庞大，变更字段变得异常困难。因此，需要将用户表拆分（垂直分表），将核心的信息保存在用户表中，比如userId、username、手机号码、密码、盐值（随机生成）等；而一些如性别，头像，昵称等信息保存在用户资料表中。</p><p>另一方面，我们需要将登录的核心链路做短，短到只依赖于读库。一般情况下，用户登录后，需要记录用户登录信息，调用风控或者短信等服务。对于登录链路来说，任何一个环节出现问题都有可能导致用户无法登录，那么怎么样才能做到最短的链路呢？方法就是依赖的服务可自动降级。比如说反欺诈校验出问题了，那么它自动降级后使用它的默认策略，极端情况下只做密码校验，主库挂了之后还能到从库读取用户信息。</p><p>最后就是接口的安全性校验。对App接口我们需要做防重放和验签。验签可能大家比较熟悉，但是对防重放这个概念可能相对陌生。防重放，顾名思义就是防止请求重复发送。用户请求在特定时间段内只能请求一次。即使用户请求被攻击者挟持，在一段时间内也无法重复请求。如果攻击者想要篡改用户请求再发送，对不起，请求不会通过。得益于大数据的支持，结合终端，我们还可以把每个用户行为画像存储在系统中（或者调用第三方服务）。用户发起请求后，我们的接口会根据用户画像对用户进行诸如手机号码校验、实名认证、人脸或者活体校验。</p><p><img src="640.png" alt="图片"></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>随着用户的增长，数据超过了1亿，怎么办？常见的办法就是分库分表。我们来分析一下用户中心常见的一些表结构：用户信息表，第三方登录关联表，用户事件表（操作日志表，登录日志表）。从上述表中可以看出来，用户相关的数据表增长相对缓慢，因为用户增长是有天花板的。用户事件表的增长是呈指数级增长，因为每个用户登录、变更等密码及变更手机号码等操作是不限次数。</p><p>因此，首先我们可以先把用户信息表垂直切分。正如上面说的，将用户ID、密码、手机号、盐值等常见字段从用户信息表中拆分，其他用户相关的信息用单独一张表。另外，把用户事件表迁移至其他库中。相比于水平切分，垂直切分的代价相对较少，操作起来相对简单。用户核心信息表由于数据量相对较少，即使是亿级别的数据，利用数据库缓存的机制，也能够解决性能问题。</p><p>其次，我们可以利用前后台业务的特性采用不同的方式来区别对待。对于用户侧前台访问：用户通过username/mobile登录或者通过uid来查询用户信息。用户侧信息的访问通常是单条数据的查询，我们可以通过索引多次查询来解决一致性和高可用问题。对于运营侧后台访问：根据年龄、性别、登录时间段、注册时间段等来进行查询，基本上都是批量分页查询。但是由于是内部系统，查询量低，对一致性要求低。如果用户侧和运营侧的查询采用同一个数据库，那么运营侧的排序查询会导致整个库的CPU上升，查询效率下降，影响到用户侧。因此，运营侧使用的数据库可以是和用户侧同样的MySQL离线库，如果想要增加运营侧的查询效率，可以采用ES非关系型数据库。ES支持分片与复制，方便水平分割和扩展，复制保证了ES的高可用与高吞吐，同时能够满足运营侧的查询需求。</p><p>简单的理解：就是用户的请求和后台运营的请求，读取的数据库不一样，因为后台运营一般都是批量查询，会导致数据库的压力或者慢查询，可以考虑将其分开，使用MySQL离线库或者从库提供后台查询操作。</p><p>最后，如果还是要水平切分来保证系统的性能，那么我们采取什么样的切分方式呢？常见的方法有索引表法和基因法。索引表法的思路主要是UID能够直接定位到库，但是手机号码或者username是无法直接定位到库的，需要建立一个索引表来记录mobile与UID或者username与UID的映射关系的方式来解决这个问题。通常这类数据比较少，可以不用分库分表，但是相比直接查询，多了一次数据库查询的同时，在新增数据的时候还多了一次映射关系的插入，事务变大。基因法的思路是我们将username或者mobile融入到UID中。具体做法如下：</p><ol><li>用户注册时，根据用户的手机号码，利用函数生成N bit的基因mobile_gen，使得mobile_gen=f(mobile);</li><li>生成M bit全局唯一的id，作为用户标识；</li><li>拼接M和N，作为UID赋给用户；</li><li>根据N bit来取余来插入到特定数据库；</li><li>查找用户数据的时候，将用户UID的后N bit取余来落到最终的库中。</li></ol><p>从上述过程中看，基因法只适用于某类经常查询的场景，比如用手机号码登录，如果用户使用username登录就比较麻烦了。因此大家也可以根据自己的业务场景来选择不同的方式水平切分。</p><h2 id="Token之柔性降级"><a href="#Token之柔性降级" class="headerlink" title="Token之柔性降级"></a>Token之柔性降级</h2><p>用户登录之后，另一个重要的事情就是Token的生成与校验。用户的Token分为两类， 一类是web端登陆生成的Token， 这个Token可以和Cookie结合， 达到单点登陆的效果，在此不细说了。另外一类就是APP端登录生成的Token。用户在我们的APP输入用户名密码之后，服务端会对用户的用户名密码进行校验，成功之后从系统配置中心获取加密算法的版本以及秘钥，并按照一定的格式排列用户ID，手机号、随机码以及过期时间，经过一系列的加密之后，生成了Token之后并将其存入Redis缓存。而Token的校验就是把用户ID和Token组合并校验是否在Redis中存在。那么假如Redis不可用了怎么办呢？这里有一个高可用和自动降级的设计。当Redis不可用的时候， 服务端会生成一个特殊格式的Token。当校验Token的时候，会对Token的格式进行一个判断。</p><p><img src="640-20231228111427761.png" alt="图片"></p><p>假如判断为Redis不可用时生成的Token，那么服务端会对Token进行解密，而Token的生成是由用户ID，手机号、随机码和过期时间等数据按照特定顺序排列并加密而来的， 那么解密出来的数据中也包含了ID，手机号码，随机码和过期时间。服务端会根据获取到的数据查询数据库， 比对之后告诉用户是否登录成功。由于内存缓存redis和数据库缓存性能的差距，在redis不可用的情况下，降级有可能会导致数据库无法及时响应，因此需要在降级的方法上加入限流。</p><p><img src="640-20231228111437617.png" alt="图片"></p><p>此处的柔性降级为采用数据库来作为备用数据源。不过在高并发场景下，数据库不一定能够hold得住，可以考虑使用其他的缓存数据库来作为备数据源，Redis或者MongoDB等等。</p><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><p>数据安全对用户中心来说非常重要。敏感数据需要脱敏处理，对密码更是要做多重的加密处理。应用虽然有自己的安全策略，但如果把黑客限制在登录之前，那应用的安全性将得到大幅度的提升。互联网上用户明文数据遭到泄露的案件屡屡发生，因此各大企业对数据安全的认识也提到了前所未有的高度。而即使使用了MD5和salt的加密方式，依然可以使用彩虹表的方式来破解。那么用户中心对用户信息是怎么保存的呢？</p><p>首先，正如上文中提到的用户密码、手机号等登录信息和其他的信息分离，而且在不同的数据库中。其次，对用户设置的密码进行黑名单校验，只要符合条件的弱密码，都会拒绝提交，因为不管使用了什么加密方式的弱密码，都极其容易破解。为什么呢？因为人的记性很差，大部分人总是最倾向于选择生日，单词等来当密码。6位纯数字可以生成100万个不同的密码，8位小写字母和数字的组合大概可以生成2.8万亿个不同的密码。一个规模为7.8万亿的密码库足以覆盖大部分用户的密码，对于不同的加密算法都可以拥有这样一个密码库，这也就是为什么大部分网站都建议用户使用8位以上数字加字母密码的原因。当然，如果一方面加了盐值，另一方面对密钥分开保管，破解难度会指数级增加。</p><p>最后，可以用bcrypt/scrypt的方式来加密。bcrypt算法是基于Blowfish块密钥算法来实现的，bcrypt内部实现了随机加盐处理，使用bcrypt之后每次加密后的密文都不一样，同时还会使用内存初始化hash过程。由于使用内存，虽然在CPU上运行很快，但是在GPU上并行运算并不快。随着新的FPGA集成了大型RAM，解决了内存密集IO的问题，但是破解难度依然不小。而scrypt算法弥补了bcrypt算法的不足，它将CPU计算与内存使用开销都指数级提升了。bcrypt和scrypt算法能够有效抵御彩虹表，但是安全性的提升带来了用户登录性能的下降。用户登录注册并不是一个高并发的接口，所以影响并不会特别大。因此在安全和性能方面需要依据业务类型和大小来做平衡，并不是所有的应用都需要使用这种加密方式来保护用户密码。</p><h2 id="异步消费设计"><a href="#异步消费设计" class="headerlink" title="异步消费设计"></a>异步消费设计</h2><p>此处的异步消费，就是上文提到的异步消费服务。用户在做完登录注册等操作后，需要记录用户的操作日志。同时，用户注册登录完毕后，下游业务需要对用户增加积分，赠送礼券等奖励操作。这些系统如果都同步依赖于用户中心，那么整个用户中心将异常庞大，链路非常冗长，也不符合业内的“大系统做小“的原则。依赖的服务不可用之后将会造成用户无法登录注册。因此，用户中心在用户操作完之后，将用户事件入库后发送至MQ，第三方业务监听用户事件。用户中心和下游业务解耦，同时用户操作事件入库后，在MQ不可用或者消息丢失的时候可做补偿处理。用户的画像数据也在很大程度上来源于此处的数据。</p><h2 id="灵活多样的监控"><a href="#灵活多样的监控" class="headerlink" title="灵活多样的监控"></a>灵活多样的监控</h2><p>用户中心涉及到用户的登录注册更改密码等核心功能，能否及时发现系统的问题成为关键指标，因此对业务的监控显得尤为重要。需要对用户中心重要接口的QPS、机器的内存使用量、垃圾回收的时间、服务的调用时间等做详细的监控。当某个接口的调用量下降的时候，监控会及时发出报警。除了这些监控之外，还有对数据库Binlog的写入，前端组件，以及基于ZipKin全链路调用时间的监控，实现从用户发起端到结束端的全面监控，哪怕出现一点问题，监控随时会告诉你哪里出问题了。比如运营互动推广注册量下降的时候，用户中心就会发出报警，可以及时通知业务方改正问题，挽回损失。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从服务架构设计，接口设计，token降级，数据安全和监控等方面介绍了亿级用户中心的设计，当然用户中心的设计远不止这些，还会包含用户数据的分库分表，熔断限流，第三方登录等，在本文中就不一一赘述。尽管本文中设计的用户中心能够满足大部分公司的需求，但是还存在一些比较大的挑战：在鉴权服务增长的情况下，如何平滑的从用户中心剥离；监控的侵入性以及监控的粒度的完善；另外服务的安全性、可用性、性能的提升永远都没有尽头，也是我们孜孜追求的目标。在未来的日子里，希望能够通过大家的努力，使用户中心的技术体系更上一层楼。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://mp.weixin.qq.com/s/hshFKM2mJSmmp7hPruXXEQ">亿级用户中心的设计与实践</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用户中心设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL之隐式类型转换</title>
      <link href="/2023/12/18/MySQL%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2023/12/18/MySQL%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL之隐式类型转换"><a href="#MySQL之隐式类型转换" class="headerlink" title="MySQL之隐式类型转换"></a>MySQL之隐式类型转换</h1><p>假设查询表tb001所有数据得到结果如下：</p><img src="image-20231218180933510.png" alt="image-20231218180933510" style="zoom:23%;"><p>那么执行<code>SELECT * FROM TB001 WHERE C1=1.1111</code>会是啥结果呢？</p><ul><li>选项1：返回所有记录</li><li>选项2：返回id为1的记录</li><li>选项3：不返回任何记录</li><li>选项4：以上都不对</li></ul><p>这似乎是个送分题，必须选2，真的如此么？<br>当表结构定义为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb001` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`c1` <span class="type">float</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><p>那么执行结果为：</p><img src="image-20231218183354819.png" alt="image-20231218183354819" style="zoom:33%;"><blockquote><p>因为float类型无法进行精确存储，所以无法进行精准的等值查询。</p></blockquote><p>当表结构定义为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb001` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `c1` <span class="type">DECIMAL</span>(<span class="number">18</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">0</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure><p>那么执行结果为：</p><img src="image-20231218192131166.png" alt="image-20231218192131166" style="zoom:33%;"><blockquote><p>decimal是可以精确存储的，所以可以进行精确的等值查询。</p></blockquote><p>通过上面的测试，发现列的类型不同，会影响到执行结果，那么假设表定于为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb001` (</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">`c1` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">KEY `IDX_C1` (`c1`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p> 查询表tb001所有数据得到结果如下：</p><img src="image-20231218192307105.png" alt="image-20231218192307105" style="zoom:23%;"><p>那么执行<code>SELECT * FROM TB001 WHERE C1=1.5;</code>会得到什么结果呢？</p><img src="image-20231218192342787.png" alt="image-20231218192342787" style="zoom:33%;"><p>上面的执行结果虽然有点出乎意料，但是也可以解释，把1.5四舍五入得到2，然后按照C1=2条件得到ID=2的记录。那么将等于改为小于等于呢？即<code>SELECT * FROM TB001 WHERE C1&lt;=1.5;</code>会得到什么结果呢？</p><img src="image-20231218192433253.png" alt="image-20231218192433253" style="zoom:33%;"><p>可以将上面的查询解释为把1.5强行转换为1，按照C1=1条件得到ID=1的记录。但上面两种解释有点冲突，如何选取呢？难道小于等于不包含等于么？</p><p>因为测试表数据仅有3行，全表扫描比索引查找更有效，于是删除C1上索引继续查询。</p><img src="image-20231218192553765.png" alt="image-20231218192553765" style="zoom:33%;"><p>可以惊奇地发现，查询结果又变了，对于等于查询，到底把1.5转换成什么数据呢？再看另外例子，假设测试数据脚本为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_user(</span><br><span class="line"> user_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line"> first_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"> last_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"> full_name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(first_name,last_name,full_name)<span class="keyword">VALUES</span>(<span class="string">&#x27;xiao&#x27;</span>,<span class="string">&#x27;ming&#x27;</span>,<span class="string">&#x27;xiao ming&#x27;</span>);</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(first_name,last_name,full_name)<span class="keyword">VALUES</span>(<span class="string">&#x27;zhang&#x27;</span>,<span class="string">&#x27;san&#x27;</span>,<span class="string">&#x27;zhang san&#x27;</span>);</span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_user(first_name,last_name,full_name)<span class="keyword">VALUES</span>(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;si&#x27;</span>,<span class="string">&#x27;li si&#x27;</span>);</span><br></pre></td></tr></table></figure><p> 全表数据为：</p><p> 全表数据为：</p><img src="image-20231218192703551.png" alt="image-20231218192703551" style="zoom:33%;"><p>然后想按照full_name进行查询：</p><img src="image-20231218192742493.png" alt="image-20231218192742493" style="zoom:33%;"><p>明明只是想查下全名叫”xiao ming”的用户，为啥全部返回呢？一定是打开方式不对，那么为啥不对呢？</p><p>在所有关系型数据库中，每个列都有类型定义，通过<code>CAST</code>或<code>CONVERT</code>函数可以将数据从一种类型转换为另外一种类型，如<code>SELECT CAST(&#39;2018-01-01&#39; AS DATETIME)</code>,被称为“<strong>显式类型转换</strong>“。与”显示类型转换“相对的是”<strong>隐式类型转换</strong>“，<strong>在按照时间字段进行查询时，我们通常会直接使用时间字符串作为参数，数据库会自动地将该字符串转换为时间类型，然后再与时间字段进行比较，这便是”隐式类型转换“。</strong></p><p>当在MySQL中对两种不同类型数据进行比较或计算时，就会导致类型转换，其中一部分类型转换属于正常操作，另外一部分就属于“异常操作”，如查询条件为<code>WHERE full_name=&#39;xiao&#39;+&#39; &#39;+&#39;ming&#39;</code>时，首先<strong>在MySQL中字符串不能使用+来连接，只有数值类型才能使用+来进行计算</strong>，因此MySQL会尝试把’xiao’/‘ ‘/‘ming’三个字符串转换为数字，转化失败就当做0来处理，因此’xiao’+’ ‘+’ming’的结果为0，然后再把full_name列和0做比较，由于full_name时VARCHAR，而0为数值，因此将full_name列转换为float，再次转换失败当做0来处理，因为0 = 0，所以所有记录都满足。</p><blockquote><p>当发生隐式类型转换且导致数据发生变化丢失时，查询不会抛出异常，仅会产生警告。如果上面的SELECT操作被修改为DELETE操作，则会导致全表数据被删除，忽略这些警告会导致故障被延期发现，从而引发更严重的问题。</p></blockquote><p><strong>MySQL发生隐式转换的规则如下：</strong></p><ol><li><strong>两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换</strong></li><li><strong>两个参数都是字符串，会按照字符串来比较，不做类型转换</strong></li><li><strong>两个参数都是整数，按照整数来比较，不做类型转换</strong></li><li><font color="cornflowerblue"><strong>十六进制的值和非数字做比较时，会被当做二进制串</strong></font></li><li><font color="cornflowerblue"><strong>有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp</strong></font></li><li><font color="cornflowerblue"><strong>有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较</strong></font></li><li><font color="cornflowerblue"><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></font></li></ol><p> 在上面的测试中，<font color="red"><strong>很多查询实际上是因为发生了隐式类型转换，数据被转换为浮点数进行比较，而浮点数最大的问题就是无法精确表示数据，也就无法“正确”地比较两个“浮点数”是否相同。</strong></font>如果表中数值列上有索引，那么即使需要对该列进行类型转换，也能使用索引来“优化查询”，上面示例中会将INT列隐式转换为“float”来进行比较，INT列是否存在索引会导致查询扫描全表数据或部分数据，最终导致查询差异。<br> 当数据列定于为FLOAT且不指定Float的长度和小数位数时，由于Float是浮点数，在MySQL中存储的是近似值，因此无法使用精确查找进行匹配，所以上面示例中WHERE C1=1.1111的执行返回数据为空，查询显示警告信息Empty set.</p><p>** float类型无法精确匹配的解决办法：**</p><ol><li>将Float数据类型转换为Double或Decimal数据类型,Decimal数据类型会保留准确精确度数据，而使用Double时不存在该问题。</li><li>为Float指定长度和小数位数。</li><li>使用FORMAT函数进行转换，如<code>WHERE FORMAT(C1,3)=FORMAT(123.456,3)</code>。</li><li>使用Like进行匹配,如<code>WHERE C1 LIKE 123.456</code>。</li></ol><h1 id="隐式类型转换与隐式字符编码转换对查询效率的影响"><a href="#隐式类型转换与隐式字符编码转换对查询效率的影响" class="headerlink" title="隐式类型转换与隐式字符编码转换对查询效率的影响"></a>隐式类型转换与隐式字符编码转换对查询效率的影响</h1><p>维护一个交易系统，交易记录表tradelog包含交易流水号(tradeid)、交易员id(operator)、交易时间(t_modified)等字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">&#x27;tradelog&#x27;</span> (</span><br><span class="line"><span class="string">&#x27;id&#x27;</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="string">&#x27;tradeid&#x27;</span> <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="string">&#x27;operator&#x27;</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="string">&#x27;t_modified&#x27;</span> datetime <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line"><span class="keyword">primary</span> key (<span class="string">&#x27;id&#x27;</span>),</span><br><span class="line">key <span class="string">&#x27;tradeid&#x27;</span> (<span class="string">&#x27;tradeid&#x27;</span>),</span><br><span class="line">key <span class="string">&#x27;t_modified&#x27;</span> (<span class="string">&#x27;t_modified&#x27;</span>)</span><br><span class="line">) engine <span class="operator">=</span> InnoDB <span class="keyword">default</span> charset <span class="operator">=</span> utf8mb4;</span><br></pre></td></tr></table></figure><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>交易编号<code>tradeid</code>字段上本身就有索引。但是explain这条语句后显示，这条语句走的时全表扫描。tradeid 的字段类型是varchar(32)，而输入的参数却是整型，所以需要做类型转换。</p><p><strong><font color="red">字符串与数字做比较的话，将字符串转换成数字。</font></strong></p><p>所以之前的语句被转换成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="built_in">CAST</span>(tradeid <span class="keyword">as</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></table></figure><p>这个会触发规则：<font color="red"><strong>对索引字段做函数操作，优化器会放弃走树搜索功能（即不走索引）。</strong></font><br>如果我们的语句是如下的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> id <span class="operator">=</span> &quot;83126&quot;;</span><br></pre></td></tr></table></figure><p>此时不会触发规则。因为字符串和数字比较，会将字符串转换成数字。现在字符串在比较符右边，只会把右边转换成数字，所以不会发生转换，所以仍然走树搜索。</p><h2 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h2><p>假设系统里有表trade_detail，用于记录交易细节。我们往交易日志表tradelog和交易详情表trade_detail这两个表里插入一些数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `trade_detail` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tradeid` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `trade_step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*操作步骤*/</span></span><br><span class="line">  `step_info` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="comment">/*步骤信息*/</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1000</span>, now());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;aaaaaaaa&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">&#x27;aaaaaaab&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;add&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;update&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;update again&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">&#x27;aaaaaaac&#x27;</span>, <span class="number">4</span>, <span class="string">&#x27;commit&#x27;</span>);</span><br></pre></td></tr></table></figure><p>调用该sql语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span> <span class="keyword">from</span> tradelog l,trade_detail d <span class="keyword">where</span> d.tradeid <span class="operator">=</span> l.tradeid <span class="keyword">and</span> l.id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>其执行步骤为：</p><ol><li>根据id在tradelog表里找到L2这一行；</li><li>从L2中取出tradeid字段的值；根据tradeid值到trade_detail表中查找条件匹配的行；</li><li>根据tradeid值到trade_detail表中查找条件匹配的行；</li></ol><p>该过程是通过遍历主键索引的方式，一个一个地判断tradeid地值是否匹配。</p><p>这里的第3步不符合我们的预期，因为trade_detail里tradeid字段是有索引的，我们本来是希望通过使用tradeid索引能够快速定位到等值的行。但是这里显然不是这样做的。</p><p>这是因为两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引。<br>将执行步骤的第三步单独拎出来改成SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> tradeid <span class="operator">=</span> $L2.tradeid.value;</span><br></pre></td></tr></table></figure><p><code>$L2.tradeid.value</code>的字符集是utf8mb4；utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是先将utf8转换成utf8mb4字符集，再做比较。也相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> trade_detail <span class="keyword">where</span> <span class="keyword">convert</span>(tradeid <span class="keyword">using</span> utf8mb4) <span class="operator">=</span> $L2.tradeid.value;</span><br></pre></td></tr></table></figure><p>这就会触发：<strong>对索引字段做函数操作，优化器会放弃树搜索功能。</strong></p><p><font color="cornflowerblue">这就是不同字符集连接查询，关联字段不走索引的原因。</font></p><p><font color="red"><strong>简而言之，一般来说 隐式类型转换 和 隐式字符编码转换 影响数据库查询性能的原因，就是因为在索引上发生了隐式类型转换或者隐式字符编码转换，实质上是在索引字段上需要执行函数，导致优化器不再走索引，最终影响了查询性能。</strong></font></p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.jianshu.com/p/b53975c53a3e">MySQL知识点之隐式类型转换</a></p><p><a href="https://codeleading.com/article/86055449559/">MySQL tips:隐式类型转换与隐式字符编码转换对查询效率的影响</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2023/12/05/E-R-Model/"/>
      <url>/2023/12/05/E-R-Model/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="1-数据库设计概述"><a href="#1-数据库设计概述" class="headerlink" title="1 数据库设计概述"></a>1 数据库设计概述</h2><h3 id="1-1何为数据库设计？"><a href="#1-1何为数据库设计？" class="headerlink" title="1.1何为数据库设计？"></a>1.1何为数据库设计？</h3><p>数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库及其应用系统，使之能够有效地存储数据，满足各种用户的应用需求（信息要求和处理要求）。</p><p>数据库是信息系统的核心和基础，它把信息系统中大量的数据按一定的模型组织起来，并提供存储、维护、检索数据的功能，最终使信息系统可以方便、及时、准确地从数据库中获得所需的信息。即数据库的设计目标是：为用户和各种应用系统提供一个信息基础设施和高效率的运行环境，这里的高效率代表的是冗余少、易维护和便于使用。</p><h4 id="数据库设计的全流程"><a href="#数据库设计的全流程" class="headerlink" title="数据库设计的全流程"></a>数据库设计的全流程</h4><img src="image-20231029111613780.png" alt="image-20231029111613780" style="zoom: 45%;"><blockquote><p><a href="https://www.cnblogs.com/blknemo/p/12416395.html#top">数据库三级模式二级映射</a></p></blockquote><p>数据库设计大致可分为如下几个阶段：</p><p><font color="red">需求分析 → <strong>概念设计</strong> → <strong>逻辑设计</strong> → <strong>物理设计</strong> → 数据库实施 → 运行与维护阶段</font></p><p><img src="v2-a7a07f6418d1d5fdc67d62982bd7bd31_1440w.png" alt="img"></p><p>设计数据库核心三个步骤：</p><ol><li>把现实世界的实体模型，通过建模转换成信息世界的E-R模型 – 概念结构设计；</li><li>信息世界的E-R模型，经过模型转化，得到数据库世界的数据模型 – 逻辑结构设计；</li><li>把数据模型进一步规范化，得到最终的数据库结构模型 – 物理结构设计；</li></ol><img src="image-20231205193612914.png" alt="image-20231205193612914" style="zoom:35%;"><blockquote><p>数据库世界的数据模型按数据的组织形式而分为三种类型：</p><ul><li>关系模型（在关系数据库设计中）</li><li>层次模型</li><li>网状模型</li></ul></blockquote><h3 id="1-2-必须要明确的几个概念"><a href="#1-2-必须要明确的几个概念" class="headerlink" title="1.2 必须要明确的几个概念"></a>1.2 必须要明确的几个概念</h3><p>本文主要讨论分析的数据库设计为关系型数据库，在正式开始了解数据库设计阶段之前先来明确几个关系型数据库的重要概念。</p><ul><li><strong>关系</strong> ：关系型数据库关系的数据结构就是一张二维表，通俗的讲，二维表名称就是关系名。</li><li><strong>属性</strong> ：二维表中的列称为属性（字段），每个属性都有一个属性名。</li><li><strong>域</strong> ：二维表中属性的取值范围称为域，每个属性都有一个域。</li><li><strong>关系模式</strong> ：二维表的结构称为关系模式。设关系名为 R，其属性为 A1，A2，…，An，则关系模式可以表示为：R(A1,A2,…,An)，一个具体的例子：职工（职工号，姓名，性别，部门）。</li><li><strong>候选码</strong> ：如果一个属性集的值能唯一标识一个关系的元组而又不含多余的属性，则称该属性集为候选码。在一个关系上可以有多个候选码。</li><li><strong>主属性</strong> ：包含在任一候选码中的属性。</li><li><strong>非主属性</strong> ：不包含在任一候选码中的属性。</li><li><strong>主键</strong> ：有时一个关系有多个候选码，可以选择其中一个作为主键。每个关系有且只有一个主键。</li><li><strong>外键</strong> ：如果关系模式 R 中的属性 K 是其他关系模式的主键，那么 K 在关系模式 R 中称为外键。</li></ul><h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2 需求分析"></a>2 需求分析</h2><p>需求分析的主要任务就是要通过详细调查现实世界中要处理的对象，来充分了解明确用户的各种需求，最终确定系统的功能，并且必须充分考虑系统在今后可能的扩充和改变，不能仅仅按当前应用需求来设计数据库。需求分析阶段的最终产物是要有明确的系统需求分析报告，一般会包括数据流图、功能模块图、数据字典等内容，并且它是指导开展数据库设计后续阶段活动的重要依据。</p><h2 id="3-概念设计"><a href="#3-概念设计" class="headerlink" title="3 概念设计"></a>3 概念设计</h2><h3 id="3-1-现实世界向机器世界的过渡"><a href="#3-1-现实世界向机器世界的过渡" class="headerlink" title="3.1 现实世界向机器世界的过渡"></a>3.1 现实世界向机器世界的过渡</h3><p>概念设计是设计形成一个独立于 DBMS 的概念数据模型，用来表述数据与数据之间的联系，它直接面向现实世界，因而很容易被用户所理解，方便用于数据库设计者与用户的交流。该阶段先设计与用户具体应用相关的数据结构——用户视图，然后再不断对视图进行集成修改，最终得到一个能正确、完整地反应该单位数据及联系并满足各种处理要求的数据模型，之后再把概念模型转换成具体机器上 DBMS 支持的数据模型。</p><p>概念设计的阶段的主要描述工具就是 E-R 模型（Entity-Relationship Model）。</p><h3 id="3-2-E-R-Model"><a href="#3-2-E-R-Model" class="headerlink" title="3.2 E-R Model"></a>3.2 E-R Model</h3><p>E-R模型（Entity-Relationship Model）是一种用于数据库设计的<a href="https://so.csdn.net/so/search?q=%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">概念模型</a>。它提供了一种描述现实世界中的数据组织和关联的图形化方法，用于表示 <strong>实体</strong>、<strong>属性</strong> 和 <strong>联系</strong> 之间的关系，简而言之，将现实世界的 <font color="red"><strong>实体模型通过建模转换为信息世界的概念模型</strong></font>，这个<a href="https://so.csdn.net/so/search?q=%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">概念模型</a>就是<strong>E-R模型</strong>。</p><h4 id="3-2-1-为什么要引入E-R图？"><a href="#3-2-1-为什么要引入E-R图？" class="headerlink" title="3.2.1 为什么要引入E-R图？"></a>3.2.1 为什么要引入E-R图？</h4><p>使用E-R模型有以下几个主要原因：</p><ul><li><strong>数据建模</strong>：E-R模型提供了一种直观且易于理解的方法来建模现实世界中的数据。通过将实体、属性和关系抽象成图形化符号，可以更好地捕捉和表示数据之间的关系和结构。</li><li><strong>数据可视化</strong>：E-R模型允许将数据的组织和关联可视化。通过图形表示，可以清晰地展示实体之间的关系、属性的特征以及它们之间的连接方式。</li><li><strong>数据完整性</strong>：E-R模型有助于确保数据的完整性。通过定义实体之间的关系和约束条件，可以确保数据在插入、更新和删除时保持一致性和正确性。</li><li><strong>查询优化</strong>：E-R模型可以帮助优化数据库查询。通过了解实体之间的关系，可以设计出更有效的查询和连接方式，提高查询性能和响应时间。E-R模型还可以指导索引的创建，以支持常见的查询操作。</li></ul><p>总的来说，E-R模型提供了一种直观和规范的方法来描述和设计数据库。它有助于提高数据库设计的质量、数据的完整性和查询的性能，从而提升整个数据库系统的效率和可靠性。</p><h4 id="3-2-2-E-R图的构成"><a href="#3-2-2-E-R图的构成" class="headerlink" title="3.2.2 E-R图的构成"></a>3.2.2 E-R图的构成</h4><ul><li><p><strong>实体</strong>（Entity）：实体表示现实世界中的一个独立对象，可以是人、物、地点、概念等。在E-R图中，实体用矩形框表示，框内写上实体的名称。</p></li><li><p><strong>属性</strong>（Attribute）：属性是描述实体特征的信息。每个实体可以有多个属性，例如一个人实体可以有姓名、年龄、性别等属性。属性以椭圆形状表示，并与相应的实体相连。<strong>其中能够唯一标识实体的属性称为主键</strong>。</p><blockquote><p>实体和属性的划分原则：为了简化E-R图的的处理，现实世界中能作为属性的尽量作为属性值。属性如果还有对应的属性进行描述，那就可以将该属性上升为实体。</p></blockquote><img src="v2-8f3b6cd1d600a3c30a809b1d78532641_1440w.png" alt="img" style="zoom:67%;"><p>这张图描述了一个教师的实体对象以及它拥有的姓名、性别等属性，是对现实世界信息的直观描述。</p><p>某些属性还可以划分具有独立意义的子属性，那这类属性就称为<strong>复合属性</strong>。例如人的姓名可划分为“姓”和“名”；地址属性可以划分为邮政编码、省名、市名、区名和街道这些子属性，而街道又可划分为街道名和门牌号，其层次结构如下：</p><img src="v2-6796c23a620b58fef1161a0a81ea876f_1440w.png" alt="img" style="zoom:67%;"><p>复合属性的用途有两个：</p><ul><li>准确模拟现实世界的复合信息结构；</li><li>当用户需要把复合属性作为一个整体使用又需要单独使用各子属性时，属性的复合结构就显得十分重要。</li></ul><p>例如发邮件时称呼对方可能只需要复合属性“姓名”中的“姓”就足够了。</p><p>属性按照取值的个数还可以分为<strong>单值属性</strong>和<strong>多值属性</strong>。单值属性是指此属性对于同一个实体只能取一个值，大多数的属性都属于单值属性，例如同一个人只能具有一个年龄和一种性别。但是在某些情况下，实体的属性可能取多个值，这时候的属性就称为多值属性，例如人的联系方式信息就是一个多值的，有的人有 1 个电话，有的人有 2 个或者 3 个等等，或者可以分为移动电话联系方式、固定电话联系方式和邮件联系方式等。</p><p>注意：多值属性的描述与单值属性不一致，它采用双线椭圆表示，并且在实际开发过程中，如果有多值属性出现，一般要将其另归为实体或联系。</p><img src="image-20231205181632978.png" alt="image-20231205181632978" style="zoom:40%;"><p>实体属性之间可能具有某种联系，例如人的年龄属性和出生日期有一种相互依赖关系，根据出生日期可以推导出人的年龄，我们就称年龄为<strong>导出属性</strong>或派生属性。导出属性不仅可以从另外的属性中导出，也可以从相关的实体导出。例如一个公司实体的员工数量属性的值可以通过累计该公司所有员工数得到。</p><p>还有一种属性称为<strong>可选属性</strong>，即并不是所有的属性都必须有值，有些属性的可以没有值，这就是可选属性，在椭圆的文字后用“（O）”来表示。</p></li><li><p><strong>关系</strong>（Relationship）：关系表示实体之间的相互作用或联系。关系可以是一对一、一对多或多对多的。在E-R图中，关系用菱形表示，并与相关的实体相连。关系还可以具有属性，用于描述与关系相关的信息。</p></li><li><p><strong>主键</strong>（Primary Key）：用于唯一标识实体的属性，通常在实体框内用下划线或加粗表示。主键属性的值在整个实体集合中必须是唯一的，用于区分不同的实体。</p></li></ul><h3 id="3-2-3-实体间的联系"><a href="#3-2-3-实体间的联系" class="headerlink" title="3.2.3 实体间的联系"></a><strong>3.2.3 实体间的联系</strong></h3><p><strong>（1）联系的种类</strong></p><p>现实世界中，事物内部或事物之间总是有联系的，联系反映了实体内部或实体之间的关系。</p><p>联系的度数指的是一个联系所涉及的实体数。比如：<strong>单实体联系</strong>、<strong>两实体联系</strong>和<strong>多实体联系</strong>。</p><p>比较常见的为两实体联系，两个实体之间可能存在以下联系：</p><ul><li>一对一联系（1 : 1），例如部门和负责人之间的联系，一个部门有一个负责人，一个负责人负责一个部门；</li><li>一对多联系（1 : n），例如部门和员工之间的联系，一个部门有多个员工，而每个员工只属于一个部门；</li><li>多对多联系（m : n），例如项目和员工之间的联系，一个项目可以需要多个员工参加，而一个员工也可以参加多个项目。</li></ul><p>联系一般使用菱形来进行描述，上面的这几种联系可用如下 E-R 图来表示。</p><img src="v2-e021393b3ea29c9893bf6fd9e7a6c800_1440w.png" alt="img" style="zoom:70%;"><p>在E-R图中，<font color="red">关系也可以具有与之相关的属性</font>，用于描述与该关系相关的信息。这些属性可以提供更详细的关系描述，以补充关系本身无法完全表达的信息。 比如职工与部门的工作关系，这个关系可以具有属性，如工作时间、工作性质。通过关系的属性以便于更好的描述职工在部门中的工作情况。</p><img src="image-20231205144615307.png" alt="image-20231205144615307" style="zoom:25%;"><blockquote><p>我们通过一个例子来加深印象：</p><p>让我们来设计一个简单的 E-R 图来表示学生和课程之间的关系。假设我们有两个实体：学生（Student）和课程（Course）。一个学生可以注册多门课程，而一门课程可以有多名学生。</p><p>设计过程如下：</p><ol><li>确定实体（Entities）：<ol><li>学生（Student）：属性包括学生ID（Student ID）、姓名（Name）、年级（Grade）等。</li><li>课程（Course）：属性包括课程ID（Course ID）、课程名称（Course Name）、学分（Credit）等。</li></ol></li><li>确定关系（Relationship）：<ol><li>注册（Enrollment）：学生和课程之间的关系。这是一个多对多的关系，因为一个学生可以注册多门课程，而一门课程可以有多名学生。此关系可以具有属性，如选课日期（Enrollment Date）。</li></ol></li><li>确定主键（Primary Key）：<ol><li>学生实体的主键为学生ID（Student ID）。</li><li>课程实体的主键为课程ID（Course ID）。</li></ol></li></ol><p>E-R图如下：</p><img src="image-20231205144943835.png" alt="image-20231205144943835" style="zoom:50%;"></blockquote><p>E-R图进阶<br>4.1弱实体<br>想象一下，在数据库中，实体就像是人或物体，而属性就像是这些人或物体的特征。通常情况下，一个实体具有自己的标识，例如一个人有独特的身份证号码，一个产品有独特的产品编号。</p><p>然而，有时候存在一种情况，某个实体的标识依赖于与其相关联的另一个实体。这时，我们称这个实体为弱实体。弱实体没有自己的唯一标识，它的标识需要依赖于与其相关联的另一个实体（强实体）。</p><p>在 E-R 图中，弱实体通常用双矩形框表示。</p><blockquote><p>我们来举一个例子：</p><p>订单小票和订单项（也就是小票上面的每个商品多少钱的那一项）之间的E-R图。</p><img src="image-20231205145123708.png" alt="image-20231205145123708" style="zoom:50%;"><p>订单项并不是一个单独存在的实体，而是基于订单小票才会产生的一个实体，所以我们把它划分为弱实体。</p></blockquote><h3 id="4-2部分键"><a href="#4-2部分键" class="headerlink" title="4.2部分键"></a>4.2部分键</h3><p>在 E-R 图中，弱实体通常没有自己的唯一标识，因此需要使用弱实体的<strong>部分键</strong>来唯一标识不同的实例。弱实体的部分键是通过指定其中一个属性与父实体的键结合从而形成相应弱实体的键，弱实体的这个属性称为弱实体的部分键。部分键用虚线标识。</p><blockquote><p>我们来举一个例子：</p><p>还是订单小票和订单项（也就是小票上面的每个商品多少钱的那一项）之间的E-R图。</p><img src="image-20231205145236301.png" alt="image-20231205145236301" style="zoom:50%;"><p>这是我们上面的图片，我们基于这个进行一个拓展，把订单项这个弱实体中的部分键标识出来。</p><img src="image-20231205145459734.png" alt="image-20231205145459734" style="zoom:50%;"><p>我们只有通过商品ID与订单ID结合才能找到某一个订单项。 所以我们可以把商品ID定为部分键。</p></blockquote><h3 id="3-5-E-R-模型的集成"><a href="#3-5-E-R-模型的集成" class="headerlink" title="3.5 E-R 模型的集成"></a><strong>3.5 E-R 模型的集成</strong></h3><p>由于局部 E-R 模型反映的只是局部子功能对应的数据视图，且局部 E-R 图之间可能存在不一致之处，还不能作为逻辑设计的依据，此时可以进行 E-R 模型的集成，去掉不一致和重复的地方，最终合并为全局视图。局部 E-R 模型的集成方法有如下两种：</p><ul><li>多元集成法：一次性将多个局部 E-R 图合并为一个全局 E-R 图；</li><li>二元集成法：用累加的方式一次集成两个局部 E-R 图。</li></ul><p>在实际应用中一般根据系统的复杂程度选择集成的方法，也可以混合使用。无论采用哪种集成方法，每次集成都分为两个阶段：</p><ol><li>合并：消除局部 E-R 图之间的冲突，生成初步 E-R 图；</li><li>优化（修改与重构）：消除（或减少）数据冗余，生成全局 E-R 图。</li></ol><img src="image-20231206161938959.png" alt="image-20231206161938959" style="zoom:40%;"><h3 id="3-5-1-合并"><a href="#3-5-1-合并" class="headerlink" title="3.5.1 合并"></a><strong>3.5.1 合并</strong></h3><p>由于各个局部应用所面临的问题不同，且通常是由不同的设计人员进行局部 E-R 图的设计，这就导致各个局部 E-R 图之间必定存在许多不一致的地方，即存在冲突。冲突主要分为三类：<strong>属性冲突</strong>、<strong>命名冲突</strong>和<strong>结构冲突</strong>。</p><p><strong>（1）属性冲突</strong></p><ol><li><strong>属性域冲突，即属性值的类型、取值范围不一致</strong>。例如，员工的工号是使用数值型还是字符型。</li><li><strong>属性取值冲突</strong>。例如，学生的成绩有的以百分制计，有的以五分制计。</li></ol><blockquote><p>这类冲突是由于用户在业务上的约定而引起，必须由用户协商解决。</p></blockquote><p><strong>（2）命名冲突</strong></p><ol><li><strong>同名异义：不同意义的对象在不同的局部应用中具有相同的名字</strong>。例如，“单位”既可以表示人员所在部门，也可以作为长度、重量等度量的属性。</li><li><strong>异名同义：同一意义的对象在不同的局部应用中具有不同的名字</strong>。例如学校的“系别”与“学院”实际上是同一实体。</li></ol><blockquote><p>命名冲突可能发生在实体、属性和联系上，常见的为属性冲突，这类冲突通常可以采取行政手段进行协商解决。</p></blockquote><p><strong>（3）结构冲突</strong></p><ol><li><p><strong>同一对象在不同局部应用中具有不同的身份</strong>。例如：局部模型A中的某实体在另一局部模型 B 中被设计为属性，这就造成了结构上的冲突。</p><p>解决方法：将实体转化为属性或将属性转化为实体，保持结构的统一。</p></li><li><p><strong>同一对象在不同局部应用中的属性组成不完全相同</strong>。例如，对同一类“员工”这一对象，在局部模型 A 中其属性为工号、姓名、性别、年龄4个属性，而在另一局部模型 B 中的属性为工号、姓名、所在部门 3 个属性组成。</p><p>解决方法：对实体的属性取其在不同局部应用中的并集，并适当设计好属性的次序。</p></li><li><p><strong>相同实体之间的联系在不同局部模型中不一致</strong>。例如，在局部应用 A 中实体 E1 和 E2 是一对多联系，而在局部应用 B 中却是多对多联系。</p><p>解决方法：根据应用语义对实体联系的类型进行综合或调整。</p></li></ol><p><strong>Demo</strong>：将E-R1和E-R2进行合并。</p><img src="image-20231206164149673.png" alt="image-20231206164149673" style="zoom:40%;"><p>将E-R1图中产品-零件的关系平移到E-R2图中，出现“数量”这个属性的命名冲突（同名异义），分别对其进行重命名为“数量1”和“数量2”。</p><h3 id="3-5-2-优化"><a href="#3-5-2-优化" class="headerlink" title="3.5.2 优化"></a><strong>3.5.2 优化</strong></h3><p><font color="red"><strong>数据冗余</strong></font> 和 <font color="red"><strong>联系冗余</strong></font> 是 E-R 模型的主要冗余问题，<font color="cornflowerblue">能被其他数据推导（派生）出来的数据就是冗余数据</font>，<font color="cornflowerblue">能被其他联系推导（派生）出来的联系就是冗余联系</font>。例如，员工实体同时具有“出生年月”和“年龄”属性，“年龄”可以从“出生年月”中推导出来，因此是冗余数据。</p><p>冗余的存在容易破坏数据的完整性，造成数据库的维护困难，应予以消除。可以利用多种方法来消除冗余，在关系型数据库中更常用规范化理论来进行分析。</p><p><strong>Demo</strong>：如图，Q3 = Q1 * Q2，Q4 = ∑Q5，所以Q3和Q4是冗余数据，可以删除。并且由于Q3删除，产品与材料间的m:n的冗余关系也应删除。</p><blockquote><p>在实际开发中，并不一定要严格删除冗余，而应该以业务场景为准，有时适当的冗余可以提升业务代码的性能和数据的可读性，并且可以降低数据库层代码复杂度。</p></blockquote><img src="image-20231206170002065.png" alt="image-20231206170002065" style="zoom:35%;"><h2 id="4-逻辑结构设计"><a href="#4-逻辑结构设计" class="headerlink" title="4 逻辑结构设计"></a>4 逻辑结构设计</h2><p>逻辑结构设计即将E-R图转换为关系模式。</p><p>关系模型<br>3.1 常用概念</p><ul><li>关系：可以理解为一张二维表，每个关系都具有一个关系名，也就是通常说的表名（table）；</li><li>元组：可以理解为二维表中的一行，在数据库中经常被称为记录（record）；</li><li>属性：可以理解为二维表中的一列，在数据库中经常被称为字段（colum）；</li><li>域：属性的取值范围，也就是数据库中某一列的取值限制；</li><li>关键字：一组可以唯一标识元组的属性，数据库中常称为主键，由一个或多个列组成（key）；</li><li>关系模式：指对关系的描述，其格式为：关系名(属性1,属性2,……,属性N)，在数据库中成为表结构；</li></ul><h3 id="3-2-E-R图转关系模式"><a href="#3-2-E-R图转关系模式" class="headerlink" title="3.2 E-R图转关系模式"></a>3.2 E-R图转关系模式</h3><p>对于E-R图中每个<code>实体</code>，都应转换为一个<code>关系</code>（table）。</p><p>该关系应包括<strong>对应实体的全部属性</strong>，并应根据关系所表达的语义确定哪个属性或哪几个属性组作为<code>关键字</code>，关键字用下划线标识；</p><h4 id="3-2-1-一对一关系"><a href="#3-2-1-一对一关系" class="headerlink" title="3.2.1 一对一关系"></a>3.2.1 一对一关系</h4><p>比如：一个班级对应一个正班长，就是<code>1:1</code>联系</p><img src="image-20231205202553302.png" alt="image-20231205202553302" style="zoom:30%;"><p>则可以创建两个关系（表），一个班级关系（表），一个学生关系（表）；然后我们需要一个联系（关联）来连接这两个关系（表）。有两种方案：</p><ol><li><strong>联系不单独对应一个关系（表）</strong>：<font color="red">联系的属性和一端实体的主键加入另一端实体的关系模式中</font>。<br>不单独创建一个关系（表）来存储联系，通俗讲就是在一个表中冗余一个字段存另外一个表的主键。<br>比如：在学生关系（表）中添加一个班级编号属性，用来存储班级关系中的班级编号属性值，或者在班级关系（表）中添加一个学号属性，用来存储学生关系中的学号属性值。</li><li><strong>联系单独对应一个关系</strong>：<font color="red">由联系的属性和两端实体主键构成新关系模式，选择任一端实体的主键作为主键</font>。<br>单独创建一个关系（表）来存储联系，通俗讲就是创建一个中间表用来存储两个或多个表的主键。<br>比如：创建一个联系关系（表）来存储<u>班级编号</u>属性和<u>学号</u>属性，并选择一个主键（班级编号或学号）作为联系关系的主键。</li></ol><p>3.2.2 一對多关系<br>班级关系和学生关系之间的联系是1:n。</p><img src="image-20231205203501864.png" alt="image-20231205203501864" style="zoom:35%;"><p>同样地也有两种关系模式:</p><ol><li><strong>联系不单独对应一个关系</strong>：<font color="red">将联系的属性和<code>1端</code>的主键加入<code>n端</code>的实体对应的关系模式中</font>。<br>在这种1:n的关系模式中，一般都是将<code>1端</code>的主键加入<code>n端</code>关系中，即在学生关系（表）中增加一个班级属性，存储对应的班级属性值。</li><li><strong>联系单独对应一个关系</strong>：<font color="red">由联系的属性和两端实体主键构成新关系模式，<code>n端</code>的主键作为该关系模式的主键</font>。<br>单独创建一个联系关系（表）来存储<u>班级编号</u>属性和<u>学号</u>属性，并选择<code>n端</code>的主键（<u>学号</u>）作为联系关系的主键。</li></ol><p>多对多关系<br>学生关系和课程关系之间的联系是m:n</p><img src="image-20231205204433994.png" alt="image-20231205204433994" style="zoom:30%;"><p>这种<code>m:n</code>的关系只有一种关系模式：</p><ul><li><strong>联系单独对应一个关系</strong>：<font color="red">由联系的属性和参与联系的各个实体的主键属性构成新关系模式，该关系模式的主键由各实体的主键共同组成</font>。<br>单独创建一个联系关系（表）来存储<u>课程号</u>属性和<u>学号</u>属性和成绩属性，联系关系的主键是<u>课程号</u>和<u>学号</u>组成的联合主键。</li></ul><h4 id="逻辑结构设计Demos"><a href="#逻辑结构设计Demos" class="headerlink" title="逻辑结构设计Demos"></a>逻辑结构设计Demos</h4><p>Demo1：将教学管理<a href="https://so.csdn.net/so/search?q=ER%E5%9B%BE&spm=1001.2101.3001.7020">ER图</a>转换为关系模式</p><p><img src="20150728110504289.jpeg" alt="img"><br>(1)把三个实体类型转换成三个模式：<br>　　 ①系（系编号，系名，电话）<br>　　 ②教师（教工号，姓名，性别，职称）<br>　　 ③课程（课程号，课程名，学分）<br>(2)对于1:1联系“主管”，可以在“系”模式中加入教工号（教工号为外键）。对于1:N联系“聘任”，可以在“教师”模式中加入系编号（系编号为外键）。对于1:N联系“开设”，可以在“课程”模式中加入系编号（系编号为外键）。</p><ul><li>　　 ①系（系编号，系名，电话，主管人的教工号）</li><li>　　 ②教师（教工号，姓名，性别，职称，系编号）</li><li>​    ③课程（课程号，课程名，学分，系编号）</li></ul><p>(3)第三步：对于M:N联系“任教”，则生成一个新的关系模式：<br>　　 ①任教（教工号，课程号，教材）<br>(4)这样，转换成的四个关系模式如下：<br>　　 ①系（系编号，系名，电话，主管人的教工号）<br>　　 ②教师（教工号，姓名，性别，职称，系编号）<br>　　 ③课程（课程号，课程名，学分，系编号）<br>　　 ④任教（教工号，课程号，教材）</p><p>Demo2：一元联系类型ER图结构转换为关系模式</p><p><img src="20150728110526893.jpeg" alt="img"><br>(1)运动员名次之间存在着1:1联系<br>　　 ①运动员（编号，姓名，性别，名次，上一名次编号）<br>(2)职工之间存在上下级联系，即1:N联系<br>　　 ①职工（工号，姓名，年龄，性别，经理工号）<br>(3)工厂的零件之间存在着组合关系（M:N联系）<br>　　 ①零件（零件号，零件名，规格）<br>　　 ②组成（零件号，子零件号，数量）</p><p>Demo3：三元联系的ER图结构转换为关系模式</p><p><img src="20150911234021180.jpeg" alt="img"><br>　　 ①仓库（仓库号，仓库名，地址）<br>　　 ②商店（商店号，商店名）<br>　　 ③商品（商品号，商品名）<br>　　 ④进货（商店号，商品号，仓库号，日期，数量）</p><h2 id="5-数据库设计规范化"><a href="#5-数据库设计规范化" class="headerlink" title="5 数据库设计规范化"></a>5 数据库设计规范化</h2><blockquote><p>数据库三大范式包含：1、第一范式(1NF)；2、第二范式(2NF)；3、第三范式(3NF)。其中，第一范式(1NF)的要求是属性不可分割;第二范式(2NF)的要求是满足第一范式，且不存在部分依赖；第三范式(3NF)的要求是满足第二范式，且不存在传递依赖。</p></blockquote><p><strong>明确一点：数据库设计时不是说遵循的范式等级越好就越好，范式越好就越牺牲数据库的性能，应该是实际业务场景为准。</strong></p><h4 id="1、第一范式-1NF"><a href="#1、第一范式-1NF" class="headerlink" title="1、第一范式(1NF)"></a>1、第一范式(1NF)</h4><p>所谓第一范式（1NF）是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即<font color="cornflowerblue">数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项</font>。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。</p><blockquote><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。</p></blockquote><p>特点：属性不可分割，即<font color="red">每个属性都是不可分割的原子项</font>。(实体的属性即表中的列)</p><p>Demo如下图中的Address属性就不满足第一范式，可以将Address拆分为Country和Address属性。</p><img src="image-20231205210959289.png" alt="image-20231205210959289" style="zoom:25%;"><h4 id="2、第二范式-2NF"><a href="#2、第二范式-2NF" class="headerlink" title="2、第二范式(2NF)"></a>2、第二范式(2NF)</h4><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）。</p><blockquote><p>能够唯一表示实体的属性集称为码，主码即主键。</p></blockquote><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）<font color="cornflowerblue">要求实体的属性完全依赖于主关键字</font>。<strong>所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。</strong>为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。</p><p><strong>教材定义：在满足第一范式的条件下，每一个非主属性完全函数依赖于任何一个候选码。</strong></p><p>特点：</p><ul><li>满足第一范式；</li><li>第二范式需要确保数据表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言），<font color="red">每张表只描述一件事情</font>；</li><li><font color="red">消除部分依赖，要求表中的每一列都完全依赖于主键（针对于组合主键），也就是不会出现某一列只和部分主键相关</font>。</li></ul><p>Demo1：“学分”字段完全依赖于“课程名称”字段，而不是依赖于主键“学号”字段，所以不符合第二范式，将“学分”字段删除之后就符合了。</p><img src="image-20231205213614147.png" alt="image-20231205213614147" style="zoom:55%;"><p>Demo2：每个表只描述一件事。</p><p>原始订单表中的“产品名称”和“规格”是依赖“产品编号”字段的，不符合第二范式，对其进行拆分为订单表和产品表，订单表中只有订单相关信息，产品表中只有产品相关信息，让每一个表只描述一件事情。</p><img src="image-20231205214852663.png" alt="image-20231205214852663" style="zoom:40%;"><h4 id="3、第三范式-3NF"><a href="#3、第三范式-3NF" class="headerlink" title="3、第三范式(3NF)"></a>3、第三范式(3NF)</h4><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）。</p><p>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。第三范式（3NF）<font color="red">要求一个关系中不包含已在其它关系已包含的非主关键字信息。</font>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是任意属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</p><p><strong>教材定义：在满足第二范式的条件下，每一个非主属性既不依赖传递于码，也不部分依赖于码</strong>。</p><p>特点：</p><ul><li>前提：满足第一范式和第二范式；</li><li>第三范式需要确保数据表中的每一列数据表和主键直接相关，而不能间接相关；</li><li>消除传递依赖，要求一张表中的每一列都和主键是直接依赖的，不是间接依赖，即任何两个非主键字段数值之间不存在函数依赖关系。</li></ul><p>Demo：订单表中的“总金额字段” = “单价” * “数量”，不符合第三范式，去掉“总金额”字段才符合。</p><blockquote><p>PS：其实这个订单表不符合第二范式，“单价”字段是依赖于“产品编号”字段，而不是主键“订单编号”。</p></blockquote><img src="image-20231205220043287.png" alt="image-20231205220043287" style="zoom:40%;"><blockquote><h4 id="巴斯-科德范式（BCNF）"><a href="#巴斯-科德范式（BCNF）" class="headerlink" title="巴斯-科德范式（BCNF）"></a>巴斯-科德范式（BCNF）</h4><p>3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除主属性对主码子集的依赖）。巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。</p></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/m0_63006478/article/details/130952118">一文讲透实体-联系模型（E-R图）</a></p><p><a href="https://blog.csdn.net/qq_31856061/article/details/134558146">E-R图与关系模式</a></p><p><a href="https://worktile.com/kb/ask/30501.html">数据库三大范式</a></p><p><a href="https://blog.csdn.net/Flora_SM/article/details/84645752?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-84645752-blog-134558146.235%5Ev39%5Epc_relevant_3m_sort_dl_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-84645752-blog-134558146.235%5Ev39%5Epc_relevant_3m_sort_dl_base2&utm_relevant_index=5">E-R图向关系模型的转换实例详解</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> E-R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2023/11/07/Maven/"/>
      <url>/2023/11/07/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven-是什么"><a href="#Maven-是什么" class="headerlink" title="Maven 是什么"></a>Maven 是什么</h2><p>Maven 是一个项目管理工具，它包含了一个<strong>项目对象模型（Project Object Model）</strong>，反映在配置中，就是一个 pom.xml 文件。它是一组标准集合，一个项目的生命周期、一个依赖管理系统，另外还包括定义在项目生命周期阶段的插件(plugin)以及目标(goal)。</p><p>当我们使用 Maven 的使用，通过一个自定义的项目对象模型pom.xml 来详细描述我们的项目。</p><p><strong>Maven 中的有两大核心：</strong></p><p><font color="red"><strong>依赖管理</strong></font>：对 jar 的统一管理(Maven 提供了一个 Maven 的中央仓库<a href="https://link.zhihu.com/?target=https://mvnrepository.com/%EF%BC%8C%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%AE%8C%E4%BE%9D%E8%B5%96%E4%B9%8B%E5%90%8E%EF%BC%8CMaven">mvnrepository.com/</a> ，当我们添加完对应的依赖Maven就会自动去中央仓库下载相关的依赖，并且解决依赖的依赖问题)。</p><p><font color="red"><strong>项目构建</strong></font>：对项目进行编译、测试、打包、部署、上传到私服等。</p><h2 id="为什么使用-Maven"><a href="#为什么使用-Maven" class="headerlink" title="为什么使用 Maven"></a>为什么使用 Maven</h2><p>由于 Java 的生态非常丰富，无论你想实现什么功能，都能找到对应的工具类，这些工具类都是以 jar 包的形式出现的，而jar 包之间会有关联，在使用一个依赖之前，还需要确定这个依赖所依赖的其他依赖，所以，当项目比较大的时候，依赖管理会变得非常麻烦臃肿，这是 Maven 解决的第一个问题。</p><p>Maven 还可以处理多模块项目。简单的项目，单模块分包处理即可，如果项目比较复杂，要做成多模块项目，例如一个电商项目有订单模块、会员模块、商品模块、支付模块…，一般来说，多模块项目，每一个模块无法独立运行，要多个模块合在一起，项目才可以运行，这个时候，借助 Maven 工具，可以实现项目的一键打包。</p><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><table><thead><tr><th align="center">仓库类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">本地仓库</td><td align="center">就是电脑上的本地目录，每台电脑上都一个本地仓库，默认地址：<code>当前用户名\.m2\repository</code></td></tr><tr><td align="center">私服仓库</td><td align="center">一般来说都是公司内部搭建的Maven仓库（也称为 二方库），处于局域网中，访问速度快，<br>这个仓库中存放的jar包一般都是公司内部自己开发或者二次开发封装的jar包</td></tr><tr><td align="center">中央仓库</td><td align="center">由Apache团建维护，包含了市面上绝大部分的jar包</td></tr></tbody></table><p>三个仓库的查找顺序：</p><img src="image-20231109140408359.png" alt="image-20231109140408359" style="zoom: 40%;"><p>实际上，没有特殊需求的话，Maven安装好之后直接就可以用了。一般来说，还是需要稍微配置一下，比如：中央仓库的问题。默认使用 Maven 自己的中央仓库，使用起来网速比较慢，这个时候，可以通过修改配置文件，将仓库改成国内的镜像仓库，国内仓库使用较多的是阿里巴巴的仓库。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本地仓库默认位置在 <code>当前用户名\.m2\repository</code>，这个位置可以自定义，但是不建议大家自定义这个地址，有几个原因：</p><ol><li>虽然所有的本地的 jar 都放在这个仓库中，但是并不会占用很大的空间。</li><li>默认的位置比较隐蔽，不容易碰到</li></ol><p>技术上来说，当然是可以自定义本地仓库位置的，在 <code>conf/settings.xml</code> 中自定义本地仓库位置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在 cmd 中敲并回车执行：<code>mvn help:system</code></p><p>首次执行 mvn help:system 命令，Maven会自动帮我们到Maven中央仓库下载缺省的或者Maven中央仓库更新的各种配置文件和类库（jar包）到Maven本地仓库中。</p></blockquote><h2 id="Maven的核心概念"><a href="#Maven的核心概念" class="headerlink" title="Maven的核心概念"></a>Maven的核心概念</h2><h3 id="GAV坐标"><a href="#GAV坐标" class="headerlink" title="GAV坐标"></a><strong>GAV坐标</strong></h3><p>在平面几何中坐标（x,y）可以标识平面中唯一的一点。在maven中坐标就是为了定位一个唯一确定的jar包。Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范，拥有了统一规范，就可以把查找工作交给机器。</p><p>Maven坐标主要组成(GAV) ：</p><p><strong>【G】groupId</strong>：定义当前Maven组织名称; </p><p><strong>【A】artifactId</strong>：定义实际项目名称; </p><p><strong>【V】version</strong>：定义当前项目的版本;</p><p> <strong>GAV坐标的作用：确定一个jar包在互联网上的位置。</strong></p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><h4 id="scope-依赖范围"><a href="#scope-依赖范围" class="headerlink" title="scope 依赖范围"></a>scope 依赖范围</h4><img src="image-20231109144335879.png" alt="image-20231109144335879" style="zoom:45%;"><p>其中依赖范围 scope 标签用于控制依赖的范围，即指定依赖的有效范围，以便在不同的环境下进行不同的构建或部署：</p><ul><li><strong>compile</strong>： <strong>默认</strong>是编译依赖范围。对于编译，测试，运行三种classpath都有效；</li><li><strong>test</strong>：测试依赖范围。只对于测试classpath有效；</li><li><strong>provided</strong>：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。</li><li><strong>runtime</strong>：运行时范围。项目打包运行时才有效,例如:jdbc驱动；</li><li>system：类似 provided，但需要显式地指定依赖的路径或文件。</li><li>import：该 scope 只用于在 pom.xml 中使用 dependencyManagement 元素来管理依赖版本号，不会实际被引入到项目中。</li></ul><p><strong>Demo | provided用法</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常情况下，lombok 依赖的 scope 被定义为 provided。这是因为 lombok 库在编译时需要在 classpath 中存在，但在运行时不需要被打包到部署包中，因为它只是一个编译时工具库（在编译的完成之后，该工具包的作用就已经结束了）。通过编译lombok注解的得到的Class类可以看出来，编译之后对应的lombok的注解都已经被同化为JDK的原生Java代码了，也就是说编译完成之后，使用lombok的注解就可以直接运行了，而不再依赖lombok。因此，将其设置为 provided 可以避免将不必要的 jar 包打包到部署包中，从而减小部署包的大小。同时，在使用 lombok 时，需要将其添加到 IDE 或编译器的插件中，以确保在编译时正常使用 lombok 注解。</p><p><strong>Demo | import + <code>&lt;dependencyManagement&gt;</code>用法</strong></p><p>Maven 的 <a href="https://so.csdn.net/so/search?q=dependencyManagement&spm=1001.2101.3001.7020">dependencyManagement</a> 元素用于管理项目的依赖版本号，它可以集中管理项目的依赖版本号，避免在多个模块中重复声明版本号，同时方便版本的统一升级。如某版本的<a href="https://so.csdn.net/so/search?q=spring-boot-starter-parent&spm=1001.2101.3001.7020">spring-boot-starter-parent</a>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自己的项目在使用spring-boot-starter-parent作为parent，同时在需要使用这些依赖的子模块中，不需要再指定依赖的版本号，只需要声明对应的 groupId 和 artifactId。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，子模块会自动使用父 POM 中声明的版本号来获取依赖。如果需要升级依赖的版本，只需要在父 POM 中修改对应的版本号即可，所有子模块都会自动继承这个版本号。</p><p>另外，如果某个子项目需要特定另外的一个版本，只需要添加version标签元素进行声明即可, 会自动覆盖版本 - <strong>就近原则</strong>。</p><blockquote><p>注意，dependencyManagement 只是用于管理依赖版本号，它并不会引入实际的依赖。如果需要在子模块中引入依赖，还需要在 dependencies 元素中声明具体的依赖信息。</p></blockquote><p>如果子模块作用域是import：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 scope 被设置为 import，这些依赖也不会被实际引入到子模块中，而是只用于管理版本号。</p><h4 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h4><p>如果想进行依赖传递，最好将所有的依赖的范围都设定为默认的compile级别，依赖传递分为两种：</p><ul><li><strong>直接依赖</strong></li><li><strong>间接依赖</strong></li></ul><p>例如：test2 依赖 test1，test3依赖test2，则test2 直接依赖 test1，test3间接依赖test1；依赖关系图如下：</p><img src="image-20231109150716918.png" alt="image-20231109150716918" style="zoom:45%;"><blockquote><p>当第二直接依赖的范围是compile的时候，依赖可以传递；当第二直接依赖的范围是test的时候，依赖不会传递。</p></blockquote><h4 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h4><p>假如test1使用junit4.10依赖，并且scope是compile，那test2、test3都可以使用test1的junit4.10，因为依赖传递下来了；</p><p>假如test2又引入了使用junit4.9依赖，那test3会使用junit4.9【就近原则的一个依赖】；</p><h4 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h4><p><code>&lt;optional&gt;</code> 属性表示依赖是否可选；也可以理解为是否向下传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span> true/false<span class="tag">&lt;<span class="name">optional</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>在依赖中添加optional选项决定此依赖是否向下传递：</p><ul><li>true：不传递；</li><li>false：传递，默认为false；</li></ul><h4 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h4><p>用maven管理库依赖，有个好处就是连同库的自身依赖（间接依赖）jar包也全部都一起下载，也就是依赖传递的功能。这种特性免去手工添加的麻烦，但同时也带来了同一个jar包会被下载了不同版本的问题，即jar包的版本冲突。好在pom的配置里面允许用<code>&lt;exclusion&gt;</code>来排除一些不需要同时下载的依赖jar 。</p><p>引入dubbo 依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibabaxm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是该包依赖<code>org.springframework 2.5.6.SEC03</code>的jar包, 但是项目本身又引入了<code>springframework 4.3.3</code>的jar包，所以这种依赖反倒成了<strong>工程瘦身</strong>的负担，并可能会出现jar包冲突的情况。</p><p>怎么解决这个问题呢?</p><p>答案: <strong>使用 exclusions,排除多余的依赖.</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，就将引入的 dubbo 2.5.3 中依赖的springframework的依赖排除了。</p><p>如果想要去掉全部的依赖，可以使用通配符<code> *</code> :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>*<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就将dubbo 2.5.3 中所有依赖的jar包都排除了，就是单纯地引入dubbo 2.5.3这一个依赖。</p><h2 id="Maven生命周期命令"><a href="#Maven生命周期命令" class="headerlink" title="Maven生命周期命令"></a>Maven生命周期命令</h2><h3 id="Maven项目的目录结构"><a href="#Maven项目的目录结构" class="headerlink" title="Maven项目的目录结构"></a>Maven项目的目录结构</h3><p>使用Maven创建Web项目，IDE会自动生成一下目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ProjectName</span><br><span class="line">  |-src</span><br><span class="line">  |   |-main</span><br><span class="line">  |   |  |-java        —— 存放项目的 .java 文件</span><br><span class="line">  |   |  |-resources   —— 存放项目资源文件，如 spring, Mybatis等的配置文件</span><br><span class="line">  |   |-test</span><br><span class="line">  |      |-java        —— 存放所有测试.java文件，如JUnit测试类</span><br><span class="line">  |      |-resources   —— 测试资源文件</span><br><span class="line">  |-target             —— 目标文件输出位置，例如 .class、.jar、.war文件</span><br><span class="line">  |-pom.xml            —— maven项目核心配置文件</span><br></pre></td></tr></table></figure><h3 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h3><p>Maven生命周期就是为了<strong>对所有的构建过程进行抽象和统一</strong>。包括项目 清理、初始化、编译、打包、测试、部署 等几乎所有构建步骤。</p><p><strong>生命周期可以理解为构建工程的步骤。</strong></p><p>在Maven中有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：</p><ul><li><strong>Clean Lifecycle</strong>： 在进行真正的构建之前进行一些清理工作；</li><li><strong>Default Lifecycle</strong>： 构建的核心部分，编译，测试，打包，部署等等；</li><li><strong>Site Lifecycle</strong>： 生成项目报告，站点，发布站点；</li></ul><h4 id="Clean-生命周期：清理项目"><a href="#Clean-生命周期：清理项目" class="headerlink" title="Clean 生命周期：清理项目"></a>Clean 生命周期：清理项目</h4><p>Clean生命周期一共包含了三个阶段： </p><ol><li><strong>pre-clean</strong>：执行一些需要在clean之前完成的工作；</li><li><strong>clean</strong>： 移除上一次构建生成的所有文件；</li><li><strong>post-clean</strong>：执行一些需要在clean之后立刻完成的工作；</li></ol><p>也就是说，<code>mvn clean</code> 等同于 <code>mvn pre-clean clean</code> 两种操作；如果执行 <code>mvn post-clean</code> ，那么 <code>pre-clean</code>，<code>clean</code> 都会被运行，这是Maven很重要的一个规则，可以大大简化命令行的输入。</p><h4 id="Default-生命周期：构造项目"><a href="#Default-生命周期：构造项目" class="headerlink" title="Default 生命周期：构造项目"></a>Default 生命周期：构造项目</h4><p>Default生命周期是Maven生命周期中最重要的一个，绝大部分工作都发生在这个生命周期中。这里只解释一些比较重要和常用的阶段：</p><p><strong>validate</strong></p><ul><li>generate-sources</li><li>process-sources</li><li>generate-resources</li><li>process-resources 复制并处理资源文件，至目标目录，准备打包。</li></ul><p><strong>compile</strong> 编译项目的源代码。</p><ul><li>process-classes</li><li>generate-test-sources</li><li>process-test-sources</li><li>generate-test-resources</li><li>process-test-resources 复制并处理资源文件，至目标测试目录。</li></ul><p><strong>test-compile</strong> 编译测试源代码。</p><ul><li>process-test-classes</li></ul><p><strong>test</strong> 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。</p><ul><li>prepare-package</li></ul><p><strong>package</strong> 接受编译好的代码，打包成可发布的格式，如 JAR 。</p><ul><li>pre-integration-test</li><li>integration-test</li><li>post-integration-test</li><li>verify</li></ul><p><strong>install</strong> 将包安装至本地仓库，以让其它项目依赖。</p><p><strong>deploy</strong> 将最终的包复制并传输到远程仓库，以让其它开发人员与项目共享</p><p><strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，这也就是为什么我们 <strong>运行<code>mvn install</code> 的时候，代码会被编译，测试，打包，安装到本地仓库的原因。</strong>此外，Maven的插件机制是完全依赖于Maven的生命周期的，因此理解生命周期至关重要。</p><h4 id="Site-生命周期：生成项目站点"><a href="#Site-生命周期：生成项目站点" class="headerlink" title="Site 生命周期：生成项目站点"></a>Site 生命周期：生成项目站点</h4><p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很方便，很好看。</p><ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作；</li><li>site：生成项目的站点文档；</li><li>post-site：执行一些需要在生成站点文档之后完成的工作，并且为部署做准备；</li><li>site-deploy：将生成的站点文档部署到特定的服务器上；</li></ul><h3 id="Maven生命周期命令-1"><a href="#Maven生命周期命令-1" class="headerlink" title="Maven生命周期命令"></a>Maven生命周期命令</h3><p>使用IDEA创建Maven项目，然后进入项目目录，测试Maven各个命令的作用：</p><p><strong>编译：mvn compile</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><p>命令执行完毕后，会生成target目录，该目录中存放了项目编译后的字节码文件。</p><p><strong>清除：mvn clean</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><p>命令执行完毕后，会将compile生成的target目录删除。</p><p><strong>测试：mvn test</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test</span><br></pre></td></tr></table></figure><p>命令执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）。</p><p><strong>打包：mvn package</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>命令执行完毕后，会在target目录中生成一个项目文件，为：jar包、war包【web项目】。</p><p><strong>安装：mvn install</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>目的就是将打包好的jar包上传到本地仓库中，执行完毕后，会在本地仓库中出现安装后的jar包，本地的其他工程就可以直接引用了，在使用Maven进行子模块开发的时候最能体现。</p><p><strong>部署: mvn deploy</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><p>目的就是将打包好的jar包部署到指定的远程仓库，比如：团体或者公司的仓库。</p><p><strong>Maven也可以使用组合命令，如：</strong></p><ul><li>mvn clean compile</li><li>mvn clean test</li><li>mvn clean package</li><li>mvn clean install</li></ul><h2 id="Maven的常用命令"><a href="#Maven的常用命令" class="headerlink" title="Maven的常用命令"></a>Maven的常用命令</h2><h4 id="Maven设置版本号命令"><a href="#Maven设置版本号命令" class="headerlink" title="Maven设置版本号命令"></a>Maven设置版本号命令</h4><p>对于多module项目，可以使用<code>versions-maven-plugin</code>的<code>mvn versions:set</code>命令升级版本号;统一修改pom的版本号，及子模块依赖的版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn versions:set -DnewVersion=xxx</span><br></pre></td></tr></table></figure><p>如果有问题，可以回退版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn versions:revert</span><br></pre></td></tr></table></figure><p>如果没问题，然后执行如下命令,确认提交版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn versions:commit</span><br></pre></td></tr></table></figure><h4 id="Maven依赖树命令"><a href="#Maven依赖树命令" class="headerlink" title="Maven依赖树命令"></a>Maven依赖树命令</h4><p>查看项目的依赖模型,可以使用Maven依赖树:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure><h2 id="Maven的常用标签"><a href="#Maven的常用标签" class="headerlink" title="Maven的常用标签"></a>Maven的常用标签</h2><h3 id="Maven的＜relativePath-＞标签"><a href="#Maven的＜relativePath-＞标签" class="headerlink" title="Maven的＜relativePath/＞标签"></a>Maven的＜relativePath/＞标签</h3><p>搭建Maven项目时，子模块指定父模块，经常在<code>&lt;parent&gt;</code>标签中添加<code>&lt;relativePath/&gt;</code>标签，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个<code>&lt;relativePath/&gt;</code>标签的意思就是parent的路径，具体来说就是从什么地方引用这个parent项目，即这个parent项目的pom在哪里？</p><ul><li>默认没有<code>&lt;relativePath/&gt;</code>标签，那就从默认的路径：../pom.xml，会从本地路径中获取parent的pom文件，建立多个模块时就是在这个情况。</li><li><code>&lt;relativePath/&gt;</code>，指定了relativePath，但是值是空的，那就始终从仓库中获取，不从本地路径获取。场景的就是使用springboot构建项目。</li><li><code>&lt;relativePath&gt;xx&lt;relativePath/&gt;</code>，指定了一个路径去获取parent的pom文件。</li></ul><p>从父级仓库查找依赖版本，MAVEN构建jar包时查找顺序：<code>relativePath元素中的地址 &gt; 本地仓库 &gt; 远程仓库</code>。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/JayLee_Wen/article/details/129831740">maven scope标签的作用</a></p><p><a href="https://zhuanlan.zhihu.com/p/97830644">学Maven，这篇万余字的教程，真的够用了！</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 项管工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析多源异构数据</title>
      <link href="/2023/10/09/%E6%B5%85%E6%9E%90%E5%A4%9A%E6%BA%90%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/10/09/%E6%B5%85%E6%9E%90%E5%A4%9A%E6%BA%90%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析多源异构数据"><a href="#浅析多源异构数据" class="headerlink" title="浅析多源异构数据"></a>浅析多源异构数据</h1><h2 id="什么是多源异构数据"><a href="#什么是多源异构数据" class="headerlink" title="什么是多源异构数据"></a>什么是多源异构数据</h2><p><strong>多源：指数据的来源具有多源性。</strong>多源异构数据来自多个数据源，包括不同<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">数据库系统</a>和不同设备在工作中采集的数据集。不同的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%BA%90&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">数据源</a>所在的<a href="https://www.zhihu.com/search?q=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">操作系统</a>、管理系统不同（例如OA、CRM、HR、MES、SCM），数据的存储模式和逻辑结构不同，数据的产生时间、使用场所、<a href="https://www.zhihu.com/search?q=%E4%BB%A3%E7%A0%81%E5%8D%8F%E8%AE%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">代码协议</a>等也不同，这造成了数据“多源”的特征。</p><p><strong>异构：指数据种类及形态具有复杂性，即<a href="https://www.zhihu.com/search?q=%E5%BC%82%E6%9E%84%E6%80%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">异构性</a>。</strong>异构数据体现在五个层次上：</p><ol><li>计算机体系结构的异构；数据的物理存储来源于不同体系结构的计算机中，如：大型机、小型机、工作站、PC或嵌入式系统中。</li><li>操作系统的异构；数据的存储来源于不同的操作系统，如：Unix、Windows、Linux、OS/400等。</li><li>数据格式的异构；数据的存储管理机制不同，可以是关系型数据库系统，如：Oracle、SQL Server、DB2等，也可以是文件行二维数据，如：txt、CSV、XLS等。</li><li>数据存储地点异构；数据存储在分散的物理位置上，此类情况大多出现在大型机构中，如：销售数据分别存储在北京、上海、日本、韩国等多个分支机构的本地销售系统中。</li><li>数据存储的逻辑模型异构；数据分别在不同的业务逻辑中存储和维护，从而相同意义的数据存在表现的异构；如：独立的销售系统和独立的采购系统中存在部门的编码不一致等。</li></ol><p>异构数据往往不是一个层面的异构，而是在多个层面上都存在异构。异构数据整合的目标就在于实现不同结构的数据之间的数据信息资源、硬件设备资源和人力资源的合并和共享。其中关键的一点就是以分散的局部的数据为基础，通过各种工具和处理逻辑建立全局的统一的数据或视图。</p><blockquote><p>101 异构数据采集技术的原理是通过获取软件系统的底层数据交换和网络流量包，进行包流量分析和使用仿真技术采集到应用数据，并且输出结构化数据。所以，它能做到无需软件厂商接口，异构数据直接采集，解决了和厂商协调难、接口费用高、实施周期长等问题。</p></blockquote><p>多源异构数据包括：结构化数据、半结构化数据 和 <a href="https://www.zhihu.com/search?q=%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">非结构化数据</a>。</p><p>① 结构化数据：指<a href="https://www.zhihu.com/search?q=%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">关系模型</a>数据，即以<a href="https://www.zhihu.com/search?q=%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">关系数据库</a>表形式管理的数据，结合到典型场景中更容易理解，比如企业ERP、财务系统。</p><p>② <a href="https://www.zhihu.com/search?q=%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">半结构化数据</a>：指非关系模型的、有基本固定<a href="https://www.zhihu.com/search?q=%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">结构模式</a>的数据，例如<a href="https://www.zhihu.com/search?q=%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">日志文件</a>、XML文档、JSON文档、E-mail等；</p><p>③ 非结构化数据：指<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">数据结构</a>不规则或不完整，没有预定义的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">数据模型</a>，不方便用数据库<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E7%BB%B4%E9%80%BB%E8%BE%91%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2472976501%7D">二维逻辑表</a>来表现的数据。如word、pdf、ppt及各种格式的图片、视频等。</p><p>不同类型的数据在形成过程中没有统一的标准，因此造成了数据“异构”的特征。如：制造业生成过程中多源异构数据划分表如下。</p><img src="v2-497f7f21840837895508cde9c052fd7a_r.jpg" alt="img" style="zoom:80%;"><h2 id="要如何融合处理多源异构数据？"><a href="#要如何融合处理多源异构数据？" class="headerlink" title="要如何融合处理多源异构数据？"></a>要如何融合处理多源异构数据？</h2><blockquote><p><strong>1、针对多元化的结构化数据融合，主要关注在数据的ETL处理 以及<a href="https://www.zhihu.com/search?q=%E6%97%B6%E6%95%88%E6%80%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">时效性</a>上：</strong></p></blockquote><p>① 表结构不同，需要做到不同类型的字段映射</p><p>②假如要新增表字段的时候，需要新增列</p><p>③ 若有表字段需要进行二次处理规范，需要支持字段转换，比如公式或其他</p><p>④新增表设计时，需要保证三大范式，这里就不展开讲了，可参考：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qq_40899182/article/details/81706253">数据库三大范式</a></p><p>⑤ 数据同步的时效性，例如实时同步、半小时一次、或者一天一次、或者说是需要实时同步融合，这个要根据具体业务场景来确认。</p><blockquote><p><strong>2、针对半结构、非结构化数据，因为数据分散，缺乏统一管理，需要借用专业工具</strong></p></blockquote><p>目前有两种方式来处理半结构、非结构化数据：</p><p>①提取半结构、非结构化数据中的关键信息，到结构化数据中进行二次利用，比较好处理的是半结构化（json、xml）、excel、csv，因为这种数据的结构比较统一。</p><p>② 向word、PDF这种<a href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%8F%90%E5%8F%96&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">文件提取</a>关键信息，假如是单个文本的话，市面上有些工具可能可以实现，但假如是大批量的话，可能就需要通过程序，去自定义一些正则表达式，去进行关键信息的提取。这种一般来说，因为格式不一致，以及用途不一致，所以程序自定义的比较多。</p><p><strong>针对这种的话，会综合考虑数据价值和<a href="https://www.zhihu.com/search?q=%E6%8A%95%E5%85%A5%E4%BA%A7%E5%87%BA%E6%AF%94&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">投入产出比</a>，因为这部分的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">数据处理</a>较为复杂。</strong> </p><p>若想提高投入产出比，可用例如**<a href="https://link.zhihu.com/?target=https://www.finedatalink.com/?utm_source=media&utm_medium=zhihu&utm_campaign=gf&utm_term=fdl">FineDataLink</a>**这类专业工具，去支持结构化/半结构化数据的融合集成，面向ETL数据处理场景，也可以让数据编排更简单一些，提高数据的使用价值。</p><p>另外，如若这部分历史文件的需要做到备份的话，会通过FTP或者SFTP将文件进行备份存储到<a href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">文件服务器</a>，进行文件业务分类、<a href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%90%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">文件名</a>、路径的统一管理，提供统一入口，通过<a href="https://www.zhihu.com/search?q=%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2512025799%7D">权限管理</a>的方式给到大家下载使用。</p><h2 id="有没有软件可以实现异构数据库的统一访问"><a href="#有没有软件可以实现异构数据库的统一访问" class="headerlink" title="有没有软件可以实现异构数据库的统一访问"></a>有没有软件可以实现异构数据库的统一访问</h2><blockquote><p>例如最起码实现如下的功能： select <a href="https://link.zhihu.com/?target=http://oracle.xxx">http://oracle.xxx</a> from ….. ; select <a href="https://link.zhihu.com/?target=http://sqlserver.xxx">http://sqlserver.xxx</a> from ….<br>应用程序层通过中间层调用一些标准SQL语句时方便些；<br>如select <a href="https://link.zhihu.com/?target=http://oracle.XXX">http://oracle.XXX</a> from XXX where oralce.XXX.id=sqlserver.XXX.id<br>就是用sql语句调用2个数据库中的表跟标用一个数据库中的表一样，<br>例如业务上，将一个数据库中的基础数据同步到另外一个数据库中，想将检查2个不同数据库中同步过去的基础数据表中是否一致。</p></blockquote><h3 id="问题1：是否有软件可以实现异构数据库的统一访问？"><a href="#问题1：是否有软件可以实现异构数据库的统一访问？" class="headerlink" title="问题1：是否有软件可以实现异构数据库的统一访问？"></a><strong>问题1：是否有软件可以实现<a href="https://www.zhihu.com/search?q=%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">异构数据库</a>的统一访问？</strong></h3><p><strong>答：</strong>有软件可以实现，但要想实现异构数据库的统一访问，例如<code>select  http://oracle.XXX from XXX ；where oralce.XXX.id=sqlserver.XXX.id</code>，首先要先明白这类数据计算运行的底层逻辑是什么。</p><p>① 假如是通过异构数据库，直接进行左右关联，那这类数据的计算就是在运行软件/程序的服务器。</p><p>② 假如只是数据的一个统一访问，然后进行OLAP<a href="https://www.zhihu.com/search?q=%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">关联分析</a>，用BI工具就行。</p><p>③ 假如是除了数据的统一访问，还需要进行数据的再次处理，那还是推荐通过工具，<strong>将分布在不同网络、不同服务器上的不同种的数据库中的数据，集成到一个数据库，再进行处理，</strong>这样的话，就是统一将算力放到这个新的目标数据库中，同时也不会影响原有数据库的使用，也就是<a href="https://www.zhihu.com/search?q=%E6%95%B0%E4%BB%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">数仓</a>搭建的最常见做法。</p><p><img src="v2-ae0ee4f62b8e5453ea00ba744b60c873_1440w.webp" alt="img"></p><p>但其实很多人，看到数仓会比较排斥，觉得这是大公司级别才会做的事情，其实不然，你可以根据你的数据库或者系统数据的体量，进行一定程度裁剪，搭建符合自己数据使用习惯的数仓就行。</p><p>现在这类市面上有很多工具，可以做到这点，开源的有<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/Kettle/5920713?fr=aladdin">kettle</a>，商业的有<a href="https://link.zhihu.com/?target=https://www.finedatalink.com/?utm_source=media&utm_medium=zhihu&utm_campaign=gf&utm_term=fdl">FineDataLink</a>，通过设置流程，很快就能完成异构数据库的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">数据迁移</a>集成。（ps：需要说明，这类开源工具，在使用过程中，会容易出现数据库报错或者连接数不足等异常，且insert/update会占用大量的CPU资源，如果对数据要求高，不太推荐使用开源工具）。</p><h3 id="问题2：做一个分布式数据库是否可以实现这个功能？"><a href="#问题2：做一个分布式数据库是否可以实现这个功能？" class="headerlink" title="问题2：做一个分布式数据库是否可以实现这个功能？"></a><strong>问题2：做一个<a href="https://www.zhihu.com/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">分布式数据库</a>是否可以实现这个功能？</strong></h3><p><strong>答：可以。</strong>但最好是在异构数据库很多，数据量很大时，再去选择分布式数据库，这样数据的存储能力和算力都会进一步提升。假如数据量<a href="https://www.zhihu.com/search?q=%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">单机数据库</a>就能支撑，其实就没必要采用分布式数据库。</p><p>为什么呢？因为一般来说，分布式数据库都是由<a href="https://www.zhihu.com/search?q=%E4%B8%BB%E8%8A%82%E7%82%B9&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">主节点</a>+N个计算存储节点，具备可扩展、高可用（当部分节点失效时，其他节点能够接替它继续服务）的能力，因此一般购买成本、运维成本都比较高。所以，如果数据量单机数据库就能支撑，采用分布式数据库就比较“浪费”，性价比不如使用上面提到的<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90%E5%B7%A5%E5%85%B7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2494038171%7D">数据集成工具</a>高。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.zhihu.com/question/45940859/answer/1716351657">https://www.zhihu.com/question/45940859/answer/1716351657</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异构数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>订单系统设计</title>
      <link href="/2023/08/30/%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/08/30/%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="订单系统设计"><a href="#订单系统设计" class="headerlink" title="订单系统设计"></a>订单系统设计</h1><p>todo…</p>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 订单系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Squirrel状态机（官网直译版）</title>
      <link href="/2023/08/24/Squirrel%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88%E5%AE%98%E7%BD%91-%E8%AF%91%EF%BC%89/"/>
      <url>/2023/08/24/Squirrel%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88%E5%AE%98%E7%BD%91-%E8%AF%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Squirrel状态机"><a href="#Squirrel状态机" class="headerlink" title="Squirrel状态机"></a>Squirrel状态机</h1><p>squirrel-foundation为Java提供了一种易于使用、类型安全且高度可扩展的状态机实现。</p><blockquote><p>个人根据官方文档翻译的中文版，官网地址：<a href="http://hekailiang.github.io/squirrel/">Squirrel State Machine</a></p></blockquote><h2 id="squirrel-foundation"><a href="#squirrel-foundation" class="headerlink" title="squirrel-foundation"></a>squirrel-foundation</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>就像松鼠这种小巧、敏捷、聪明、警觉和可爱的动物一样，squirrel-foundation旨在为企业提供轻量级、高度灵活和可扩展、可诊断、易于使用和类型安全的Java状态机实现。</p><p>下面是描述ATM机状态变化的状态机图:</p><img src="image-20230824160701442.png" alt="image-20230824160701442" style="zoom:35%;"><p>示例代码可以在<code>“org.squirrelframework.foundation.fsm.atm”</code>包中找到。</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Squirrel-foundation已经部署到maven中央存储库，因此您只需要向pom.xml添加以下依赖项。</p><p>最新Released版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.squirrelframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>squirrel-foundation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最新Snapshot版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.squirrelframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>squirrel-foundation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.9-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><p>要快速尝试squirrel状态机功能，请创建一个maven项目，并适当地包含squirrel-foundation依赖项。然后运行下面的示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.StateMachineBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.UntypedStateMachine;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.UntypedStateMachineBuilder;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.annotation.StateMachineParameters;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.impl.AbstractUntypedStateMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickStartSample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Define State Machine Event | 定义状态机事件,状态发生切换时可以触发指定事件</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">FSMEvent</span> &#123;</span><br><span class="line">        ToA, ToB, ToC, ToD</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. Define State Machine Class | 定义状态机</span></span><br><span class="line"><span class="comment">     * 参数解释:</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@StateMachineParameters</span>注解 定义状态机参数</span></span><br><span class="line"><span class="comment">     * stateType = String.class 表示状态类型为String</span></span><br><span class="line"><span class="comment">     * eventType = FSMEvent.class 表示状态机事件类型为FSMEvent</span></span><br><span class="line"><span class="comment">     * contextType = Integer.class 表示状态上下文类型为Integer,用于数据透传</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@StateMachineParameters(stateType = String.class, eventType = FSMEvent.class, contextType = Integer.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StateMachineSample</span> <span class="keyword">extends</span> <span class="title class_">AbstractUntypedStateMachine</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fromAToB</span><span class="params">(String from, String to, FSMEvent event, Integer context)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Transition from &#x27;&quot;</span> + from + <span class="string">&quot;&#x27; to &#x27;&quot;</span> + to + <span class="string">&quot;&#x27; on event &#x27;&quot;</span> + event +</span><br><span class="line">                <span class="string">&quot;&#x27; with context &#x27;&quot;</span> + context + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">ontoB</span><span class="params">(String from, String to, FSMEvent event, Integer context)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Entry State \&#x27;&quot;</span> + to + <span class="string">&quot;\&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. Build State Transitions | 构建状态转换过程</span></span><br><span class="line">        <span class="type">UntypedStateMachineBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> StateMachineBuilderFactory.create(StateMachineSample.class);</span><br><span class="line">        builder.externalTransition().from(<span class="string">&quot;A&quot;</span>).to(<span class="string">&quot;B&quot;</span>).on(FSMEvent.ToB).callMethod(<span class="string">&quot;fromAToB&quot;</span>);</span><br><span class="line">        builder.onEntry(<span class="string">&quot;B&quot;</span>).callMethod(<span class="string">&quot;ontoB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. Use State Machine | 使用状态机</span></span><br><span class="line">        <span class="type">UntypedStateMachine</span> <span class="variable">fsm</span> <span class="operator">=</span> builder.newStateMachine(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        fsm.fire(FSMEvent.ToB, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Current state is &quot;</span> + fsm.getCurrentState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">16:25:32.202 [main] DEBUG org.squirrelframework.foundation.fsm.impl.StateImpl - State &quot;A&quot; entry.</span><br><span class="line">16:25:32.206 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;STATE_ENTRY__A&#x27; invoked.</span><br><span class="line">16:25:32.210 [main] DEBUG org.squirrelframework.foundation.fsm.impl.StateImpl - State &quot;A&quot; exit.</span><br><span class="line">16:25:32.211 [main] DEBUG org.squirrelframework.foundation.fsm.impl.StateImpl - State &quot;B&quot; entry.</span><br><span class="line">16:25:32.211 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;STATE_EXIT__A&#x27; invoked.</span><br><span class="line">Transition from &#x27;A&#x27; to &#x27;B&#x27; on event &#x27;ToB&#x27; with context &#x27;10&#x27;.</span><br><span class="line">16:25:32.216 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;TRANSITION__A-[ToB, Always, 1, EXTERNAL]-&gt;B&#x27; invoked.</span><br><span class="line">Entry State &#x27;B&#x27;.</span><br><span class="line">16:25:32.216 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;STATE_ENTRY__B&#x27; invoked.</span><br><span class="line">Current state is B</span><br></pre></td></tr></table></figure><p>现在您可能对示例代码有很多疑问，请耐心等待。下面的用户指南将回答您的大部分问题。但在进入细节之前，需要对状态机概念有基本的了解。这些材料有助于理解状态机的概念。 [<a href="http://www.uml-diagrams.org/state-machine-diagrams.html">state-machine-diagrams]</a> [<a href="http://qt-project.org/doc/qt-4.8/statemachine-api.html">qt-state-machine]</a></p><h2 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>squirrel-foundation支持流式API和声明式的方式来声明状态机，并使用户能够以简单的方式定义操作方法。</p><h4 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a><strong>State Machine</strong></h4><p><strong>状态机</strong></p><p>接口接受四个泛型类型参数:</p><ul><li>T表示实现状态机的类型。</li><li>S表示实现状态的类型。</li><li>E表示实现事件的类型。</li><li>C代表实现的外部上下文的类型。</li></ul><h4 id="State-Machine-Builder"><a href="#State-Machine-Builder" class="headerlink" title="State Machine Builder"></a><strong>State Machine Builder</strong></h4><p><strong>状态机构造器</strong></p><ul><li>状态机生成器用于生成状态机定义。StateMachineBuilder可以通过StateMachineBuilderFactory创建。</li><li>StateMachineBuilder由*TransitionBuilder (InternalTransitionBuilder / LocalTransitionBuilder / ExternalTransitionBuilder)和EntryExitActionBuilder组成，前者用于构建状态之间的转换，而后者用于在进入或退出状态时构建动作。</li><li>内部状态在转换创建或状态操作创建期间隐式构建。</li><li>由同一状态机构建器创建的所有状态机实例共享相同的数据定义，以优化内存使用。</li><li>状态机生成器以惰性方式生成状态机定义。当构建器创建第一个状态机实例时，将生成状态机定义，这是一个耗时的过程。但在生成状态机定义之后，后续的状态机实例创建将会快得多。通常，应该尽可能重用状态机构建器。</li></ul><p>为了创建状态机，用户需要首先创建状态机构建器。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StateMachineBuilder&lt;MyStateMachine, MyState, MyEvent, MyContext&gt; builder =</span><br><span class="line">      StateMachineBuilderFactory.create(MyStateMachine.class, MyState.class, MyEvent.class, MyContext.class);</span><br></pre></td></tr></table></figure><p>状态机构造器接受的参数是状态机(T)、状态(S)、事件(E)和上下文(C)的类型。</p><h4 id="Fluent-API"><a href="#Fluent-API" class="headerlink" title="Fluent API"></a><strong>Fluent API</strong></h4><p><strong>流式API</strong></p><p>在创建了状态机构建器之后，我们可以使用Fluent API来定义状态机的状态/转换/动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.externalTransition().from(MyState.A).to(MyState.B).on(MyEvent.GoToB);</span><br></pre></td></tr></table></figure><p>在状态“A”到状态“B”之间构建外部转换，并<strong>在接收到事件“GoToB”时触发</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.internalTransition(TransitionPriority.HIGH).within(MyState.A).on(MyEvent.WithinA).perform(myAction);</span><br></pre></td></tr></table></figure><p>一个优先级设置为高的内部转换，在内部状态’ A ‘中构建事件’ WithinA ‘执行’ myAction ‘行为。内部转换是指在转换完成后，没有退出或进入任何状态。转换优先级用于在状态机扩展时覆盖原始转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">builder.externalTransition().from(MyState.C).to(MyState.D).on(MyEvent.GoToD).when(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Condition</span>&lt;MyContext&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSatisfied</span><span class="params">(MyContext context)</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> context!=<span class="literal">null</span> &amp;&amp; context.getValue()&gt;<span class="number">80</span>;</span><br><span class="line">          &#125;</span><br><span class="line">            </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;MyCondition&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;).callMethod(<span class="string">&quot;myInternalTransitionCall&quot;</span>);</span><br></pre></td></tr></table></figure><p>在事件“GoToD”上从状态“C”构建到状态“D”的条件转换，当外部上下文满足条件限制时，然后调用动作方法“myInternalTransitionCall”。用户还可以使用MVEL(一种功能强大的表达语言)以以下方式描述状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.externalTransition().from(MyState.C).to(MyState.D).on(MyEvent.GoToD).whenMvel(</span><br><span class="line">      <span class="string">&quot;MyCondition:::(context!=null &amp;&amp; context.getValue()&gt;80)&quot;</span>).callMethod(<span class="string">&quot;myInternalTransitionCall&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意: 使用字符’:::’分隔条件名称和条件表达式。’context ‘是指向当前context对象的预定义变量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.onEntry(MyState.A).perform(Lists.newArrayList(action1, action2))</span><br></pre></td></tr></table></figure><p>在上面的示例代码中定义了状态输入操作列表。</p><h4 id="Method-Call-Action"><a href="#Method-Call-Action" class="headerlink" title="Method Call Action"></a><strong>Method Call Action</strong></h4><p><strong>方法调用行为</strong></p><p>用户可以在定义转换或状态进入/退出期间定义匿名操作。然而，操作代码将分散在许多地方，这可能使代码难以维护。而且，其他用户不能覆盖这些操作。因此，squirrel-foundation也支持定义状态机方法调用动作，这是随状态机类本身而来的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StateMachineBuilder&lt;...&gt; builder = StateMachineBuilderFactory.create(</span><br><span class="line">      MyStateMachine.class, MyState.class, MyEvent.class, MyContext.class);</span><br><span class="line">  builder.externalTransition().from(A).to(B).on(toB).callMethod(<span class="string">&quot;fromAToB&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的转换行为方法都跟随状态机类</span></span><br><span class="line">  <span class="comment">// All transition action method stays with state machine class</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStateMachine</span>&lt;...&gt; <span class="keyword">extends</span> <span class="title class_">AbstractStateMachine</span>&lt;...&gt; &#123;</span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fromAToB</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span> &#123;</span><br><span class="line">          <span class="comment">// this method will be called during transition from &quot;A&quot; to &quot;B&quot; on event &quot;toB&quot;</span></span><br><span class="line">          <span class="comment">// the action method parameters types and order should match</span></span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此外，squirrel-foundation还支持以约定优于配置的方式定义方法调用动作。基本上，这意味着如果在状态机中声明的方法满足命名和参数约定，它将被添加到转换操作列表中，并在某个阶段被调用。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">transitFromAToBOnGoToB</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span></span><br></pre></td></tr></table></figure><p>命名为transitFrom[SourceStateName]To[TargetStateName]On[EventName]，参数化为[MyState, MyState, MyEvent, MyContext]将被添加到转换“A-(GoToB)-&gt;B”动作列表中。当接收到事件’ GoToB ‘触发状态’ A ‘转换到状态’ B ‘时，将调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">transitFromAnyToBOnGoToB</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span></span><br></pre></td></tr></table></figure><p>transitFromAnyTo[TargetStateName]On[EventName]该方法将在事件’ GoToB ‘上从任何状态转移到状态’ B ‘时调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">exitA</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span></span><br></pre></td></tr></table></figure><p>该方法将在退出状态’ A ‘时被调用。entry[StateName]， beforeExitAny/afterExitAny和beforeEntryAny/afterEntryAny也是如此。</p><p><strong>其他支持的命名模式</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transitFrom[fromStateName]To[toStateName]On[eventName]When[conditionName]  </span><br><span class="line">transitFrom[fromStateName]To[toStateName]On[eventName]  </span><br><span class="line">transitFromAnyTo[toStateName]On[eventName]  </span><br><span class="line">transitFrom[fromStateName]ToAnyOn[eventName]  </span><br><span class="line">transitFrom[fromStateName]To[toStateName]          </span><br><span class="line">on[eventName] </span><br></pre></td></tr></table></figure><p>上面列出的那些方法约定还提供了类似aop的功能，这些功能为任何粒度的松鼠状态机提供了内置的灵活扩展功能。</p><p>要了解更多信息，请参考测试用例<code>“org.squirrelframework.foundation.fsm.ExtensionMethodCallTest”</code>。</p><p>从0.3.1开始，有另一种方式来定义这些类似aop的扩展方法，就是通过Fluent API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since 0.3.1</span></span><br><span class="line"><span class="comment">// the same effect as add method transitFromAnyToCOnToC in your state machine | 和transitFromAnyToCOnToC效果类似</span></span><br><span class="line">builder.transit().fromAny().to(<span class="string">&quot;C&quot;</span>).on(<span class="string">&quot;ToC&quot;</span>).callMethod(<span class="string">&quot;fromAnyToC&quot;</span>);</span><br><span class="line"><span class="comment">// the same effect as add method transitFromBToAnyOnToC in your state machine | 和transitFromBToAnyOnToC效果类似</span></span><br><span class="line">builder.transit().from(<span class="string">&quot;B&quot;</span>).toAny().on(<span class="string">&quot;ToC&quot;</span>).callMethod(<span class="string">&quot;fromBToAny&quot;</span>);</span><br><span class="line"><span class="comment">// the same effect as add method transitFromBToAny in your state machine | 和transitFromBToAny效果类似</span></span><br><span class="line">builder.transit().from(<span class="string">&quot;B&quot;</span>).toAny().onAny().callMethod(<span class="string">&quot;fromBToAny&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者通过声明性注释，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// since 0.3.1</span></span><br><span class="line"><span class="meta">@Transitions(&#123;</span></span><br><span class="line"><span class="meta">  @Transit(from=&quot;B&quot;, to=&quot;E&quot;, on=&quot;*&quot;, callMethod=&quot;fromBToEOnAny&quot;),</span></span><br><span class="line"><span class="meta">  @Transit(from=&quot;*&quot;, to=&quot;E&quot;, on=&quot;ToE&quot;, callMethod=&quot;fromAnyToEOnToE&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:这些动作方法将附加到 相匹配的并且已存在的转换，但不会创建任何新的转换。</p></blockquote><p>从0.3.4开始，也可以使用以下API一次定义多个转换，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transitions(A-&gt;B@A2B=&gt;a2b, A-&gt;C@A2C=&gt;a2c, A-&gt;D@A2D) will be defined at once</span></span><br><span class="line">builder.transitions().from(State._A).toAmong(State.B, State.C, State.D).</span><br><span class="line">  onEach(Event.A2B, Event.A2C, Event.A2D).callMethod(<span class="string">&quot;a2b|a2c|_&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transitions(A-&gt;_A@A2ANY=&gt;DecisionMaker, _A-&gt;A@ANY2A) will be defined at once</span></span><br><span class="line">builder.localTransitions().between(State.A).and(State._A).</span><br><span class="line">  onMutual(Event.A2ANY, Event.ANY2A).</span><br><span class="line">  perform( Lists.newArrayList(<span class="keyword">new</span> <span class="title class_">DecisionMaker</span>(<span class="string">&quot;SomeLocalState&quot;</span>), <span class="literal">null</span>) );</span><br></pre></td></tr></table></figure><p>更多信息可以在<code>org.squirrelframework.foundation.fsm.samples.DecisionStateSampleTest</code>;</p><h4 id="Declarative-Annotation"><a href="#Declarative-Annotation" class="headerlink" title="Declarative Annotation"></a><strong>Declarative Annotation</strong></h4><p><strong>声明注解</strong></p><p>还提供了一种声明性注解的方式来定义和扩展状态机。这里有一个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@States(&#123;</span></span><br><span class="line"><span class="meta">  @State(name=&quot;A&quot;, entryCallMethod=&quot;entryStateA&quot;, exitCallMethod=&quot;exitStateA&quot;), </span></span><br><span class="line"><span class="meta">  @State(name=&quot;B&quot;, entryCallMethod=&quot;entryStateB&quot;, exitCallMethod=&quot;exitStateB&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Transitions(&#123;</span></span><br><span class="line"><span class="meta">  @Transit(from=&quot;A&quot;, to=&quot;B&quot;, on=&quot;GoToB&quot;, callMethod=&quot;stateAToStateBOnGotoB&quot;),</span></span><br><span class="line"><span class="meta">  @Transit(from=&quot;A&quot;, to=&quot;A&quot;, on=&quot;WithinA&quot;, callMethod=&quot;stateAToStateAOnWithinA&quot;, type=TransitionType.INTERNAL)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyStateMachine</span> <span class="keyword">extends</span> <span class="title class_">StateMachine</span>&lt;MyStateMachine, MyState, MyEvent, MyContext&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">entryStateA</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">stateAToStateBOnGotoB</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">stateAToStateAOnWithinA</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">exitStateA</span><span class="params">(MyState from, MyState to, MyEvent event, MyContext context)</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解既可以在状态机的实现类中定义，也可以在状态机将要实现的任何接口中定义。它还可以与fluent API混合使用，这意味着fluent API中定义的状态机也可以通过这些注释进行扩展。(您可能需要注意的一件事是，在接口中定义的方法必须是公共的，这也意味着方法调用操作实现对调用者也是公共的。)</p><h4 id="Converters"><a href="#Converters" class="headerlink" title="Converters"></a><strong>Converters</strong></h4><p><strong>转换器</strong></p><p>为了在<code>@State</code>和<code>@Transit</code>中声明状态和事件，用户需要为其状态(S)和事件(E)类型实现相应的转换器。转换必须实现<code>Converter&lt;T&gt;</code>接口，该接口将状态/事件转换为String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SquirrelComponent</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Convert object to string.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> obj converted object</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> string description of object</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  String <span class="title function_">convertToString</span><span class="params">(T obj)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Convert string to object.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> name name of the object</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> converted object</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  T <span class="title function_">convertFromString</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将这些转换器注册到ConverterProvider。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConverterProvider.INSTANCE.register(MyEvent.class, <span class="keyword">new</span> <span class="title class_">MyEventConverter</span>());</span><br><span class="line">ConverterProvider.INSTANCE.register(MyState.class, <span class="keyword">new</span> <span class="title class_">MyStateConverter</span>());</span><br></pre></td></tr></table></figure><blockquote><p>注意:如果只使用Fluent API来定义状态机，则不需要实现相应的转换器。而且，如果Event或State类是String或Enumeration类型，在大多数情况下，您不需要显式实现或注册转换器。</p></blockquote><h4 id="New-State-Machine-Instance"><a href="#New-State-Machine-Instance" class="headerlink" title="New State Machine Instance"></a><strong>New State Machine Instance</strong></h4><p><strong>新状态机实例</strong></p><p>在用户定义状态机行为之后，用户可以通过构建器创建新的状态机实例。注意，一旦从构建器创建了状态机实例，就不能再使用构建器来定义状态机的任何新元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">newStateMachine</span><span class="params">(S initialStateId, Object... extraParams)</span>;</span><br></pre></td></tr></table></figure><p>要从状态机生成器创建新的状态机实例，需要传递以下参数。</p><ol><li><p>initialStateId: 启动时，状态机的初始状态。</p></li><li><p>extraParams: 创建新状态机实例所需的额外参数。设置为<code>“new Object[0]”</code>，不需要额外参数。</p><p>a.如果用户在创建新的状态机实例时传递了额外的参数，请确保StateMachineBuilderFactory在创建状态机生成器时也定义了额外参数的类型。否则，额外的参数将被忽略。</p><p>b.额外的参数可以通过两种方式传递到状态机实例中。一种是通过状态机构造函数，这意味着用户需要为状态机实例定义具有相同参数类型和顺序的构造函数。另一种方法是定义一个名为postConstruct的方法，并且具有相同的参数类型和顺序。</p></li></ol><p>如果不需要向状态机传递额外的参数，用户可以简单地调用<code>T newstatemmachine (S initialStateId)</code>来创建一个新的状态机实例。</p><p>来自状态机构建器的新状态机。(在这种情况下，不需要传递额外的参数。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyStateMachine</span> <span class="variable">stateMachine</span> <span class="operator">=</span> builder.newStateMachine(MyState.Initial);</span><br></pre></td></tr></table></figure><h4 id="Trigger-Transition"><a href="#Trigger-Transition" class="headerlink" title="Trigger Transition"></a><strong>Trigger Transition</strong></h4><p><strong>触发转换</strong></p><p>状态机创建后，用户可以触发事件和上下文来触发状态机内部的转换。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateMachine.fire(MyEvent.Prepare, <span class="keyword">new</span> <span class="title class_">MyContext</span>(<span class="string">&quot;Testing&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="Untyped-State-Machine"><a href="#Untyped-State-Machine" class="headerlink" title="Untyped State Machine"></a><strong>Untyped State Machine</strong></h4><p><strong>无类型状态机</strong></p><p>为了简化状态机的使用，并避免过多的泛型(例如 <code>StateMachine&lt;T, S, E, C&gt;</code>)，这些泛型在某些情况下可能会使代码难以阅读，但在转换动作执行时仍然保持重要的类型安全特性，为此实现了UntypedStateMachine。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.StateMachineBuilderFactory;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.UntypedStateMachine;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.UntypedStateMachineBuilder;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.annotation.StateMachineParameters;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.annotation.Transit;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.annotation.Transitions;</span><br><span class="line"><span class="keyword">import</span> org.squirrelframework.foundation.fsm.impl.AbstractUntypedStateMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UntypedStateMachineDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">TestEvent</span> &#123;</span><br><span class="line">        toA, toB, toC, toD</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transitions(&#123;</span></span><br><span class="line"><span class="meta">        @Transit(from = &quot;A&quot;, to = &quot;B&quot;, on = &quot;toB&quot;, callMethod = &quot;fromAToB&quot;),</span></span><br><span class="line"><span class="meta">        @Transit(from = &quot;B&quot;, to = &quot;C&quot;, on = &quot;toC&quot;),</span></span><br><span class="line"><span class="meta">        @Transit(from = &quot;C&quot;, to = &quot;D&quot;, on = &quot;toD&quot;),</span></span><br><span class="line"><span class="meta">        @Transit(from = &quot;D&quot;, to = &quot;A&quot;, on = &quot;toA&quot;, callMethod = &quot;transitFromDToAOntoA&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@StateMachineParameters(stateType = String.class, eventType = TestEvent.class, contextType = Integer.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UntypedStateMachineSample</span> <span class="keyword">extends</span> <span class="title class_">AbstractUntypedStateMachine</span> &#123;</span><br><span class="line">        <span class="comment">// No need to specify constructor anymore since 0.2.9</span></span><br><span class="line">        <span class="comment">// protected UntypedStateMachineSample(ImmutableUntypedState initialState,</span></span><br><span class="line">        <span class="comment">// Map&lt;Object, ImmutableUntypedState&gt; states) &#123;</span></span><br><span class="line">        <span class="comment">//    super(initialState, states);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">fromAToB</span><span class="params">(String from, String to, TestEvent event, Integer context)</span> &#123;</span><br><span class="line">            <span class="comment">// transition action still type safe ...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Transition from &#x27;&quot;</span> + from + <span class="string">&quot;&#x27; to &#x27;&quot;</span> + to + <span class="string">&quot;&#x27; on event &#x27;&quot;</span> + event +</span><br><span class="line">                <span class="string">&quot;&#x27; with context &#x27;&quot;</span> + context + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">transitFromDToAOntoA</span><span class="params">(String from, String to, TestEvent event, Integer context)</span> &#123;</span><br><span class="line">            <span class="comment">// transition action still type safe ...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Transition from &#x27;&quot;</span> + from + <span class="string">&quot;&#x27; to &#x27;&quot;</span> + to + <span class="string">&quot;&#x27; on event &#x27;&quot;</span> + event +</span><br><span class="line">                <span class="string">&quot;&#x27; with context &#x27;&quot;</span> + context + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UntypedStateMachineBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> StateMachineBuilderFactory.create(UntypedStateMachineSample.class);</span><br><span class="line">        <span class="comment">// state machine builder not type safe anymore</span></span><br><span class="line">        <span class="comment">// builder.externalTransition().from(&quot;D&quot;).to(&quot;A&quot;).on(TestEvent.toA);</span></span><br><span class="line">        <span class="comment">// UntypedStateMachine fsm = builder.newStateMachine(&quot;A&quot;);</span></span><br><span class="line">        <span class="type">UntypedStateMachine</span> <span class="variable">fsm</span> <span class="operator">=</span> builder.newStateMachine(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">        fsm.fire(TestEvent.toA, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:31:10.629 [main] DEBUG org.squirrelframework.foundation.fsm.impl.StateImpl - State &quot;D&quot; entry.</span><br><span class="line">18:31:10.633 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;STATE_ENTRY__D&#x27; invoked.</span><br><span class="line">18:31:10.635 [main] DEBUG org.squirrelframework.foundation.fsm.impl.StateImpl - State &quot;D&quot; exit.</span><br><span class="line">18:31:10.636 [main] DEBUG org.squirrelframework.foundation.fsm.impl.StateImpl - State &quot;A&quot; entry.</span><br><span class="line">18:31:10.636 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;STATE_EXIT__D&#x27; invoked.</span><br><span class="line">Transition from &#x27;D&#x27; to &#x27;A&#x27; on event &#x27;toA&#x27; with context &#x27;8&#x27;.</span><br><span class="line">18:31:10.638 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;TRANSITION__D-[toA, Always, 1, EXTERNAL]-&gt;A&#x27; invoked.</span><br><span class="line">18:31:10.638 [main] DEBUG org.squirrelframework.foundation.fsm.impl.AbstractExecutionService - Actions within &#x27;STATE_ENTRY__A&#x27; invoked.</span><br></pre></td></tr></table></figure><p>要构建一个UntypedStateMachine，用户需要先通过StateMachineBuilderFactory创建一个UntypedStateMachineBuilder。StateMachineBuilderFactory只接受一个参数，即创建UntypedStateMachineBuilder的状态机类的类型。</p><p><code>@StateMachineParameters</code>用于声明状态机通用参数类型。</p><p><code>AbstractUntypedStateMachine</code>是任何无类型状态机的基类。</p><h4 id="Context-Insensitive-State-Machine"><a href="#Context-Insensitive-State-Machine" class="headerlink" title="Context Insensitive State Machine"></a><strong>Context Insensitive State Machine</strong></h4><p><strong>上下文不敏感状态机</strong></p><p>有时状态转换不关心上下文，这意味着转换大多只由事件决定。对于这种情况，用户可以使用上下文不敏感状态机来简化方法调用参数。</p><p>声明上下文不敏感状态机非常简单。用户只需要在状态机实现类上添加<code>@ContextInsensitive</code>注解。然后就可以忽略转换方法参数列表中的上下文参数。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextInsensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATMStateMachine</span> <span class="keyword">extends</span> <span class="title class_">AbstractStateMachine</span>&lt;ATMStateMachine, ATMState, String, Void&gt; &#123;</span><br><span class="line">  <span class="comment">// no need to add context parameter here anymore | 参数中不再需要上下文了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transitFromIdleToLoadingOnConnected</span><span class="params">(ATMState from, ATMState to, String event)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entryLoading</span><span class="params">(ATMState from, ATMState to, String event)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Transition-Exception-Handling"><a href="#Transition-Exception-Handling" class="headerlink" title="Transition Exception Handling"></a><strong>Transition Exception Handling</strong></h4><p><strong>转换异常处理</strong></p><p>当状态转换过程中发生异常时，执行的动作列表将被中止，状态机将进入错误状态，这意味着状态机实例无法再处理事件。如果用户继续向状态机实例触发事件，将抛出一个<code>IllegalStateException</code>。</p><p>在转换阶段发生的所有异常(包括 操作执行 和 外部监听器调用)将被包装到<code>TransitionException</code>(未检查的异常)中。目前，默认的异常处理策略简单粗暴，只是继续抛出异常，请参阅<code>AbstractStateMachine.afterTransitionCausedException</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterTransitionCausedException</span><span class="params">(...)</span> &#123; <span class="keyword">throw</span> e; &#125;</span><br></pre></td></tr></table></figure><p>如果想状态机从该异常中恢复，用户可以扩展<code>afterTransitionCausedException</code>方法，并在该方法中添加相应的恢复逻辑。不要忘记在结束时将状态机状态设置为正常状态。如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterTransitionCausedException</span><span class="params">(Object fromState, Object toState, Object event, Object context)</span> &#123;</span><br><span class="line">  <span class="type">Throwable</span> <span class="variable">targeException</span> <span class="operator">=</span> getLastException().getTargetException();</span><br><span class="line">  <span class="comment">// recover from IllegalArgumentException thrown out from state &#x27;A&#x27; to &#x27;B&#x27; caused by event &#x27;ToB&#x27;</span></span><br><span class="line">  <span class="keyword">if</span>(targeException <span class="keyword">instanceof</span> IllegalArgumentException &amp;&amp; </span><br><span class="line">     fromState.equals(<span class="string">&quot;A&quot;</span>) &amp;&amp; toState.equals(<span class="string">&quot;B&quot;</span>) &amp;&amp; event.equals(<span class="string">&quot;ToB&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// do some error clean up job here | 执行异常清理工作</span></span><br><span class="line">    <span class="comment">// ... | 异常恢复逻辑</span></span><br><span class="line">    <span class="comment">// after recovered from this exception, reset the state machine status back to normal</span></span><br><span class="line">    setStatus(StateMachineStatus.IDLE); <span class="comment">// 异常逻辑恢复之后设置状态机为正常状态</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(...) &#123;</span><br><span class="line">    <span class="comment">// recover from other exception ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.afterTransitionCausedException(fromState, toState, event, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Advanced-Feature"><a href="#Advanced-Feature" class="headerlink" title="Advanced Feature"></a>Advanced Feature</h3><h4 id="Define-Hierarchical-State"><a href="#Define-Hierarchical-State" class="headerlink" title="Define Hierarchical State"></a><strong>Define Hierarchical State</strong></h4><p><strong>定义分层状态</strong></p><p>分层状态可以包含嵌套状态。子状态本身可以有嵌套的子状态，并且嵌套可以进行到任何深度。<strong>当层次状态处于活动状态时，它的一个子状态且只有一个子状态处于活动状态</strong>。层次状态可以通过API或注释来定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">defineSequentialStatesOn</span><span class="params">(S parentStateId, S... childStateIds)</span>;</span><br></pre></td></tr></table></figure><p>*builder.defineSequentialStatesOn(State.A, State.BinA, State.CinA) *在父状态“A”下定义了两个子状态“BinA”和“CinA”，第一个定义的子状态也将是分层状态“A”的初始状态。同样的层次状态也可以通过注释来定义，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@States(&#123;</span></span><br><span class="line"><span class="meta">  @State(name=&quot;A&quot;, entryMethodCall=&quot;entryA&quot;, exitMethodCall=&quot;exitA&quot;),</span></span><br><span class="line"><span class="meta">  @State(parent=&quot;A&quot;, name=&quot;BinA&quot;, entryMethodCall=&quot;entryBinA&quot;, exitMethodCall=&quot;exitBinA&quot;, initialState=true),</span></span><br><span class="line"><span class="meta">  @State(parent=&quot;A&quot;, name=&quot;CinA&quot;, entryMethodCall=&quot;entryCinA&quot;, exitMethodCall=&quot;exitCinA&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="Define-Parallel-State"><a href="#Define-Parallel-State" class="headerlink" title="Define Parallel State"></a><strong>Define Parallel State</strong></h4><p><strong>定义并行状态</strong></p><p>并行状态封装了一组子状态，<strong>这些子状态在父元素处于活动状态时同时处于活动状态</strong>。并行状态可以通过API或注释来定义。如：</p><img src="image-20230830105006436.png" alt="image-20230830105006436" style="zoom:30%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defines two region states &quot;RegionState1&quot; and &quot;RegionState2&quot; under parent parallel state &quot;Root&quot;</span></span><br><span class="line">builder.defineParallelStatesOn(MyState.Root, MyState.RegionState1, MyState.RegionState2);</span><br><span class="line"></span><br><span class="line">builder.defineSequentialStatesOn(MyState.RegionState1, MyState.State11, MyState.State12);</span><br><span class="line">builder.externalTransition().from(MyState.State11).to(MyState.State12).on(MyEvent.Event1);</span><br><span class="line"></span><br><span class="line">builder.defineSequentialStatesOn(MyState.RegionState2, MyState.State21, MyState.State22);</span><br><span class="line">builder.externalTransition().from(MyState.State21).to(MyState.State22).on(MyEvent.Event2);</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@States(&#123;</span></span><br><span class="line"><span class="meta">  @State(name=&quot;Root&quot;, entryCallMethod=&quot;enterRoot&quot;, exitCallMethod=&quot;exitRoot&quot;, compositeType=StateCompositeType.PARALLEL),</span></span><br><span class="line"><span class="meta">  @State(parent=&quot;Root&quot;, name=&quot;RegionState1&quot;, entryCallMethod=&quot;enterRegionState1&quot;, exitCallMethod=&quot;exitRegionState1&quot;),</span></span><br><span class="line"><span class="meta">  @State(parent=&quot;Root&quot;, name=&quot;RegionState2&quot;, entryCallMethod=&quot;enterRegionState2&quot;, exitCallMethod=&quot;exitRegionState2&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>得到平行状态的当前所有子状态:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stateMachine.getSubStatesOn(MyState.Root); <span class="comment">// return list of current sub states of parallel state</span></span><br></pre></td></tr></table></figure><p>当所有并行状态达到最终状态时，将触发Finish上下文事件。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析故障转移</title>
      <link href="/2023/08/23/%E6%B5%85%E6%9E%90%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/"/>
      <url>/2023/08/23/%E6%B5%85%E6%9E%90%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析故障转移"><a href="#浅析故障转移" class="headerlink" title="浅析故障转移"></a>浅析故障转移</h1><p><strong><font color="red">故障转移（failover），即当活动的服务或应用意外终止时，快速启用冗余或备用的服务器、系统、硬件或者网络接替它们工作。</font></strong> 故障转移(failover)与交换转移操作基本相同，只是故障转移通常是自动完成的，没有警告提醒手动完成，而交换转移需要手动进行。</p><p>对于要求高可用和高稳定性的服务器、系统或者网络，系统设计者通常会设计故障转移功能。</p><p>要使故障转移正常工作，必须有一个数据备份裸机服务器或虚拟机充当恢复站点系统，以便在发生故障时替换主站点。由于故障转移是灾难恢复中必不可少的步骤，因此数据备份系统本身必须不受故障影响。在服务器级别，自动故障转移通常使用一个“<a href="https://baike.baidu.com/item/%E5%BF%83%E8%B7%B3?fromModule=lemma_inlink">心跳</a>”线连接两台服务器。只要主服务器与备用服务器间脉冲或“心跳”没有中断，备用服务器就不会启用。为了热切换和防止服务中断，也可能会有第三台服务器运行备用组件待命。当检测到主服务器“心跳”报警后，备用服务器会接管服务。有些系统有发送故障转移通知的功能。</p><p>有些系统故意设计为不能进行完全自动故障转移，而是需要管理员介入。这种“人工确认的自动故障转移”配置，当管理员确认进行故障转移后，整个过程将自动完成。</p><h2 id="如何进行故障转移"><a href="#如何进行故障转移" class="headerlink" title="如何进行故障转移"></a>如何进行故障转移</h2><p>有两种方法可以设置故障转移系统： <strong>主动-主动</strong> 和 <strong>主动-被动（或主动-备用）</strong>配置。两种设置都需要至少两个节点（服务器或虚拟机）才能正常工作。</p><ul><li><font color="cornflowerblue">在主动-主动设置中，多个节点同时运行。这允许他们分担工作量并防止任何一个节点过载。如果一个节点停止工作，它的工作负载将被其他活动节点占用，直到它重新激活。</font><ul><li>例如：Dubbo架构部署的分布式系统，当一个节点宕机之后，其流量会被分配到其他可用节点上。</li></ul></li><li><font color="cornflowerblue">主动-被动（主动-备用）设置还包括多个节点，但并非所有节点都同时处于活动状态。一旦主动节点停止工作，被动节点就会被激活并充当故障转移节点。当主节点再次运行时，数据备份节点将操作切换回主节点并再次变为被动状态。</font><ul><li>例如：Zookeeper集群架构，Leader和Follow节点，当Leader节点宕机之后，会重新选取一个Follow节点接替Leader节点进行工作。</li></ul></li></ul><p>无论采用哪种故障转移方法，两种配置都要求每个节点具有相同的配置。这确保了在站点之间切换时的一致性和稳定性。</p><h2 id="什么是故障恢复"><a href="#什么是故障恢复" class="headerlink" title="什么是故障恢复"></a>什么是故障恢复</h2><p><strong>故障恢复</strong>(failback)是将系统，组件，服务恢复到故障之前的组态。使用<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96?fromModule=lemma_inlink">虚拟化</a>允许故障转移操作减少对硬件的依赖。</p><blockquote><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>在计算机技术中，<strong>虚拟化（技术）</strong>或<strong>虚拟技术</strong>（英语：<a href="https://baike.baidu.com/item/Virtualization/10102404?fromModule=lemma_inlink">Virtualization</a>）是一种资源管理技术，是将计算机的各种实体资源（<a href="https://baike.baidu.com/item/CPU?fromModule=lemma_inlink">CPU</a>、<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_inlink">内存</a>、磁盘空间、<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%82%E9%85%8D%E5%99%A8?fromModule=lemma_inlink">网络适配器</a>等），予以抽象、转换后呈现出来并可供分区、组合为一个或多个计算机配置环境。由此，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些计算机硬件资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/9827490?fromModule=lemma_inlink">数据存储</a>。</p></blockquote><p>故障恢复是在计划内或计划外中断解决后切换回主站点的过程。故障恢复通常在故障转移之后作为灾难恢复计划的一部分。<br>故障恢复不是完成故障转移的唯一方法。使用虚拟机时，您可以执行永久故障回复，使数据备份虚拟机成为新的主站点。</p><h2 id="如何进行故障恢复"><a href="#如何进行故障恢复" class="headerlink" title="如何进行故障恢复"></a>如何进行故障恢复</h2><p>成功执行故障回复需要一些准备。在切换回主站点之前，请考虑以下步骤：</p><p>1、检查与主站点的连接的质量和网络带宽。</p><p>2、检查备份站点上的所有数据是否存在潜在错误。这对于关键文件和文档尤其重要。</p><p>3、在开始故障恢复之前彻底测试所有主系统。</p><p>4、准备并实施故障恢复计划，以最大限度地减少停机时间和用户不便。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/qq_35634154/article/details/127047233">故障转移和恢复</a></p><p><a href="https://baike.baidu.com/item/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/14768924">故障转移</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故障转移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机业务场景</title>
      <link href="/2023/08/17/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/2023/08/17/%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在日常开发中经常遇到运营审核经销商活动、任务等等类似业务需求，大部分需求中状态稳定且单一无需使用状态机，但是也会出现大量的<code>if...else</code>前置状态代码，也是不够那么的“优雅”。随着业务的发展、需求迭代，每一次的业务代码改动都需要维护使用到状态的代码，更让开发人员头疼的是这些维护状态的代码，像散弹一样遍布在各个Service的方法中，不仅增加发布的风险，同时也增加了回归测试的工作量。</p><h3 id="什么是状态机？"><a href="#什么是状态机？" class="headerlink" title="什么是状态机？"></a>什么是状态机？</h3><p><strong>通常所说的状态机为有限状态机（英语：finite-state machine，缩写：FSM），简称状态机， 是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。</strong> </p><p>应用FSM模型可以帮助对象生命周期的状态的顺序以及导致状态变化的事件进行管理。 将状态和事件控制从不同的业务Service方法的<code>if else</code>中抽离出来。FSM的应用范围很广，状态机 可以描述核心业务规则，核心业务内容。无限状态机，顾名思义状态无限，类似于“π”，暂不做研究。</p><p>状态机可归纳为4个要素，即<strong>现态、条件、动作、次态</strong>。这样的归纳，主要是出于对状态机的内在因果关系的考虑。<strong>“现态”和“条件”是因</strong>，<strong>“动作”和“次态”是果</strong>。详解如下：</p><ol><li>现态：是指当前所处的状态。</li><li>条件：又称为“事件”，当一个条件被满足，将会触发一个动作，或者执行一次状态的迁移。</li><li>动作：条件满足后执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不 执行任何动作，直接迁移到新状态。</li><li>次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ol><p>动作是在给定时刻要进行的活动的描述。<strong>有多种类型的动作：</strong></p><ul><li>进入动作（entry action）：在进入状态时进行</li><li>退出动作（exit action）：在退出状态时进行</li><li>输入动作：依赖于当前状态和输入条件进行</li><li>转移动作：在进行特定转移时进行</li></ul><p><strong>其他术语：</strong></p><ul><li>Transition: 状态转移节点，是组成状态机引擎的核心。</li><li>source/from：现态。</li><li>target/to：次态。</li><li>event/trigger：触发节点从现态转移到次态的动作，这里也可能是一个timer。</li><li>guard/when：状态迁移前的校验，执行于action前。</li><li>action：用于实现当前节点对应的业务逻辑处理。</li></ul><p>文字描述比较不容易理解，让我们举个栗子：每天上班都需要坐地铁，从刷卡进站到闸机关闭这个过程，将闸机抽象为一个状态机模型，如下图：</p><img src="27422-20230508182520000-1244922968.jpg" alt="图片" style="zoom:80%;"><h3 id="什么场景使用？"><a href="#什么场景使用？" class="headerlink" title="什么场景使用？"></a>什么场景使用？</h3><p>以下的场景您可能会需要使用：</p><ul><li><p>您可以将应用程序或其结构的一部分表示为状态。</p></li><li><p>您希望将复杂的逻辑拆分为更小的可管理任务。</p></li><li><p>应用程序已经遇到了并发问题，例如异步执行导致了一些异常情况。</p></li></ul><p>当您执行以下操作时，您已经在尝试实现状态机：</p><ul><li><p>使用布尔标志或枚举来建模情况。</p></li><li><p>具有仅对应用程序生命周期的某些部分有意义的变量。</p></li><li><p>在<code>if...else</code>结构（或者更糟糕的是，多个这样的结构）中循环，检查是否设置了特定的标志或枚举，然后在标志和枚举的某些组合存在或不存在时，做出进一步的异常处理。</p></li></ul><h3 id="为什么要用？有哪些好处？"><a href="#为什么要用？有哪些好处？" class="headerlink" title="为什么要用？有哪些好处？"></a>为什么要用？有哪些好处？</h3><p>最初活动模块功能设计时，并没有想使用状态机，仅仅想把状态的变更和业务剥离开，规范状态转换和程序在不同状态下所能提供的能力，去掉复杂的逻辑判断也就是<code>if...else</code>，想换一种模式实现思路，此前了解过spring“全家桶”有状态机就想到了“它”，场景也符合。</p><p>从个人使用的经验，开发阶段和迭代维护期总结了以下几点：</p><ul><li>使用状态机来管理状态好处更多体现在代码的可维护性、对于流程复杂易变的业务场景能大大减轻维护和测试的难度。</li><li>解耦，业务逻辑与状态流程隔离，避免业务与状态“散弹式”维护，且状态持久化在同一个事务。</li><li>状态流转越复杂，越能体现状态流转的逻辑清晰，减少的“胶水”代码也越多。</li></ul><h2 id="Squirrel状态机"><a href="#Squirrel状态机" class="headerlink" title="Squirrel状态机"></a>Squirrel状态机</h2><p>Squirrel状态机是一种用来进行对象行为建模的工具，主要描述对象在它的生命周期内所经历的状态，以及如何响应来自外界的各种事件。比如订单的创建、已支付、发货、收获、取消等等状态、状态之间的控制、触发事件的监听，可以用该框架进行清晰的管理实现。使用状态机来管理对象生命流的好处更多体现在代码的可维护性、可测试性上，明确的状态条件、原子的响应动作、事件驱动迁移目标状态，对于流程复杂易变的业务场景能大大减轻维护和测试的难度。</p><p>Squirrel状态机是一种有限状态机，有限状态机是指对象有一个明确并且复杂的生命流（一般而言三个以上状态），并且在状态变迁存在不同的触发条件以及处理行为。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="店铺审核CASE"><a href="#店铺审核CASE" class="headerlink" title="店铺审核CASE"></a>店铺审核CASE</h4><p>举例，京东线上开店需要经过审核才能正式上线，店铺状态有待审核、已驳回、已审核，对应操作有提交审核，审核通过，审核驳回动作。现在需要实现一个店铺审核流程的需求。</p><h4 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h4><p><strong>常用if-else或switch-case实现（分支模式）</strong></p><img src="image-20230817174631564.png" alt="image-20230817174631564" style="zoom: 40%;"><p><strong>状态机实现</strong></p><img src="image-20230817174813510.png" alt="image-20230817174813510" style="zoom:40%;"><p>通过引入状态机，可以去除大量<code>if-else if-else</code>或者<code>switch-case</code>分支结构，<strong>直接通过当前状态和状态驱动表查询行为驱动表，找到具体行为执行操作，有利于代码的维护和扩展。</strong></p><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><img src="image-20230817175013768.png" alt="image-20230817175013768" style="zoom:45%;"><ul><li>StateMachine: StateMachine实例由StateMachineBuilder创建不被共享，对于使用annotation方式(或fluent api)定义的StateMachine，StateMachine实例即根据此定义创建，相应的action也由本实例执行，与spring的集成最终要的就是讲spring的bean实例注入给由builder创建的状态机实例；</li><li>StateMachineBuilder: 本质上是由StateMachineBuilderFactory创建的动态代理。被代理的StateMachineBuilder默认实现为StateMachineBuilderImpl，内部描述了状态机实例创建细节包括State、Event、Context类型信息、constructor等，同时也包含了StateMachine的一些全局共享资源包括StateConverter、EventConverter、MvelScriptManager等。StateMachineBuilder可被复用，使用中可被实现为singleton；</li><li>StateMachineBuilderFactory: 为StateMachineBuilder创建的动态代理实例；</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>todo…</p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.cnblogs.com/88223100/archive/2023/05/17/Spring-Statemachine-Application-Practice.html">Spring Statemachine应用实践</a></p><p><a href="https://baijiahao.baidu.com/s?id=1756234841103977369&wfr=spider&for=pc">Squirrel状态机-从原理探究到最佳实践</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型语法糖</title>
      <link href="/2023/08/08/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/08/08/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型语法糖"><a href="#泛型语法糖" class="headerlink" title="泛型语法糖"></a>泛型语法糖</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><blockquote><p><strong>泛型</strong>：Java语法糖。</p><p><strong>定义</strong>：语法糖（Syntactic Sugar），也称糖衣语法。是由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明的一个术语，指的是在计算机语言中添加的某种语法，<strong>这种语法对语言的编译结果和功能并没有实际影响， 但是却能更方便程序员使用该语言</strong>。</p><p><strong>作用</strong>：通常来说使用语法糖能够<strong>减少代码量、增加程序的可读性</strong>，从而<strong>减少程序代码出错</strong>的机会。</p></blockquote><p>泛型是Java SE 1.5的新特性，泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。</p><h2 id="泛型有什么好处"><a href="#泛型有什么好处" class="headerlink" title="泛型有什么好处"></a>泛型有什么好处</h2><p>在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p><img src="image-20230808163647956.png" alt="image-20230808163647956" style="zoom: 25%;"><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p><ol><li>注意泛型的类型必须是引用类型,泛型不能是基本数据类型,必须是其包装类。</li><li>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</li><li>泛型的类型参数可以有多个。</li><li>泛型的参数类型可以使用extends语句，例如 <code>&lt;T extends superclass&gt;</code>。习惯上称为“有界类型”。<ol><li> <code>&lt;T extends superclass&gt;</code> 上边界，泛型类是superclass的子类或其本身。</li><li> <code>&lt;T super subclass&gt;</code>  下边界，泛型类是subclass的父类获取本身。</li></ol></li><li>泛型的参数类型还可以是通配符类型。例如 <code>Class&lt;?&gt; classType = Class.forName(&quot;java.lang.String&quot;)</code> 。</li><li>指明泛型类型之后,在集合类或接口中凡是定义类或接口时,内部结构使用到类的泛型的位置,都使用指定的泛型类型；如: <code>add(E e)</code> —&gt; 实例化之后: <code>add(Integer i)</code></li><li>如果实例化时，没有指定泛型的类型，默认是 <code>java.lang.Object</code> 类型。</li></ol><p>没有泛型的时候是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">al.add(<span class="string">&quot;ysjian001&quot;</span>);</span><br><span class="line">al.add(<span class="number">1</span>);</span><br><span class="line">al.add(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure><p>这段代码看似功能强大，为什么呢？</p><p>因为它似乎能够往集合中添加各种类型的对象（int类型会被装箱成Integer对象类型），貌似一些老程序员也倾向于这么去做，而且他们可以理直气壮的告诉我理由：我这么做想存什么就存什么！先不否定这种说法，让我们继续，看看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) al.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>往集合里面存值就是为了后期取出来用的，而不是 <code>System.out.println(first)</code> ，这里就产生了一个强制类型转换问题，而这种<strong>类型强制转换在编译器中是允许通过</strong>的，而写程序的人们会犯下无意间的错误，错误的进行了强制转换，导致程序运行失败。</p><p>强制类型转换导致的程序运行失败的原因是没有在编译期间对类型进行控制，任何类型都可以添加，编译器无法进行错误检验，埋下了安全隐患，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">al.add(<span class="keyword">new</span> <span class="title class_">File</span>());  <span class="comment">// 无法进行错误检查，File对象可以添加进去，编译器和运行期都可以通过</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> (String) al.get(<span class="number">0</span>);  <span class="comment">// 强制类型转换失败导致运行失败</span></span><br></pre></td></tr></table></figure><p>没有泛型的程序面临两个问题：</p><ol><li><strong>编译器无法进行类型检查</strong>，可以向集合中添加任意类型的对象。</li><li>取值时类型转换失败导致程序运行失败。</li></ol><p>没有泛型的程序导致的后果：</p><ol><li>程序的可读性有所降低，因为程序员可以不受限制往集合中添加任意对象。</li><li>程序的安全性遭到质疑，可能会因为强制类型转换失败导致程序运行失败。</li></ol><p>Java5泛型提供了一个更好的解决方案：<strong>类型参数（type parameters），即 泛型</strong>，使用泛型的程序改善上述代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">al.add( <span class="string">&quot;ysjian001&quot;</span>); <span class="comment">// al.add(new Thread()); // 定义了String类型参数，添加File对象时编译会报错</span></span><br><span class="line"><span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span>  al.get(<span class="number">0</span>); <span class="comment">// 使用泛型后取值不用进行类型转换</span></span><br></pre></td></tr></table></figure><p>到这里，通过前后对比，泛型的好处是不是很清楚了呢？为什么用泛型呢？</p><p><strong>因为出现编译错误比类在运行时出现强制类型转换异常要好得多，泛型的好处在于提高了程序的可读性和安全性</strong>，这也是程序设计的宗旨之一。</p><h2 id="什么时候使用泛型"><a href="#什么时候使用泛型" class="headerlink" title="什么时候使用泛型"></a>什么时候使用泛型</h2><p>使用泛型类是一件很轻松的事，集合框架中的类都是泛型类，用起来很方便。有人会想类型限制我们为什么不直接用数组呢？这个问题就好像问为什么集合优于数组，数组是固定的，而集合是可以自动扩展的。另外在实际中，实现一个泛型其实并不是那么容易。</p><p>大多数程序员对泛型的熟练程度仅仅停留在使用泛型上，像集合类中的List、Set和Map这些泛型集合用的很多，他们不必考虑这些泛型集合的工作方式和原理。那么当把不同的泛型类混合在一起使用时，或者对Java5之前的遗留代码进行衔接时，可能会看到含糊不清的的错误消息。这样一来，程序员就需要学习Java泛型来解决问题了，而不是在程序中胡乱猜测了。最终，部分程序员可能想要实现自己的泛型类和泛型方法。</p><p>提炼出泛型程序设计的三种熟练程度就是：</p><ol><li>仅仅使用泛型。</li><li>学习泛型解决一些问题。</li><li>掌握泛型，实现自己的泛型。</li></ol><h2 id="怎么使用泛型"><a href="#怎么使用泛型" class="headerlink" title="怎么使用泛型"></a>怎么使用泛型</h2><p>如何使用泛型听起来是一件很容易的事情，因为Sun公司的那些工程师已经做了很大努力，而需求总是会稍微苛刻一点的，需要解决因为缺乏类型参数模糊不清的问题，或者我们有必要实现自己的泛型来满足业务需求，所以学习和掌握泛型是很有必要的。最常见的自定义泛型的场景是 <strong>泛型类</strong>、<strong>泛型方法</strong>、<strong>泛型接口</strong>。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>格式：<code>public class 类名&lt;泛型类型1,…&gt;</code></p><p>注意：泛型类型必须是引用类型</p><p>早期的时候，我们使用Object来代表任意的类型。向上转型是没有任何问题的，但是在向下转型的时候其实隐含了类型转换的问题。也就是说这样的程序其实并不是安全的。所以Java在JDK5后引入了泛型，提高程序的安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTool</span>&lt;T&gt; &#123; </span><br><span class="line">   <span class="keyword">private</span> T obj; </span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">getObj</span><span class="params">()</span> &#123;     </span><br><span class="line">     <span class="keyword">return</span> obj; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(T obj)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.obj = obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类的测试 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectToolDemo</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    ObjectTool&lt;String&gt; ot = <span class="keyword">new</span> <span class="title class_">ObjectTool</span>&lt;String&gt;();    </span><br><span class="line">    ot.setObj(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;中国&quot;</span>)); </span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ot.getObj(); </span><br><span class="line">    System.out.println(<span class="string">&quot;姓名是：&quot;</span> + s); </span><br><span class="line">    </span><br><span class="line">    ObjectTool&lt;Integer&gt; ot2 = <span class="keyword">new</span> <span class="title class_">ObjectTool</span>&lt;Integer&gt;();</span><br><span class="line">    ot2.setObj(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">69</span>)); </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> ot2.getObj(); </span><br><span class="line">    System.out.println(<span class="string">&quot;年龄是：&quot;</span> + i); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">姓名是：中国</span><br><span class="line">年龄是：69</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>格式: <code>public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTool</span> &#123;  </span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    System.out.println(t); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectToolDemo</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    <span class="comment">// 定义泛型方法后</span></span><br><span class="line">    <span class="type">ObjectTool</span> <span class="variable">ot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectTool</span>(); </span><br><span class="line">    ot.show(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    ot.show(<span class="number">100</span>);</span><br><span class="line">    ot.show(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以传递任意类型的参数了。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>格式：<code>public interface 接口名&lt;泛型类型1…&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inter</span>&lt;T&gt; &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类在实现接口的时候，我们会遇到两种情况</p><p><strong>第一种情况：已经知道泛型具体是什么类型的了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">implements</span> <span class="title class_">Inter</span>&lt;String&gt; &#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String t)</span> &#123; </span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种情况：还不知道泛型具体是什么类型的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Inter</span>&lt;T&gt; &#123; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123; </span><br><span class="line">    System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterDemo</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一种情况的测试</span></span><br><span class="line">    Inter&lt;String&gt; i = <span class="keyword">new</span> <span class="title class_">InterImpl</span>(); </span><br><span class="line">    i.show(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种情况的测试</span></span><br><span class="line">    Inter&lt;String&gt; i = <span class="keyword">new</span> <span class="title class_">InterImpl</span>&lt;String&gt;(); </span><br><span class="line">    i.show(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">    Inter&lt;Integer&gt; ii = <span class="keyword">new</span> <span class="title class_">InterImpl</span>&lt;Integer&gt;(); </span><br><span class="line">    ii.show(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型明确时，前后必须一致 </span></span><br><span class="line">    Collection&lt;Object&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    <span class="comment">// Collection&lt;Object&gt; c2 = new ArrayList&lt;Animal&gt;();//报错</span></span><br><span class="line">    <span class="comment">// Collection&lt;Object&gt; c3 = new ArrayList&lt;Dog&gt;();//报错</span></span><br><span class="line">    <span class="comment">// Collection&lt;Object&gt; c4 = new ArrayList&lt;Cat&gt;();//报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ?通配符表示任意的类型都是可以的</span></span><br><span class="line">    Collection&lt;?&gt; c5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    Collection&lt;?&gt; c6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">    Collection&lt;?&gt; c7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">    Collection&lt;?&gt; c8 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Cat&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ? extends E:向下限定，E及其子类</span></span><br><span class="line">    <span class="comment">// Collection&lt;? extends Animal&gt; c9 = new ArrayList&lt;Object&gt;();//报错</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; c10 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; c11 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt; c12 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Cat&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ? super E:向上限定，E极其父类</span></span><br><span class="line">    Collection&lt;? <span class="built_in">super</span> Animal&gt; c13 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">    Collection&lt;? <span class="built_in">super</span> Animal&gt; c14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line">    <span class="comment">// Collection&lt;? super Animal&gt; c15 = new ArrayList&lt;Dog&gt;();//报错</span></span><br><span class="line">    <span class="comment">// Collection&lt;? super Animal&gt; c16 = new ArrayList&lt;Cat&gt;();//报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>泛型擦除</p><h3 id="泛型擦除的原因"><a href="#泛型擦除的原因" class="headerlink" title="泛型擦除的原因"></a>泛型擦除的原因</h3><p><strong>原因一</strong>：JDK1.5及1.5之前都是没有泛型的概念的，JDK1.5之后引入了泛型的概念，<font color="cornflowerblue"><strong>为了与之前的JDK版本兼容，所以引入了泛型擦除的概念</strong></font>。<br><strong>原因二</strong>：<font color="cornflowerblue"><strong>若对每个泛型类型都生成不同的目标代码，就会生成多份字节码文件</strong></font>。如：现有10个不同泛型的List。<code>List&lt;Integer&gt;</code> 、<code>List&lt;String&gt;</code> 、…，就要生成10份字节码，这样会造成不仅造成代码膨胀，而且一份字节码对应一个Class对象，会占据大量的JVM内存。引入泛型擦除之后，多种不同泛型的应用类型只会生成一份字节码文件。</p><h3 id="泛型擦除规则"><a href="#泛型擦除规则" class="headerlink" title="泛型擦除规则"></a>泛型擦除规则</h3><ol><li><p>情况一：首先将 <strong>所有声明泛型的地方</strong> 都擦除，然后若 <strong>定义该泛型的地方</strong> 没有指定泛型上界，则 <strong>所有该泛型类型的变量的数据类型</strong> 在编译之后都替换为Object。</p><img src="d30995e7aa6e4ce9b5e9be98626b5d3b.png" style="zoom:80%;"></li><li><p>情况二：首先将 <strong>所有声明泛型的地方</strong> 都擦除，然后若 <strong>定义该泛型的地方</strong> 指定了泛型上界，则 <strong>所有该泛型类型的变量的数据类型</strong> 在编译之后都替换为泛型上界类型。</p><img src="ee9c8c80244b4377b78e1c7ef3cc5e5b.png" alt="在这里插入图片描述" style="zoom:80%;"></li></ol><p><strong>Demo1：</strong></p><p>泛型擦除，<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Double&gt;</code>   是同一个Class文件：<code>List.class</code>，同时 <code>new ArrayList&lt;Integer&gt;()</code> 和 <code>new ArrayList&lt;Double&gt;</code> 经过泛型擦除之后都是<code>ArrayList</code>对象。</p><img src="68aabef9758d4bc2ba45be27a2dc164c.png" alt="img" style="zoom:50%;"><p><strong>Demo2：</strong></p><p>编译期的泛型擦除，方法入参 <code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>的翻新被擦除之后都是<code>List</code>，方法的签名相同了，无法进行方法重载。</p><img src="effb8e3de87a447a9336ccd86c576445.png" alt="img" style="zoom:45%;"><h3 id="泛型擦除规则的验证"><a href="#泛型擦除规则的验证" class="headerlink" title="泛型擦除规则的验证"></a>泛型擦除规则的验证</h3><ol><li><p>方式一：通过Class对象验证：<strong>通过Class对象获取泛型信息</strong>，但是获取的泛型信息仅是占位符，并不是实际的泛型类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">System.out.println(Arrays.toString(list.getClass().getTypeParameters())); <span class="comment">// 输出：[E]</span></span><br><span class="line">System.out.println(Arrays.toString(map.getClass().getTypeParameters()));  <span class="comment">// 输出：[K, V]</span></span><br><span class="line"><span class="comment">// Class.getTypeParameters()获取当前Class对象中的泛型，以数据形式返回。</span></span><br></pre></td></tr></table></figure></li><li><p>方式二：通过反射机制验证：我们知道<font color="red"><strong>泛型只是用来对变量类型进行约束，这个约束只在编译阶段有效，在编译之后泛型就被擦除了</strong></font>。我们可以利用反射绕过泛型的约束检查。比如：</p></li></ol><img src="510a6ef7f598495aaa0482336687d380.png" alt="img" style="zoom:80%;"><p>因此，如果可以绕过编译阶段对泛型的约束检测，那么就可以传入任何类型的变量（因为都可以向上转型为Object类型），这就想到了反射，反射可以在运行时获取Class对象并操作，不受编译器的限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射绕过编译</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> list.getClass();</span><br><span class="line"><span class="comment">// 这里必须是Object，因为泛型擦除规则：ArrayList&lt;E&gt;中E没有泛型上界，所以泛型擦除后占位符E用Object代替</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">method.invoke(list, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印该集合</span></span><br><span class="line">System.out.println(list.toString());</span><br><span class="line"><span class="comment">// 从集合中获取元素,会有一个类型转换,对于反射放入的非String类型的元素值会抛出ClassCastException</span></span><br><span class="line">System.out.println(list.get(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[张三, 李四, 21]</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">at com.maple.reflect.Demo6_BeyondGeneric.main(Demo6_BeyondGeneric.java:43)</span><br></pre></td></tr></table></figure><h3 id="使用反射获取被擦除泛型信息的技巧"><a href="#使用反射获取被擦除泛型信息的技巧" class="headerlink" title="使用反射获取被擦除泛型信息的技巧"></a>使用反射获取被擦除泛型信息的技巧</h3><p>问：进行泛型擦除后的程序就能够在JDK1.5上正确执行了，那么还有必要保存原本的泛型信息吗？</p><p>答：会保存。所有类会先将自己类中涉及的所有实际泛型备份放在自己类中，然后再进行泛型擦除 【超级重要！！！】。</p><p>原理及获取方式：使用了泛型的类编译为class文件时会生成一个<code>signature</code>字段，而原本的泛型信息就被保存在class文件中<code>signature</code>指向的<font color="red"><strong>常量池</strong></font>中。<br><img src="a9e4cb7df7dd426f96074adca54b641b.png" alt="img" style="zoom:80%;"></p><p>但是<code>signature</code>是一个<code>private</code>修饰的属性，不能直接访问，只能通过反射访问。因为class文件中会生成一些<code>public</code>修饰的方法能将访问<code>signature</code>属性并获取相关信息。所以，在实际中一般采用这些方法来获取泛型，而不是直接使用<code>signature</code>字段。具体方法为：</p><img src="e4993af3fe904f94bb9340d06f884618.png" alt="img" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T, ID&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String, Integer&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取父类泛型类型</span></span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) B.class.getGenericSuperclass();</span><br><span class="line">        <span class="comment">// 获取泛型的具体类型集合</span></span><br><span class="line">        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">        <span class="keyword">for</span> (Type actualTypeArgument : actualTypeArguments) &#123;</span><br><span class="line">            System.out.println(actualTypeArgument);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.String</span><br><span class="line">class java.lang.Integer</span><br></pre></td></tr></table></figure><h3 id="泛型擦除导致的两大经典问题的解决方案"><a href="#泛型擦除导致的两大经典问题的解决方案" class="headerlink" title="泛型擦除导致的两大经典问题的解决方案"></a>泛型擦除导致的两大经典问题的解决方案</h3><p>泛型有3类：泛型类、泛型接口、泛型方法。但无论是哪种都会造成泛型擦除，而这也造成了问题：</p><p>问题1：由于泛型擦除，导致无法在 泛型类 中获取实际泛型类型<br>解决方法：使用匿名内部类</p><p>问题2：由于泛型擦除，导致无法在 泛型接口 进行 接口回调 之后获取实际泛型类型<br>解决方法：使用匿名内部类</p><blockquote><p>泛型方法的泛型擦除导致的问题，目前实际开发中还没有遇到，遇到了再补充…</p></blockquote><hr><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/qq_43546676/article/details/128790980">【Java】 泛型擦除</a></p><p><a href="https://baijiahao.baidu.com/s?id=1761849638395784359&wfr=spider&for=pc">Java常用的语法糖有哪些</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析加密、签名和数字证书</title>
      <link href="/2023/06/29/%E6%B5%85%E6%9E%90%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/"/>
      <url>/2023/06/29/%E6%B5%85%E6%9E%90%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析加密、数字签名和数字证书"><a href="#浅析加密、数字签名和数字证书" class="headerlink" title="浅析加密、数字签名和数字证书"></a>浅析加密、数字签名和数字证书</h1><blockquote><p><strong>Q:</strong></p><ol><li>非对称加密中公私钥都可以加密，那么什么时候用公钥”加密”，什么时候用私钥“加密” ？</li><li>什么是数字签名，数字签名的作用是什么？</li><li>为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？</li><li>什么是数字证书，数字证书解决了什么问题？</li></ol></blockquote><h2 id="什么是加密"><a href="#什么是加密" class="headerlink" title="什么是加密"></a>什么是加密</h2><p>加密就是<strong>对明文数据按某种特殊算法进行处理，使其成为不可读的一段代码，通常称为“密文”。</strong> 密文通过”密钥”解密后还原出原来的明文，通过这样的途径可以达到保护数据不被非法人窃取、阅读的目的。</p><p>考虑以下哪些属于加密方法：</p><ul><li><strong>AES</strong></li><li><strong>DES</strong></li><li><strong>RSA</strong></li><li>SM4</li><li>SHA</li><li>MD5</li><li>BASE64</li></ul><p>这几种都是日常开发中常用的<strong>数据编码技术</strong>，但是<strong>只有 AES、RSA、SM4 才能算是加密算法</strong>。</p><p>为什么呢？</p><p><strong>一个区分的简单方法就是****看编码后的数据是否能还原，能还原的才是加密算法。</strong></p><p>MD5 实际上是对数据进行<strong>有损压缩</strong>，无论数据有多长，1KB、1Mb 还是 1G，都会<strong>生成****固定 128 位的散列值（实际开发中会为以32位的十六进制字符串进行显示）</strong>，并且 MD5 理论上是不可能对编码后的数据进行还原的，即<strong>不可逆</strong>。MD5 因其具有不可逆性、单向恒定性[幂等性]（相同的数据多次计算值不变）被广泛应用于文件完整性验证、口令加密以及接下来会讲到的数字签名中。</p><p>SHA和MD5算法类似，SHA (Security Hash Algorithm) 安全哈希算法也是一种信息摘要生成算法。</p><p>使用非对称加密时的签名，使用私钥对摘要进行签名，这个过程称为数字签名 – 数字签名是专门针对使用非对称加密的场景。</p><p>如果不使用非对称加密，直接使用MD5和SHA1来实现签名和验签操作也是OK的。</p><p>至于 BASE64 是否算做加密方法，仁者见仁。在这里不下结论，因为 BASE64 编码不需要密钥，且编码后的字符串任何人都可以解码出原串，所以一般不认为是加密方法。<strong>BASE64 常用来做转码（重编码）</strong>，如: 把二进制字节序列转化为Base64字符序列。BASE64是一种编码格式。</p><p>Base64是网络上最常见的用于传输8Bit<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683?fromModule=lemma_inlink">字节码</a>的编码方式之一，Base64就是一种基于64个可打印字符来表示<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457?fromModule=lemma_inlink">二进制</a>数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3<em>8 = 4</em>6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3（代码Demo已验证）。</p><p>关于这个编码的规则：</p><ol><li>把3个字节变成4个字节。</li><li>每76个字符加一个换行符。</li><li>最后的结束符也要处理。</li></ol><p>Base64编码是从二进制到字符的过程，可用于在<a href="https://baike.baidu.com/item/HTTP?fromModule=lemma_inlink">HTTP</a>环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p><p>加密算法得出的加密字符串使用的是ASCII码字符集，ASCII码字符集有128个字符，其中96个为可见字符，剩下的为不可见字符。所以在使用加密算法进行加密的时候得到的加密字符串中可能会出现不可见的字符，这样会导致调用方无法正确的解析密文。因此在使用加密算法加密数据之后通常都会使用BASE64进行编码，确保密文的组成字符都是可见字符。</p><h3 id="BASE64转换表"><a href="#BASE64转换表" class="headerlink" title="BASE64转换表"></a>BASE64转换表</h3><table><thead><tr><th><strong>索引</strong></th><th><strong>对应字符</strong></th><th><strong>索引</strong></th><th><strong>对应字符</strong></th><th><strong>索引</strong></th><th><strong>对应字符</strong></th><th><strong>索引</strong></th><th><strong>对应字符</strong></th></tr></thead><tbody><tr><td>0</td><td><strong>A</strong></td><td>17</td><td><strong>R</strong></td><td>34</td><td><strong>i</strong></td><td>51</td><td><strong>z</strong></td></tr><tr><td>1</td><td><strong>B</strong></td><td>18</td><td><strong>S</strong></td><td>35</td><td><strong>j</strong></td><td>52</td><td><strong>0</strong></td></tr><tr><td>2</td><td><strong>C</strong></td><td>19</td><td><strong>T</strong></td><td>36</td><td><strong>k</strong></td><td>53</td><td><strong>1</strong></td></tr><tr><td>3</td><td><strong>D</strong></td><td>20</td><td><strong>U</strong></td><td>37</td><td><strong>l</strong></td><td>54</td><td><strong>2</strong></td></tr><tr><td>4</td><td><strong>E</strong></td><td>21</td><td><strong>V</strong></td><td>38</td><td><strong>m</strong></td><td>55</td><td><strong>3</strong></td></tr><tr><td>5</td><td><strong>F</strong></td><td>22</td><td><strong>W</strong></td><td>39</td><td><strong>n</strong></td><td>56</td><td><strong>4</strong></td></tr><tr><td>6</td><td><strong>G</strong></td><td>23</td><td><strong>X</strong></td><td>40</td><td><strong>o</strong></td><td>57</td><td><strong>5</strong></td></tr><tr><td>7</td><td><strong>H</strong></td><td>24</td><td><strong>Y</strong></td><td>41</td><td><strong>p</strong></td><td>58</td><td><strong>6</strong></td></tr><tr><td>8</td><td><strong>I</strong></td><td>25</td><td><strong>Z</strong></td><td>42</td><td><strong>q</strong></td><td>59</td><td><strong>7</strong></td></tr><tr><td>9</td><td><strong>J</strong></td><td>26</td><td><strong>a</strong></td><td>43</td><td><strong>r</strong></td><td>60</td><td><strong>8</strong></td></tr><tr><td>10</td><td><strong>K</strong></td><td>27</td><td><strong>b</strong></td><td>44</td><td><strong>s</strong></td><td>61</td><td><strong>9</strong></td></tr><tr><td>11</td><td><strong>L</strong></td><td>28</td><td><strong>c</strong></td><td>45</td><td><strong>t</strong></td><td>62</td><td><strong>+</strong></td></tr><tr><td>12</td><td><strong>M</strong></td><td>29</td><td><strong>d</strong></td><td>46</td><td><strong>u</strong></td><td>63</td><td><strong>/</strong></td></tr><tr><td>13</td><td><strong>N</strong></td><td>30</td><td><strong>e</strong></td><td>47</td><td><strong>v</strong></td><td></td><td></td></tr><tr><td>14</td><td><strong>O</strong></td><td>31</td><td><strong>f</strong></td><td>48</td><td><strong>w</strong></td><td></td><td></td></tr><tr><td>15</td><td><strong>P</strong></td><td>32</td><td><strong>g</strong></td><td>49</td><td><strong>x</strong></td><td></td><td></td></tr><tr><td>16</td><td><strong>Q</strong></td><td>33</td><td><strong>h</strong></td><td>50</td><td><strong>y</strong></td><td></td><td></td></tr></tbody></table><h3 id="加密算法的分类"><a href="#加密算法的分类" class="headerlink" title="加密算法的分类"></a>加密算法的分类</h3><p>加密算法按照加解密使用的密钥是否相同，可分为：</p><ul><li><p><strong>对称加密（Symmetric Cryptography）</strong></p></li><li><ul><li><strong>秘钥相同</strong></li><li><strong>AES，DES</strong></li></ul></li></ul><p><strong>AES和DES算法的主要区别</strong></p><p>AES与DES之间的主要区别在于加密过程。在DES中，将明文分为两半，然后再进行进一步处理；而在AES中，整个块不进行除法，整个块一起处理以生成密文。相对而言，AES比DES快得多，与DES相比，AES能够在几秒钟内加密大型文件。</p><p>由于DES中使用的共享密钥的比特大小较小，因此它被认为不如AES安全。DES被认为更容易受到暴力攻击，而到目前为止，尚未遇到任何严重攻击的AES。</p><p>在灵活性的基础上评估算法的实现，AES比DES更具灵活性，因为它允许包括128、192、256位在内的各种长度的文本，而DES允许对64位固定文本进行加密。</p><p>DES回合处理中使用的功能是扩展，置换和替换，具有回合键的XOR操作，而AES回合中使用的功能是子字节，移位行，混合列和添加回合键。AES实际上在硬件和软件实现上都是高效的，而DES最初只在硬件上有效。</p><p><strong>DES算法缺点：</strong></p><p>分组比较短、密钥太短、密码生命周期短、运算速度较慢。</p><p><strong>DES算法优点：</strong></p><p>DES算法具有极高安全性，到目前为止，除了用穷举搜索法对DES算法进行攻击外，还没有发现更有效的办法。</p><p><strong>AES算法缺点：</strong></p><p>目前尚未存在对AES 算法完整版的成功攻击，但已经提出对其简化算法的攻击。</p><p><strong>AES算法优点：</strong></p><p>1、运算速度快，对内存的需求非常低，适合于受限环境。</p><p>2、分组长度和密钥长度设计灵活， AES标准支持可变分组长度，分组长度可设定为32比特的任意倍数，最小值为128比特，最大值为256比特。</p><p>3、 AES的密钥长度比DES大，它也可设定为32比特的任意倍数，最小值为128比特，最大值为256比特，所以用穷举法是不可能破解的。</p><p>4、具有很好的抵抗差分密码分析及线性密码分析的能力。</p><p><strong>总而言之，AES和DES算法之间的区别就是加密过程，这两种算法都有自己的优缺点，相对来说，AES比DES安全性高，运算速度快。</strong></p><ul><li><p><strong>非对称加密（Asymmetric Cryptography）</strong></p></li><li><ul><li><strong>秘钥不同</strong></li><li><strong>RSA</strong></li></ul></li></ul><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密是指加密和解密时使用同一个密钥。</p><img src="image-20230629194658600.png" alt="image-20230629194658600" style="zoom: 33%;"><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密是指加密和解密使用不同的密钥，这两个密钥分别叫做「公钥」、「私钥」。</p><p>公钥是可以公开给所有人的，而私钥需要自己保密的。公钥加密的数据只能用私钥解密。</p><img src="image-20230629194750698.png" alt="image-20230629194750698" style="zoom:33%;"><p>同理，私钥“加密”的数据只能用公钥“解密”：</p><img src="image-20230629194830702.png" alt="image-20230629194830702" style="zoom:33%;"><p>大家注意到没， <strong>私钥“加密”</strong> 这里打了引号，为什么呢？</p><p>因为私钥不是用来加密的，准确的说法应该是 <font color="red"><strong>「私钥签名，公钥验签」</strong></font>。</p><p>这个问题很多同学都存在误解，认为公私钥都可以用于加密。实际上不是的，至于为什么，后面会解释的。</p><p>这么看来，非对称加密的公私钥就有两种玩法了，如下两种场景:</p><ul><li><strong>加密场景</strong><ul><li><font color="green">公钥加密 –&gt; 私钥解密</font></li></ul></li><li><strong>数字签名场景</strong><ul><li><font color="green">私钥签名（也就是加密操作，只是称呼不一样） –&gt; 公钥验签（也就是解密操作，称呼不一样）</font></li></ul></li></ul><p>接下来引入一个小故事继续后续内容。</p><p><strong>故事开始</strong></p><p><strong>第一回合</strong></p><p>Bob 想约 Alice 出来玩，于是给 Alice 发了一封邮件：</p><img src="image-20230629195514420.png" alt="image-20230629195514420" style="zoom:33%;"><p>但我们都知道网络是不可信的，并且由于消息在网络中是明文传输的，所以黑客可以轻易的截获、篡改甚至冒充 Bob。来，我们看看黑客 Eve 是怎么干的：</p><img src="image-20230629195550962.png" alt="image-20230629195550962" style="zoom:33%;"><p>瞧，Eve 轻易的拿到了邮件内容 （<strong>窃听</strong>），并且修改了邮件内容 （<strong>篡改</strong>），甚至说他可以随时冒充 Bob 给 Alice 发送邮件 （伪装）。如果上图中 Eve 伪造的内容被 Alice 接收到了，那么后果可想而知。现实世界中，我们每天都在通过网络进行聊天、转账、浏览不存在网站。如果都是这样明文传输数据，显然毫无安全感。</p><p><strong>第二回合</strong></p><p>既然我们不能明文传输，那么 Bob 和 Alice 提前商量好密钥，使用对称加密对邮件内容加密不就好了~</p><img src="image-20230629195626990.png" alt="image-20230629195626990" style="zoom:33%;"><p>现在 Bob 发送的邮件都使用和 Alice 提前商量好的密钥加密后再传输。由于没有密钥，Eve 就算截获到数据也无法获取邮件的内容，也没法篡改和冒充 Bob。因为篡改后的数据必须使用密钥再次加密 Alice 才能正确解密。那么只要 Bob 和 Alice 能够保证密钥不泄露，整个通信就是安全的。如果密钥泄露，被中间人截获，那么就等同于明文通信。所以我们不能把安全性寄托在人上面[这也是开发中需要规避的问题，相当于不要依赖调用方的入参不发生错误]。并且这里也存在一个问题，如果两个人不能线下见面， 如何在网上安全的交换密钥呢？</p><p>这似乎是无解的，因为交换密钥的时候我们必须明文通信，不然对方根本看不懂。但是明文交换即意味着可能泄露。但是别忘了我们的密码学工具箱里还有一个好东西 — 「非对称加密」。</p><p>Bob 和 Alice 各自生成一对公私钥，因为公钥本来就是公开的，可以被任何人获取，所以可以通过网络明文交换公钥。然后使用公钥加密邮件内容后发送给对方，接收者使用自己的私钥即可解密。完美~</p><p><strong>第三回合</strong></p><p>来看看，在非对称加密体系下，Bob 如何给 Alice 发消息的。</p><p>首先 Alice 需要先生成一对公私钥，私钥只能 Alice 自己知道，公钥是可以让任何人都知道的，因此可将公钥直接发送给 Bob，就算被截获也无所谓。</p><img src="image-20230629195714586.png" alt="image-20230629195714586" style="zoom:33%;"><p>Bob 使用 Alice 的公钥加密邮件内容，加密后的内容只能由 Alice 的私钥解密，所以就算 Eve 截获也是徒劳。反之，如果 Alice 想给 Bob 回信，就需要用 Bob 的公钥加密后发送。这就解决了密钥交换问题，也保证了邮件内容不会泄露。也就是说现在可以防窃听。</p><p><strong>如何证明 Bob 是 Bob</strong></p><p>不知道你注意到没有，这里也存在另外一个问题：Eve 也可以使用 Alice 的公钥冒充 Bob 给 Alice 发邮件啊，因为 Alice 的公钥本来就是公开的，任何人都可以获得。由于 Eve 也可以获得 Alice 公钥，所以没法防止 Eve 伪装和篡改，并且对于 Alice 而言，她无法分辨出邮件到底是 Eve 发的还是 Bob。所以这个问题的本质就是 「Alice 如何确认邮件来自于 Bob」。</p><p>那么在生活中，我们如何做这件事呢？</p><p>那就是让 Bob 在纸上签名并且按手印，因为指纹和字迹是 Bob 独有的，其它人很难伪造。所以我们需要在计算机中引入类似的机制：即只有 Bob 自己能够产生的独一无二的标志，并且其它人能够验证这个标志确实是属于 Bob的。</p><p>这就是我们今天要讲的主题—<font color="red">「<strong>数字签名</strong>」</font>。</p><p>还记得什么是 Bob 独有的吗？</p><p>对，就是 Bob 自己的私钥，Bob 用自己的私钥对邮件内容计算一个「签名」，将「签名」和邮件内容一起发送出去，接受者 Alice 可以使用 Bob 的公钥验证这个签名是否正确，这就叫「验签」。如果不是 Bob 的私钥计算的签名，那么 Alice 用 Bob 公钥验签将会出错。</p><img src="image-20230629195851532.png" alt="image-20230629195851532" style="zoom:33%;"><p>可以看到， Eve 试图使用自己的私钥计算签名然后发送给 Alice， 但是 Alice 使用 Bob的公钥进行验签时将会出错！</p><p>那么 Eve 可能篡改内容并冒充 Bob 的签名吗？不可能！因为内容发生改变时，对应的签名也需要重新计算，而签名的生成依赖于私钥，只要 Bob 的私钥不泄露，签名就不会被冒充。啊啥？你说万一私钥泄露了怎么办？那就当我没说…</p><p>所以<strong>使用数字签名，我们能够鉴别消息的发送者</strong>，也就是说黑客无法伪装发送者进行发送数据，也无法篡改。</p><blockquote><p><strong>注意：</strong></p><p>可以看出我们这里数据是明文传输的，存在窃听风险。这是我们为了阐述数字签名机制是如何运转的，故意将保证信息机密性的机制省略了。<strong>如果想要保证数据的机密性，我们常见的做法是，通信双方通过非对称加密安全交换对称加密的密钥，后续通信过程的数据都使用对称加密保证数据机密性。</strong>并且「签名」的作用本身也不是用来保证数据的机密性，而是用于验证数据来源的防止数据被篡改的，也就是确认发送者的身份。</p></blockquote><p>一般而言，我们不会直接对数据本身直接计算数字签名，为什么呢？</p><p>因为数字签名属于非对称加密，非对称加密依赖于复杂的数学运算，包括大数乘法、大数模等等，耗时比较久。如果数据量大的时候计算数字签名将会比较耗时，所以一般做法是先将原数据进行 Hash 运算，得到的 Hash 值就叫做「摘要」。</p><p>「摘要」就像人的指纹一样，可以代表一个人，只要内容发生了改变，计算出来的摘要也应该变化。</p><p>「摘要」最好是不可逆转的，一般使用开头提到的 MD5 作为 Hash 函数，MD5 输出的结果固定位 128 位。</p><blockquote><p><strong>为什么「摘要」最好是不可逆转的？</strong></p><p>因为既然 Alice 可以用 Bob 公钥解开签名，那么理论上其它人，比如 Eve 也可以使用 Bob 公钥解开签名拿到数据。所以我们最好对数据的「摘要」进行签名，这样，Eve 就算解开签名，拿到的也是「摘要」，如果摘要是不可逆转的，也就是无法从摘要反推出原文，也就达到了保密的作用。</p></blockquote><p>发送者使用私钥对「摘要」计算数字签名。那么接收者如何验证呢？</p><img src="image-20230629195948011.png" alt="image-20230629195948011" style="zoom:33%;"><ol><li>接受者 Alice 收到后，取下数字签名，同时用 Bob 的公钥解密，得到「摘要1」，<strong>证明确实是 Bob 发的</strong>。*( 画外音：如果使用 Bob 的公钥验证签名出错，那么签名一定不是 Bob 的私钥生成的）*</li><li>再对邮件内容使用相同的散列函数计算「摘要2」，与上面得到的「摘要1」进行对比，<strong>两者一致就说明信息未被篡改。</strong>这样两步分别证明发送者身份和保证数据未被篡改。</li></ol><p><strong>这就够了吗？</strong></p><p>Bob 和 Alice 现在可以依赖于对称加密进行保密通信，也可以依赖于数字签名验证消息是否是对方发送的。<strong>但是这一切的根基是建立在 Alice 持有的公钥确实是 Bob的，反之亦然。</strong></p><p>什么意思呢？</p><p>试想，<strong>Eve 如果将自己的公钥冒充 Bob 发送给 Alice，然后 Alice 保存了下来，那以后凡是 Bob 发送的消息，反而会验证签名失败，被当做冒充者。</strong>那你可能会问，为什么 Eve 可以将自己的公钥发送给 Alice，而 Alice 毫不知情呢？</p><img src="image-20230629200026445.png" alt="image-20230629200026445" style="zoom:33%;"><p>看！我们又回到了最初的起点，只不过这次被篡改的是公钥，之前是消息本身。因为 Bob 的公钥是直接通过网络发送给 Alice的，所以 Eve 才可以在这一步做手脚，进行篡改，将自己的公钥冒充 Bob 发送给 Alice，也就是发送公钥这一步没有做到：</p><ul><li><strong>防篡改</strong></li><li><strong>防冒充</strong></li></ul><p>防篡改怎么和防冒充怎么实现的呢？我们前面讲了，就是靠数字签名！ 但是数字签名需要接受者持有发送者公钥，才能进行验签。<strong>而我们现在处理的是分发公钥这一步，所以…死锁了。这像是先有鸡还是先有蛋的问题。</strong></p><p>现在的问题就是「Bob 无法证明它自己是 Bob」。</p><p>这个是不是似曾相识，以前去办事的时候经常被要求出具「我妈是我妈」这类证明。但是我们自己说“我妈就是我妈”，人家根本不会信呀，需要一个可信第三方出具证明，比如派出所。</p><p>那么「Alice 如何才能确认 Bob 发送给自己的公钥确实是 Bob 的，而没有被篡改？」在只有 Alice 和 Bob 两人的情况下是没法验证的。所以，我们这里也需要一个第三方帮 Bob证明 「Bob 的公钥就是 Bob 的公钥」，有点绕口令那感觉了~</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>为了解决这个问题，就引入了「数字证书」，什么叫数字证书呢？</p><p>百度百科：</p><p>数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。</p><p>因此数字证书又称为数字标识。数字证书对网络用户在交流中的信息和数据等以加密或解密的形式保证了信息和数据的完整性和安全性。</p><p>看了这个描述，是不是感觉还是云里雾里，还是我用大白话来说吧~</p><p><strong>只要你理解了前面的数字签名，就能理解这里的数字证书，因为我把数字证书叫做「<strong><strong>公钥的数字签名</strong></strong>」。</strong></p><p>为什么呢？我们引入数字证书的目的是为了保证公钥不被篡改，即使被篡改了也能识别出来。</p><p>而防篡改的方法就是数字签名，但是这个签名不能我们自己做，原因说过了，因为我们的公钥还没分发出去，别人无法验证。所以只能找可信的第三方来帮我们签名，即证书颁布机构（CA），CA 会将：证书的颁布机构、有效期、公钥、持有者(subject)等信息用 CA 的私钥进行签名。并且将签名结果和这些信息放在一起，这就叫做「数字证书」。</p><p>这样，Bob 就可以去 CA 申请一个证书，然后将自己的证书发给 Alice，那么 Alice 如何验证这个证书确实是 Bob的呢？</p><p>当然是使用 CA 的公钥进行验签。</p><p><strong>注意：</strong></p><p>CA 的公钥也是需要使用证书来分发的，所以 Alice 的电脑必须安装 CA 的证书，证书里包含了 CA 的公钥。</p><p>收到 Bob 发过来的数字证书后，Alice 使用 CA 的公钥进行验证，验证通过即证明这确实是 Bob 证书，也就可以使用证书中包含的 Bob 的公钥，按照之前讨论的流程进行通信。</p><p>那么 Eve 是否可以在中途篡改 Bob 的证书呢？</p><p>答案：不行，因为证书的信息使用 CA 的私钥进行签名，只要 Eve 修改了任何一个 Bit 都会导致最后签名验证不通过。</p><p>那 Eve 可不可以修改证书信息后自己重新计算一次证书的数字签名呢？</p><p>也不行，因为证书的数字签名计算依赖于 CA 的私钥，Eve 是拿不到 CA 的私钥的。</p><p>如果拿到了，说明什么？整个世界都是不可信的。</p><p><strong>数字证书长啥样</strong></p><p>这是我电脑中的自带的证书：</p><img src="image-20230629200113061.png" alt="image-20230629200113061" style="zoom:33%;"><p>可以看到，包含了证书持有人的公钥和证书的签名。另外，证书颁发机构是有层级关系的，下级 CA 的证书是需要由上级 CA 签名的。</p><p>换句话说一定存在根证书颁发机构，那么他们的证书是由谁签名的呢？</p><p>答案是自签，自己给自己认证。</p><p>这是我电脑中的一个自签的根证书颁发机构：</p><img src="image-20230629200156426.png" alt="image-20230629200156426" style="zoom:33%;"><p>为什么根证书可以自签，谁来保证安全？</p><p>你把钱存在银行，你会担心吗？我们基于对国家的信任，才信任银行，这就是信任链的基础！我们思考问题应该是分层的，如果不认可一个统一的基础，一直套娃下去，那么问题就无解。</p><p>那还有个问题，如何保证根证书的可靠性？</p><p>这是操作系统和浏览器预装的，由微软、苹果等操作系统厂商来选择根证书。</p><p><strong>证书不可信？</strong></p><p>那么什么情况下浏览器会提示 “证书不可信” 呢？</p><p>根据我们上面的分析，下面是可能的原因：</p><ul><li>证书不是权威 CA 颁发</li></ul><p>有些企业为了贪图便宜使用盗版的证书，没有经过 CA 认证。也就是无法使用浏览器内置 CA 公钥进行验证。</p><ul><li>证书过期</li></ul><p>上面说了，证书里有一项就是有效期，一般就是一年或者两年的时间。如果证书过期，那么浏览器就会提示“证书不可信”</p><ul><li>证书部署错误</li></ul><p>可能是服务器证书部署出错，比如证书与域名不匹配，因为证书里有一项是持有人信息的。</p><p>好了，饶了一大圈，Bob 终于可以安全的向 Alice 发出前往红树林的邀请了~</p><blockquote><p><strong>QA</strong></p><p>现在我们来回答文章开头提出的一些问题：</p><ol><li><p>非对称加密中公私钥都可以加密，那么什么时候用公钥加密，什么时候用私钥“加密” ？</p></li><li><ol><li>加密场景，那么肯定希望只有我才能解密，别人只能加密。即<strong>公钥加密，私钥解密。</strong></li><li>签名场景，既然是签名，就希望只能我才能签名，别人只能验证。即<strong>私钥签名，公钥验签</strong></li></ol></li><li><p>什么是数字签名，数字签名的作用是什么？</p></li><li><ol><li>数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。</li><li>可以起到防篡改、防伪装、防否认的作用。</li></ol></li><li><p>为什么要对数据的摘要进行签名，而不是直接计算原始数据的数字签名？</p></li><li><ol><li>数据可能比较大，签名是使用非对称加密算法，比较耗时。</li><li>防止第三方使用公钥解开签名后，拿到原始数据。</li></ol></li><li><p>什么是数字证书，数字证书存在解决了什么问题？</p></li><li><ol><li>数字证书就是由 CA 机构使用自己私钥，对证书申请者的公钥进行签名认证。</li><li>数字证书解决了如何安全分发公钥的问题，也奠定了信任链的基础。</li></ol></li></ol></blockquote><hr><p><strong>参考:</strong></p><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书</a></p><p><a href="https://zhuanlan.zhihu.com/p/469646140">什么是数字签名</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密、签名、数字证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅对接第三方API</title>
      <link href="/2023/06/28/%E4%BC%98%E9%9B%85%E5%AF%B9%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9API/"/>
      <url>/2023/06/28/%E4%BC%98%E9%9B%85%E5%AF%B9%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9API/</url>
      
        <content type="html"><![CDATA[<h1 id="优雅对接第三方API"><a href="#优雅对接第三方API" class="headerlink" title="优雅对接第三方API"></a>优雅对接第三方API</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常的开发中，我们难免会遇见需要和第三方系统进行交互的需求，此时如何设计优雅地对第三方暴露的API就很重要了，不然就可能会出现接口被刷、数据泄露等安全问题。</p><blockquote><p><strong>非技术对接需要注意的点：</strong></p><ul><li><p>与第三方平台对接时，一定要积极和谐友善沟通，要是自己沟通不融洽，对自己的开发进度以及整体团队的对接进度就得往后延期了。</p></li><li><p>沟通方向要在同个频道，不然可能带来的影响就是：自己写完api文档之后，发给对方之后，发现写得完全就不在方向上，这就很尴尬了。</p></li></ul></blockquote><h2 id="第三方API对接"><a href="#第三方API对接" class="headerlink" title="第三方API对接"></a>第三方API对接</h2><h3 id="1-网络协议方面"><a href="#1-网络协议方面" class="headerlink" title="1. 网络协议方面"></a>1. 网络协议方面</h3><p>尽量规范双方使用https协议，因为https是http协议的升级版本，可通过对网络浏览器和网络服务器中间传输的数据进行加密，安全性方面还是比http协议高很多的，从谷歌规范来说，也是使用https协议的。虽然使用成本相对高一些，但这是值得的。</p><h3 id="2-接口请求方面"><a href="#2-接口请求方面" class="headerlink" title="2. 接口请求方面"></a>2. 接口请求方面</h3><ol><li>接口请求类型（GET|POST|PUT|DELETE等等）看具体业务场景规定好；</li><li>入参的数据类型要规定好；</li><li>数据合法性校验：常规性校验以及业务校验； <ul><li>常规性校验：包括签名校验，必填校验，长度校验，类型校验，格式校验等； </li><li>业务校验：根据实际业务而定，比如订单金额不能小于0等；</li></ul></li></ol><p>这里如果使用POST请求的时候，基本是规定数据传参格式为：<code>application/json</code> , Json格式的入参可以支持参数值拓展，对于之后的业务迭代还是友好的。</p><h3 id="3-接口加签验签-加密解密"><a href="#3-接口加签验签-加密解密" class="headerlink" title="3.接口加签验签/加密解密"></a>3.接口加签验签/加密解密</h3><p>对接口的参数进行加签/加密，然后被调用系统可以使用双方规定好的验签/解密方式校验接口的参数是否有效，这样能够大大有利的避免许多不必要的安全隐患。</p><p>此处介绍加密、加签的基本方案和步骤。详细了解请见：<a href="/maple/2023/06/29/%E6%B5%85%E6%9E%90%E5%8A%A0%E5%AF%86%E3%80%81%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">浅析加密、签名和数字证书</a></p><h4 id="加签验签"><a href="#加签验签" class="headerlink" title="加签验签"></a>加签验签</h4><p>常见的签名方法有MD5，SHA1等，签名基本原理是通过 <code>key/secret</code> 的实现：</p><ol><li>服务器负责为每个客户端生成一对 key/secret （ key/secret 没有任何关系，不能相互推算），保存并告知客户端。</li><li>当客户端调用 api 时，根据制定规则将所有请求参数串联起来并用 secret 生成签名 sign，同时可以考虑加盐 。</li><li>将 sign 和 key 一起放进请求参数对服务器进行调用。（注意 secret 不要传）</li><li>服务端收到请求，根据 key 去查 secret ，然后用同样的算法，验证签名。</li><li>为避免重放攻击，可加上 timestamp 参数，指明客户端可进行调用的时间窗口限制。</li></ol><blockquote><p>在实际开发中使用key去查询secret的操作略显笨重，而是采用直接线下将secret直接给到对方。</p></blockquote><h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><p>对称加密 or 非对称加密。</p><h3 id="4-日志记录"><a href="#4-日志记录" class="headerlink" title="4.日志记录"></a>4.日志记录</h3><p>对于我们接口接收到的数据，以及解析之后的参数值，都用埋点日志记录下来，以防在线上服务器出问题的时候，我们找不到对应的入参数据去排查线上问题。</p><h3 id="5-幂等校验"><a href="#5-幂等校验" class="headerlink" title="5.幂等校验"></a>5.幂等校验</h3><p>在日常的系统api调用中，会可能由于用户误触或者网络波动等原因，同一个时刻会多几次调用接口，我们要在实现具体业务操作之前，加一个幂等校验，例如可以对该数据中的唯一值做记录，要是先查到，就不继续实现具体业务操作，而是返回响应成功（注意：这里幂等校验要查找到该数据已经有成功调用过了，就直接返回响应成功，而不是响应失败等其他提示信息）。</p><h4 id="常见的幂等校验实现方式"><a href="#常见的幂等校验实现方式" class="headerlink" title="常见的幂等校验实现方式"></a>常见的幂等校验实现方式</h4><ul><li>分布式锁实现的并发幂等校验</li><li>数据库层select实现前置幂等校验</li><li>基于缓存+MD5实现可控时间窗口的幂等校验</li></ul><h3 id="6-补偿重试机制"><a href="#6-补偿重试机制" class="headerlink" title="6.补偿重试机制"></a>6.补偿重试机制</h3><p>比如在电商系统中，由于大促等促销活动有可能随时产生非常大的并发，要这时候要是第三方系统刚好调用我们系统的api接口，我们的服务器刚好短暂宕机，那这可能会造成大量的数据丢失。这中间是涉及到钱的，要真的发生了，可能狗头不保，直接GG。为了保住狗头，还是需要让对方去做接口的重试机制，要是接口响应不成功，可以规定之后一定的频率回调我们的接口，比如每隔3分钟重新发起一次调用，直到累积到10次都不成功，就认为失败，要是最后一次也是调用不成功的话，基本是要把调用不成功的接口信息落库，存到mysql、redis、或者es等数据源，等事后人工干预。</p><h3 id="7-安全机制"><a href="#7-安全机制" class="headerlink" title="7.安全机制"></a>7.安全机制</h3><p>到了对接的业务上线之后，接口加密的数据有可能是会被不明第三方抓包以及破译的，这时候更加需要从其他方面去提升安全等级，例如：<strong>定期更换密钥</strong>。除了防住黑的一方，也有白的一方需要防范，白是谁，当然是指我们这些本身开发这块业务的开发者，这个怎么防范，只能提高自己本身的职业素质了。</p><h3 id="8-AppId机制"><a href="#8-AppId机制" class="headerlink" title="8.AppId机制"></a>8.AppId机制</h3><p>大部分网站基本都需要用户名和密码才能登录，并不是谁来能使用我的网站，这其实也是一种安全机制；对应的对外提供的接口其实也需要这么一种机制，并不是谁都可以调用，需要使用接口的用户需要在后台开通appid，提供给用户相关的密钥；在调用的接口中需要提供appid+密钥，服务器端会进行相关的验证；</p><h3 id="9-限流机制"><a href="#9-限流机制" class="headerlink" title="9.限流机制"></a>9.限流机制</h3><p>本来就是真实的用户，并且开通了appid，但是出现频繁调用接口的情况；这种情况需要给相关appid限流处理，常用的限流算法有令牌桶和漏桶算法；</p><p>常用的限流算法包括：令牌桶限流，漏桶限流，计数器限流；</p><h4 id="1-令牌桶限流"><a href="#1-令牌桶限流" class="headerlink" title="1.令牌桶限流"></a>1.令牌桶限流</h4><p>令牌桶算法的原理是系统以一定速率向桶中放入令牌，填满了就丢弃令牌；请求来时会先从桶中取出令牌，如果能取到令牌，则可以继续完成请求，否则等待或者拒绝服务；令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌；</p><h4 id="2-漏桶限流"><a href="#2-漏桶限流" class="headerlink" title="2.漏桶限流"></a>2.漏桶限流</h4><p>漏桶算法的原理是按照固定常量速率流出请求，流入请求速率任意，当请求数超过桶的容量时，新的请求等待或者拒绝服务；可以看出漏桶算法可以强制限制数据的传输速度；</p><h4 id="3-计数器限流"><a href="#3-计数器限流" class="headerlink" title="3.计数器限流"></a>3.计数器限流</h4><p>计数器是一种比较简单粗暴的算法，主要用来限制总并发数，比如：数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流；</p><p>具体基于以上算法如何实现，Guava提供了RateLimiter工具类基于基于令牌桶算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>以上代码表示一秒钟只允许处理五个并发请求，以上方式只能用在单应用的请求限流，不能进行全局限流；</p><p>这个时候就需要分布式限流，可以基于redis+lua来实现或者Sentinel的集群分布式限流。</p><h3 id="10-黑名单机制"><a href="#10-黑名单机制" class="headerlink" title="10.黑名单机制"></a>10.黑名单机制</h3><p>如果此appid进行过很多非法操作，或者说专门有一个中黑系统，经过分析之后直接将此appid列入黑名单，所有请求直接返回错误码；</p><hr><h2 id="Java-后端开发常用的-10-种第三方服务"><a href="#Java-后端开发常用的-10-种第三方服务" class="headerlink" title="Java 后端开发常用的 10 种第三方服务"></a><a href="https://www.cnblogs.com/qing-gee/p/13651693.html">Java 后端开发常用的 10 种第三方服务</a></h2><p>严格意义上说，所有软件的第三方服务都可以自己开发，不过从零到一是需要时间和金钱成本的。就像我们研发芯片，投入了巨大的成本，但仍然没有取得理想的成绩，有些事情并不是一朝一夕，投机取巧就能完成的。</p><p>Java 后端开发通常会涉及到很多第三方服务，那么都有哪些成熟的方案可供直接上手使用呢？</p><img src="image-20230628155349797.png" alt="image-20230628155349797" style="zoom:67%;"><p><strong>1）IaaS</strong></p><p>IaaS 的英文全称是 Infrastructure as a Service，即基础设施服务，指把 IT 基础设施作为一种服务通过网络对外提供，并根据用户对资源的实际使用量或占用量进行计费的一种服务模式。IaaS 可根据需求快速纵向扩缩，用户无需购买和管理自己的实体服务器和其他数据中心基础结构，从而避免了相应的开支和复杂操作。</p><p>用户通过 IaaS 可以完成的典型事项包括：</p><ul><li>测试和开发。</li><li>网站托管。</li><li>存储、备份和恢复。</li><li>Web 应用。</li><li>高性能计算。</li><li>大数据分析。</li></ul><p>基本上所有的云服务商都提供了 IaaS 服务，国内最强大的云服务商当属阿里云。</p><p><strong>2）PaaS</strong></p><p>PaaS 的英文全称是 Platform as a Service，只需要提交代码到指定运行环境，代码打包、部署、IP 绑定都由平台完成。与 IaaS 相比，用户不需要管理与控制云端基础设施（包含网络、服务器、操作系统或存储），但需要控制上层的应用程序部署与应用托管的环境。</p><p><strong>3）SaaS</strong></p><p>SaaS 的英文全称是 Software as a Service，用户在这种模式下，不需要经过传统的安装步骤就可以通过网络使用软件。SaaS 最大的特色在于软件本身并没有被下载到用户的硬盘，而是存储在提供商的云端或者服务器。</p><p>怎么区分 IaaS、PaaS 和 SaaS 呢？来看下面这张图。</p><img src="image-20230628155501417.png" alt="image-20230628155501417" style="zoom:67%;"><p>如果我们开发了一个网站，按照传统的方式，我们需要买专业的服务器（连接网络），并在上面安装服务器软件，然后再把编写好的网站部署上去。</p><p>如果采用 IaaS 服务的话，就不需要自己购买服务器了，直接在租用的云服务器上安装服务器软件并且部署网站即可。</p><p>如果采用 PaaS 服务的话，不需要购买服务器，也不需要安装服务器软件，只需要部署网站即可。</p><p>如果采用 SaaS 服务的话，网站也不需要自己开发了，直接使用服务商开发好的网站，后期的升级、维护都交由服务商来负责。</p><p>阮一峰的网络日志上这样解释三者之间的关系。假如你想做披萨生意，有三种方案。</p><p>方案一，IaaS。</p><p>他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。</p><p>方案二，PaaS。</p><p>除了基础设施，他人还提供披萨饼皮。你只需要把自己的配料洒在饼皮上，至于是牛肉味的还是奥尔良鸡翅味的，你来决定。</p><p>方案三，SaaS。</p><p>他人直接做好了披萨，你拿到手就是一个成品。你要做的就是把披萨卖出去，最好印上自己的 Logo。</p><p><strong>4）域名</strong></p><p>有了可以提供服务的应用后，还需要一个能够让人记得住的域名，最好越简单越好。拿维基百科来说，wikipedia.org 是一个域名，和 IP 地址 208.80.152.2 相对应，用户可以直接访问 wikipedia.org 来代替 IP 地址，域名系统（DNS）会将域名转化成便于机器识别的 IP 地址。</p><p><strong>5）CDN</strong></p><p>CDN 的全称是 Content Delivery Network，即<strong>内容分发网络</strong>，一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。比较有名的 CDN 服务商有：</p><ul><li>Cloudflare，提供的免费版解决方案足以保护小网站免受 DDoS 之灾，也可以隐藏网站的真实 IP 地址。在海外有着极好的响应速度，国内好像不咋滴。</li><li>腾讯云，资源储备遍布全球 50+ 国家与地区，全网带宽 120Tbps+。国内 1100+ 加速节点，覆盖移动、联通、电信及十几家中小型运营商。</li><li>阿里云，全球 2800+ 节点，130T 带宽能力，六大洲覆盖，国内主流运营商支持。</li><li>七牛云，全球 2000 节点，20+ 运营商覆盖，访问提速 80%，应用场景包括音视频点播、大文件下载、Web 加速服务等。</li><li>又拍云，全球 1100+ 节点，10Tbps 带宽储备，国内主流运营商支持。</li></ul><p><strong>6）邮件发送</strong></p><p>基本上每个应用都离不开邮件发送，最常用的邮件服务器就是腾讯邮箱和网易邮箱。常用的电子邮件协议包括 SMTP、POP3 和 IMAP，不过，邮件的创建和发送只需要用到 SMTP 协议就可以了。</p><p>Java 官方提供了对电子邮件协议封装的 Java 类库，就是 JavaMail，但并没有包含在标准的 JDK 中，GitHub 地址如下：</p><p><a href="https://javaee.github.io/javamail/">https://javaee.github.io/javamail/</a></p><p>记得之前接到过这样一个需求，要求发送的邮件不能到垃圾邮箱里，还挺难做的。因为邮件服务器，比如说腾讯和网易，都做了邮件的过滤器，会识别一些邮件，自动放到垃圾邮箱里。</p><p><strong>7）短信发送</strong></p><p>使用短信发送验证码几乎是每个应用必不可少的一部分，仿佛手机号码就代表了一个人，所以丢手机是一件非常危险的事情——需要立即挂失。短信是需要运营商支持的，所以基本上都需要依赖第三方代理。市面上有很多短信网关代理，阿里云通信是比较常用的一个，以前叫阿里大于。</p><img src="image-20230628155554996.png" alt="image-20230628155554996" style="zoom:67%;"><p>阿里云通信的价格是每条短信 0.036 元，市面上还有一些其他的服务商，有些价格更低，但稳定性我个人没有测评过。我的技术交流群里就潜藏了不少做短信的商户人员。应用接入阿里云通信并不复杂，我之前在 CSDN 上分享过一个博客，很详细，图文并茂，还带源码实例，需要的小伙伴可以去围观下。</p><p><a href="https://qingmiaogu.blog.csdn.net/article/details/78751698">https://qingmiaogu.blog.csdn.net/article/details/78751698</a></p><p><strong>8）消息推送</strong></p><p>消息推送（Push）指运营人员通过自己的产品或第三方工具对用户移动设备进行的主动消息推送。用户可以在移动设备锁定屏幕和通知栏看到 push 消息通知，通知栏点击可唤起 APP 并去往相应页面。</p><p>移动应用上，推送已经成为一个标配功能。</p><p>iOS 在系统层面与苹果 APNs（Apple Push Notification service）服务器建立连接，应用通过观察者模式向 iOS 系统注册关注的消息，系统收到 APNs Server 消息后转发到相应的应用程序。</p><p>Android 的 C2DM（Android Cloud to Device Messaging）采取与 iOS 类似的机制，都是由系统层面来支持消息推送，但是由于 Google 的服务在国内不能稳定的访问，此方案对于国内用户来说基本是无法使用的。</p><p>鉴于 Android 平台 C2DM 推送的不可用性，国内涌现出大量的第三方推送服务提供商，目前应用最为广泛的第三方推送服务提供商包括个推、极光、友盟、小米、华为、BAT 等，我之前用个推做过一个小程序的推送 Demo，API 调用起来很简单，感觉还挺好用的。</p><p><strong>9）开放平台</strong></p><p>通过开放平台，可以使用 OAuth 等协议获取用户在第三方平台上的信息以实现第三方平台登录。比如用户想要登录 A 网站，A 网站让用户提供第三方网站的数据，证明自己的身份。获取第三方网站的身份数据，就需要 OAuth 授权。</p><p>国内的微博、微信、QQ 是最常见的第三方登录方式，阿里系的产品可以通过支付宝授权登录，还有一些网站绑定了 GitHub 登录。</p><p>阮一峰的网络日志上有一篇 GitHub OAuth 第三方登录示例教程：</p><p><a href="https://www.ruanyifeng.com/blog/2019/04/github-oauth.html">https://www.ruanyifeng.com/blog/2019/04/github-oauth.html</a></p><p><strong>10）支付接口</strong></p><p>目前，接入最多的支付接口就是支付宝和微信。</p><p>支付宝提供了当面付、APP 支付、手机网站支付、电脑网站支付等支付接口。</p><p>提供的文档很齐全，还有 Java、PHP、.NET 等版本的 Demo。</p><p><a href="https://opendocs.alipay.com/open/270">https://opendocs.alipay.com/open/270</a></p><p>微信支付的话，我推荐使用开源工具库 WxJava：</p><p><a href="https://github.com/Wechat-Group/WxJava">https://github.com/Wechat-Group/WxJava</a></p><p>我们公司的网站就用的这个，支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的后端开发，很齐全。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对接第三方API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2023/06/27/Threadlocal/"/>
      <url>/2023/06/27/Threadlocal/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钩子方法</title>
      <link href="/2023/06/27/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/"/>
      <url>/2023/06/27/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h1><blockquote><p>此处的钩子方法和Runtime类中的钩子线程是两种概念：Runtime.getRuntime( ).addShutdownHook( )</p><p>请参考：<a href="/maple/2023/05/09/Java%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/">JVM钩子</a></p></blockquote><p>钩子方法源于设计模式中<strong>模板方法（Template Method）模式</strong>，模板方法模式的概念为：<strong>在一个方法中定义一个算法骨架，而将一些具体步骤延迟到子类中实现。</strong></p><p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤实现。其方法主要分为两大类：模版方法 和 基本方法，而基本方法又分为：抽象方法（Abstract Method），具体方法（Concrete Method），钩子方法（Hook Method）。</p><p>模板方法模式中的四种方法基本定义（<strong>前提：在抽象类中定义</strong>）：</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>​        定义了一个方法，其中定义了整个逻辑的基本骨架。</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​    由抽象类声明，由具体子类实现，并以abstract关键字进行标识。</p><h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>​        由抽象类声明并且实现，子类并不做实现和覆盖操作。其实质就是普遍适用的方法，不需要子类来实现。</p><h3 id="钩子方法-1"><a href="#钩子方法-1" class="headerlink" title="钩子方法"></a>钩子方法</h3><p>​        由抽象类声明并且实现，子类也可以选择重写加以扩展。</p><p>通常抽象类会给出一个空实现的钩子方法，也就是没有实现内容的扩展。它和具体方法在代码层面上没有区别，不过是一种意识的区别；它和抽象方法在子类中都需要实现的层面上也没有区别，不同的是抽象方法必须由子类实现，而钩子方法在子类中可以不实现。也就是说钩子方法为开发者在实现某一个抽象类的时候提供了可选项，相当于预先提供了一个默认配置。提供了更大的灵活性，有些抽象类的子类有很多，如果将方法定义成抽象方法，所有的子类都必须要实现，但该方法又不是所有子类都有的行为，如果只在对应的子类中进行具体实现，其他子类进行空实现，这样是可以的，但是无谓的工作量太多。此时就可以考虑使用钩子方法，在需要的子类中进行实现，不需要实现的子类中直接忽略。</p><p>示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类，定义模板方法和基本方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体方法,声明并实现，继承此抽象类不需实现此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concreteMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;这是一个具体方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，abstract关键字标识，只声明，不实现，继承此抽象类的子类必须实现此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 钩子方法，声明并实现（空实现或者定义相关内容皆可），继承此抽象类的子类可扩展实现或者不实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法，整个算法的骨架|场景:如解析所有的配置项,不同类型的配置项的解析方法不同,但是解析的流程是相同的,此时就可以将解析配置</span></span><br><span class="line"><span class="comment">     * 抽象成一个类,将解析流程定义成一个模板方法,其中具体的解析方法由各个子类实现.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        abstractMethod();</span><br><span class="line">        concreteMethod();</span><br><span class="line">        hookMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bond</span><span class="params">(AbstractClass abstractClass)</span> &#123;</span><br><span class="line">        abstractClass.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ChildClass</span> <span class="variable">childClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">        childClass.bond(<span class="keyword">new</span> <span class="title class_">AbstractClass</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子类实现父类抽象类中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接口中的default方法，也是一种钩子方法的思想。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钩子方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok</title>
      <link href="/2023/06/26/Lombok/"/>
      <url>/2023/06/26/Lombok/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lombok简介"><a href="#1-Lombok简介" class="headerlink" title="1. Lombok简介"></a>1. Lombok简介</h2><blockquote><p>官方介绍： Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><p>官网地址：<a href="https://projectlombok.org/">Project Lombok</a></p></blockquote><p>意思：Lombok是一个java库，它可以自动插入编辑器和构建工具中，以提升java性能。不需要另外编写getter或equals方法，使用一个注解，你的类就有一个功能齐全的生成器，自动记录变量，等等。</p><p>简而言之：<strong>Lombok能以简单的注解形式来简化java代码，提高开发人员的效率。</strong></p><h2 id="2-Lombok使用"><a href="#2-Lombok使用" class="headerlink" title="2. Lombok使用"></a>2. Lombok使用</h2><p>使用Lombok需要的开发环境为：<code>Java + Maven + IntelliJ IDEA 或 Eclipse(安装Lombok Plugin)</code></p><h3 id="2-1-添加maven依赖"><a href="#2-1-添加maven依赖" class="headerlink" title="2.1 添加maven依赖"></a>2.1 添加maven依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.4&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-安装插件"><a href="#2-2-安装插件" class="headerlink" title="2.2 安装插件"></a>2.2 安装插件</h3><p>使用Lombok需要插件的配合，使用开发工具为IDEA。打开IDEA的设置，点击<code>Plugins</code>，点击<code>Browse repositories</code>，在弹出的窗口中搜索<code>lombok</code>，然后安装即可。如图：</p><p><img src="r&ynotemdtimestamp=1687769940680-20230626171037196.png" alt="lombok1"></p><h3 id="2-3-解决编译时出错问题"><a href="#2-3-解决编译时出错问题" class="headerlink" title="2.3 解决编译时出错问题"></a>2.3 解决编译时出错问题</h3><p>编译时出错，可能是没有<code>enable</code>注解处理器。<code>Annotation Processors</code>-&gt;<code>Enable annotation processing</code>。设置完成之后程序可正常运行。如图：</p><p><img src="r&ynotemdtimestamp=1687769940680-20230626171037110.png" alt="lombok2"></p><h3 id="2-4-代码示例"><a href="#2-4-代码示例" class="headerlink" title="2.4 代码示例"></a>2.4 代码示例</h3><p>下面举两个栗子，看看使用lombok和不使用的区别。</p><h4 id="2-4-1-创建一个用户类"><a href="#2-4-1-创建一个用户类" class="headerlink" title="2.4.1 创建一个用户类"></a>2.4.1 创建一个用户类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">            <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(id, user.id) &amp;&amp;</span><br><span class="line">            Objects.equals(username, user.username) &amp;&amp;</span><br><span class="line">            Objects.equals(age, user.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, username, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-使用Lombok"><a href="#2-4-2-使用Lombok" class="headerlink" title="2.4.2 使用Lombok"></a>2.4.2 使用Lombok</h4><ul><li>@Data注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译得到<code>.class</code>文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="built_in">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                label47: &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">this$id</span> <span class="operator">=</span> <span class="built_in">this</span>.getId();</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">other$id</span> <span class="operator">=</span> other.getId();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>$id == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (other$id == <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span> label47;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>$id.equals(other$id)) &#123;</span><br><span class="line">                        <span class="keyword">break</span> label47;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">this$username</span> <span class="operator">=</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">other$username</span> <span class="operator">=</span> other.getUsername();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>$username == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$username != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>$username.equals(other$username)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">Object</span> <span class="variable">this$age</span> <span class="operator">=</span> <span class="built_in">this</span>.getAge();</span><br><span class="line">                <span class="type">Object</span> <span class="variable">other$age</span> <span class="operator">=</span> other.getAge();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>$age == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$age != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>$age.equals(other$age)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">canEqual</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> User;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">PRIME</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">$id</span> <span class="operator">=</span> <span class="built_in">this</span>.getId();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> result * <span class="number">59</span> + ($id == <span class="literal">null</span> ? <span class="number">43</span> : $id.hashCode());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">$username</span> <span class="operator">=</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">        result = result * <span class="number">59</span> + ($username == <span class="literal">null</span> ? <span class="number">43</span> : $username.hashCode());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">$age</span> <span class="operator">=</span> <span class="built_in">this</span>.getAge();</span><br><span class="line">        result = result * <span class="number">59</span> + ($age == <span class="literal">null</span> ? <span class="number">43</span> : $age.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User(id=&quot;</span> + <span class="built_in">this</span>.getId() + <span class="string">&quot;, username=&quot;</span> + <span class="built_in">this</span>.getUsername() + <span class="string">&quot;, age=&quot;</span> + <span class="built_in">this</span>.getAge() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明<code>@Data</code>注解在类上，会为类的所有属性自动生成<code>无参构造器</code>、<code>setter/getter</code> 、<code>equals</code> 、<code>canEqual</code> 、<code>hashCode</code> 、<code>toString</code> 方法。</p><blockquote><p><strong>注意</strong>：如果类中有<code>final</code>修饰的属性，则不会为该属性生成<code>setter</code>方法，其他的方法都会有。因为使用<code>final</code>修饰的属性就是一个不可变属性，所以没有<code>setter</code>方法也是很合理的。</p></blockquote><h4 id="2-4-3-自动生成日志变量"><a href="#2-4-3-自动生成日志变量" class="headerlink" title="2.4.3 自动生成日志变量"></a>2.4.3 自动生成日志变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Maple!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后的<code>.class</code> 文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line">    <span class="comment">// @Slf4j注解生成的Logger日志对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(DemoController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo1_Controller</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/test&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Maple!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编译可以看到<code>@Slf4j</code>注解生成了log日志变量（严格意义来说是常量），无需去声明一个log就可以在类中使用log记录日志。</p><h4 id="2-5-常用注解"><a href="#2-5-常用注解" class="headerlink" title="2.5 常用注解"></a>2.5 常用注解</h4><p>常用的几个注解：</p><ul><li><p><strong>@Setter</strong>注解：在类或属性上，注解在类上时表示为所有属性生成setter方法，注解在属性上时只为该属性生成setter方法；</p></li><li><p><strong>@Getter</strong> 注解： 同上，区别在于生成的是getter方法；</p></li><li><p><strong>@ToString</strong> 注解：在类上，添加toString()方法；</p></li><li><p><strong>@EqualsAndHashCode</strong>注解：在类上，生成hashCode()、canEqual()方法和equals()方法；</p></li><li><p><strong>@NoArgsConstructor</strong> 注解：在类上，生成无参的构造方法|无参构造器是默认生成的,即使没有添加任何注解；</p></li><li><p><strong>@RequiredArgsConstructor</strong> 注解：在类上，为类中需要特殊处理的属性生成构造方法，只包含这些属性的专属构造器。比如<code>final</code>和被<code>@NonNull</code>注解的属性；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后的结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8054600833969507380L</span>;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="meta">@NonNull</span></span><br><span class="line">      <span class="keyword">private</span> String username;</span><br><span class="line">      <span class="keyword">private</span> Integer age;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="meta">@NonNull</span> String username)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;username is marked non-null but is null&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.username = username;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，@RequiredArgsConstructor注解并没有为final修饰的属性创建一个专属的构造器，但是为@nonNull注解修饰的属性创建了专属的构造器。</p></li></ul><blockquote><p>可能是由于lombok的版本更新，去除了为final修饰的属性创建专属构造器的功能。</p></blockquote><ul><li><p><strong>@AllArgsConstructor</strong> 注解：在类上，生成包含类中所有属性的有参构造方法，同时会覆盖默认的空参构造器；</p><p>在基类上使用时没有问题，但是在继承了父类属性的子类上使用时就要注意此时的全参构造仅包含子类中的所有参数，而不包含从父类中继承的属性。</p><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleUser</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleUser</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleUser</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只包含特定属性的构造器</span></span><br><span class="line">    <span class="meta">@ConstructorProperties(&#123;&quot;roleName&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleUser</span><span class="params">(String roleName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roleName = roleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Data</strong> 注解：在类上，生成无参构造器、setter( )/getter( )、equals( )、canEqual( )、hashCode( )、toString( )方法，如为final属性，则不会为该属性生成setter方法；</p></li><li><p><strong>@Slf4j</strong> 注解：在类上，自动生成log变量，严格意义来说是常量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UserController.class);</span><br></pre></td></tr></table></figure><p>springboot-1.5.10.Release版本的lombok下使用@Slf4j在编译之后生成的<code>.class</code>文件中生成的日志对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Accessors(chain = true)</strong> 使用链式设置属性，set方法返回的是this对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//使用@Accessors(chain = true)</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">userChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    userChain.setId(<span class="string">&quot;1&quot;</span>).setName(<span class="string">&quot;chain&quot;</span>).setAge(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@UtilityClass:工具类</strong>：使用该注解的类表明是一个工具类，会为类生成私有构造，并将所有的方法都设置为static.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocalCache = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化线程本地缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        threadLocalCache.set(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(arg)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; stringObjectMap = threadLocalCache.get();</span><br><span class="line">        <span class="keyword">if</span> (stringObjectMap.containsKey(arg)) &#123;</span><br><span class="line">            <span class="keyword">return</span> stringObjectMap.get(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocalCache.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TestTool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocalCache = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        threadLocalCache.set(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">get</span><span class="params">(String arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(arg)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;String, Object&gt; stringObjectMap = (Map)threadLocalCache.get();</span><br><span class="line">            <span class="keyword">return</span> stringObjectMap.containsKey(arg) ? stringObjectMap.get(arg) : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocalCache.remove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TestTool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;This is a utility class and cannot be instantiated&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Lombok工作原理"><a href="#3-Lombok工作原理" class="headerlink" title="3. Lombok工作原理"></a>3. Lombok工作原理</h2><p>在Lombok使用的过程中，只需要添加相应的注解，无需再为此写任何代码。自动生成的代码到底是如何产生的呢？</p><p>核心之处就是对于注解的解析上。JDK5引入了注解的同时，也提供了两种解析方式。</p><ol><li><p>运行时解析 运行时能够解析的注解，必须将<code>@Retention</code>设置为<code>RUNTIME</code>，这样就可以通过反射拿到该注解。<code>java.lang.reflect</code>反射包中提供了一个接口AnnotatedElement，该接口定义了获取注解信息的几个方法，Class、Constructor、Field、Method、Package等都实现了该接口，对反射熟悉的朋友应该都会很熟悉这种解析方式。</p></li><li><p>编译时解析 编译时解析有两种机制，分别简单描述下：</p><ol><li><p>Annotation Processing Tool</p><p>apt自JDK5产生，JDK7已标记为过期，不推荐使用，JDK8中已彻底删除，自JDK6开始，可以使用Pluggable Annotation Processing API来替换它，apt被替换主要有2点原因：</p><ul><li>api都在com.sun.mirror非标准包下；</li><li>没有集成到javac中，需要额外运行；</li></ul></li><li><p>Pluggable Annotation Processing API</p><p>JSR 269自JDK6加入，作为apt的替代方案，它解决了apt的两个问题，javac在执行的时候会调用实现了该API的程序，这样我们就可以对编译器做一些增强，javac执行的过程如下：</p><p><img src="r&ynotemdtimestamp=1687769940680.png" alt="lombok4"></p></li></ol></li></ol><p>Lombok本质上就是一个实现了“JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p><ol><li>javac对源代码进行分析，生成了一棵抽象语法树（AST）；</li><li>运行过程中调用实现了“JSR 269 API”的Lombok程序；</li><li>此时Lombok就对第一步骤得到的AST进行处理，找到<code>@Data</code>注解所在类对应的语法树（AST），然后修改该语法树（AST），增加getter()和setter()方法定义的相应树节点；</li><li>javac使用修改后的抽象语法树（AST）生成字节码文件，即给class增加新的节点（代码块）；</li></ol><p>通过读Lombok源码，发现对应注解的实现都在<code>HandleXXX</code>中，如<code>@Getter</code>注解的实现在<code>HandleGetter.handle()</code>。还有一些其它类库使用这种方式实现，比如Google Auto、Dagger等等。</p><h2 id="4-Lombok的优缺点"><a href="#4-Lombok的优缺点" class="headerlink" title="4. Lombok的优缺点"></a>4. Lombok的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提升了一定的开发效率；</li><li>让代码变得简洁，不用过多的去关注方法实现；</li><li>属性修改时，也简化了维护这些属性所生成的getter/setter方法等；</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>不支持多种参数构造器的重载，即不能灵活地创建只包含部分属性的构造器；</li><li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度；</li></ol><hr><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/ThinkWon/article/details/101392808">Lombok简介、使用、工作原理、优缺点</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分销业务场景</title>
      <link href="/2023/06/22/%E5%88%86%E9%94%80/"/>
      <url>/2023/06/22/%E5%88%86%E9%94%80/</url>
      
        <content type="html"><![CDATA[<h1 id="分销"><a href="#分销" class="headerlink" title="分销"></a>分销</h1><h2 id="一、什么是分销"><a href="#一、什么是分销" class="headerlink" title="一、什么是分销"></a>一、什么是分销</h2><p>在西方经济学中，分销的含义是建立销售渠道的意思。分销渠道又叫营销渠道，是指某种商品或服务从生产者向消费者转移的过程中，获取这种商品或服务的所有权，帮助所有权转移的所有企业和个人。</p><p>分销，简单的说，就是让更多的人帮助企业卖货，企业通过<strong>裂变</strong>分销，实现分销渠道裂变从而达到销售商品的目的。企业为了销售商品，主要的任务是把自己的商品销售出去来获取更多的利润。</p><p><img src="T45POTbFsftANN.png" alt="分销系统分解与产品设计"></p><p>传统的销售渠道就是公司招聘销售员，由销售员进行推销产品，另外也会通过互联网进行一些宣传，总而言之一切都是为了把货卖出去。而分销模式是通过分销员向自己身边的朋友以及家人宣传和推广商品并且成交订单，分销员就可以获得一定比例的返佣。</p><img src="T45POU8HUa2wdE.png" alt="分销系统分解与产品设计" style="zoom:70%;"><p>分销的三级代理模式：</p><img src="T45POV3960RFUY.png" alt="分销系统分解与产品设计" style="zoom:70%;"><h2 id="二、分销模式的应用"><a href="#二、分销模式的应用" class="headerlink" title="二、分销模式的应用"></a>二、分销模式的应用</h2><p>分销模式主要是商家在销售商品或服务时，通过其用户的粉丝效应或者朋友交际圈来扩大销售覆盖人群最终实现商品的销售，在电商、保险、信用卡、社区团购较为常见。我们平常在进行商品下单的时候，常需要我们填些推荐码时，或者通过专属的分享链接进行下单，例如我们常见的有淘宝联盟、直播电商平台中主播挂的购物链接等等，这都是属于分销模式。</p><p>分销模式最主要的特点为：<strong>下级的收益按一定比例作为上级的收入，通过该种形式而成为分销体系中的一员，其对于平台的粘性以及积极主动性会更高一些，通过良好的机制能让整个销售团队实现内循环、内增长。</strong></p><h2 id="三、分销模式优点"><a href="#三、分销模式优点" class="headerlink" title="三、分销模式优点"></a>三、分销模式优点</h2><p>分销模式在各行各业都能广泛应用且该模式经久不衰，其主要原因是对于分销模式中各方（品牌方、分销者、终端用户）都有益处。</p><p><strong>1）品牌方</strong></p><p>对于品牌方来说，分销模式在降低成本的同时还能提高营收。随着近年来互联网红利逐渐消退，获客成本逐年升高，在某些行业比如教育或者金融行业的CPS获客成本高达上百甚至上千元。</p><p>而分销模式可利用分销员社交平台的熟人关系链，使得每一个用户都有可能成为品牌方的分销员，在社交关系网的帮助下不断的触达更多的用户，使得用非常低的成本即可完成获客及完单转化。</p><p><strong>2）分销员</strong></p><p>分销员利用自身的社交链通过促成产品的交易实现收入，在其影响力达到一定程度后，可以实现所谓的“躺赚”。也是正因此，分销模式也成为更多人的副业或者家庭主妇的职业选择方向。</p><p><strong>3）终端用户</strong></p><p>当前市场上的商品或服务繁多，用户要想选择一个适合自己的产品，需要花费大量的时间去了解相关的信息，若直接从相熟的人那去购买相关产品，则可以大大减少这其中的决策成本和时间成本，当前带货主播能如此热门也正是因为这个原因。</p><h2 id="四、分销系统的设计"><a href="#四、分销系统的设计" class="headerlink" title="四、分销系统的设计"></a>四、分销系统的设计</h2><p>确定实体及对应的属性：</p><img src="image-20230622120040069.png" alt="image-20230622120040069" style="zoom:67%;"><p>分销模式中有几个重要的产品特点，需要在产品设计中充分考虑：</p><h3 id="1-分销门槛"><a href="#1-分销门槛" class="headerlink" title="1. 分销门槛"></a>1. 分销门槛</h3><p>分销的门槛主要有两种，一种是无条件申请，另一种是需要达到申请条件才能成为分销员。</p><p>对于无条件申请来说，所有人都可以成为分销员，这种方式的优点是：在初期可以快速发展分销员，提高分销裂变的速度；缺点是分销用户筛选不够精准，动力不强。</p><p>对于需要达到一定条件才能申请的模式，类似于需要付费加入或者完成某些特定任务之后才能申请成为分销商。这种方式的优点是：因为用户前期付出了支付成本，会让新用户有动力将付出的钱赚回来，所以一定程度上销售动力会特别强；当然这种方式的缺点是分销员的增长速度相对较慢。</p><h3 id="2-分销关系链"><a href="#2-分销关系链" class="headerlink" title="2. 分销关系链"></a>2. 分销关系链</h3><p>分销关系链主要有两种情况：</p><ul><li>无固定关系：这种方式其实可以理解为一级分销，如下图所示的第一种情况。每个分销员都是独立的，没有上下级关系，彼此之间也没有任何的绑定关系。</li><li>固定关系：类似于下图二级分销和三级分销的情况，分销员之间建立固定的捆绑关系，下一级分销员产生的订单，上级都可以获得一定比例的奖励。</li></ul><img src="T45PP8B94ZXA0R.png" alt="分销系统分解与产品设计" style="zoom:67%;"><h3 id="3-佣金标准"><a href="#3-佣金标准" class="headerlink" title="3. 佣金标准"></a>3. 佣金标准</h3><p>分销模式的佣金标准一般有两个特点，一个是<strong>分段提成</strong>，一个是<strong>跨级提成</strong>。</p><p><strong>1）分段提成</strong></p><p><strong>分销员的成长体系</strong>，当分销员成长为更高等级时，其个人所获得的包括其上级所得到的佣金比例也随之升高。分段提成不仅可以促使分销员自身更有动力成长为高级别的分销员，还能促使其培养更高级别的成员。</p><img src="T45PPjSB0PRHjM.png" alt="分销系统分解与产品设计" style="zoom:67%;"><p><strong>2）跨级提成</strong></p><p>分销员通过直接分享商品获得订单的销售佣金，或者下级成交订单后获得的间接销售佣金，随着其分销员的级别变化而变化。跨级提成一方面可以刺激分销员进行商品销售，激发其销售动力，另一个方面可有利于团队管理者对于团队成员的配置，实现该模式的正向发展。</p><p>这里的跨级指的是分销级数：一级、二级、三级。</p><p>有成交客户之后，平台会按照一级佣金给分销员结算；当存在二级分销时，二级分销员会得到成交客户的一级佣金，而一级分销员会得到成交客户的二级佣金；三级分销也是类似的逻辑。</p><p>通常来说，末尾三级分佣，一级分销商获得佣金最多，因为能直接为商家带来订单，发展一级分销商的二级、三级分销商会获得较低的二级、三级佣金。</p><img src="T45PPkFGHm3Nyf.png" alt="分销系统分解与产品设计" style="zoom:67%;"><p><strong>3）等级权益</strong></p><p>分销员等级以及权益：分销体系的核心诉求是让分销渠道源源不断地产生动力，所以好的分销等级及对应权益的设计可以持续激励分销员，不断提升分销员的积极性，从而不断地为平台拉新或者提升销售额。</p><p>通常的晋升规则是按订单量或成交金额来进行等级划分，对应的等级权益常见的有：分销佣金的奖励比例、额外的返现、特殊商品的分销资格等等。</p><p>高等级的高分销佣金比例，可以不断提升分销员热情和活跃度，让分销员拥有更高的内驱力进行分销。</p><p>同时也可以设计分销员降级规则，在规定的时间内没有完成指定任务则进行相应的惩罚措施，例如降级等，降级规则要谨慎使用，若使用不好有可能降低分销员的积极主动性，具体要看业务在实际过程当中的应用及需要。</p><h2 id="五、分销产品设计"><a href="#五、分销产品设计" class="headerlink" title="五、分销产品设计"></a>五、分销产品设计</h2><p>我们简单列举一下在进行分销产品设计时所涉及到的前端信息架构及后台支撑系统，具体内容就不在此展开了。</p><p>前端应用的使用方主要是分销员，在进行产品设计时我们需要注意做为分销员最的核心模块是什么，一般分销产品的功能模块及信息架构如下：</p><img src="T45PPl666hrVV0.png" alt="分销系统分解与产品设计" style="zoom:67%;"><p>对应的APP架构设计如下：</p><img src="T45PPlZ7NeP6ue.png" alt="分销系统分解与产品设计" style="zoom:90%;"><p>分销后台则支撑着整个分销业务的发展，因此在进行分销建设时需要充分考虑应用场景、便捷性以及高度可拓展性。以下列举了分销系统中的核心模块，具体的模块功能需要根据业务的实际需求来进行产品设计。</p><img src="T45PPmG7E9AE82.png" alt="分销系统分解与产品设计" style="zoom:75%;"><ol><li>分销系统的基本要求易用性：分销系统无论是to B还是to C，面对的都有可能是庞大的客户群，需要在没有任何培训的情况下进行使用,各功能模块区域都要简单易用，清晰明确，使得用户在最短的路径内完成其特定需求。安全性：分销系统的每笔交易、每笔佣金都跟商家、客户的钱是息息相关的，在计算上面不能出错，否则这将给市场及售后带来很大的麻烦。稳定性：由于分销模式伴随着交易的产生，故对业务的稳定性要求较大，且需要考虑多并非对于系统的影响。</li><li>常见的分销系统，如赤焰社群直播分销系统。这是一款基于公众号平台搭建的二级和三级分销商城，通过系统可以设置一级、二级分销模式，设置分销佣金规则，网友注册账号即可成为分销商，拥有自己的分销二维码，通过推广和分享自己的分销二维码来为商城带来订单，从而获得推广佣金。</li></ol><hr><p><strong>参考：</strong></p><ul><li><a href="https://article.autotimes.com.cn/article/124668.html">分销是什么意思 分销模式是什么意思</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分销 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 7」-- 规则配置持久化</title>
      <link href="/2023/06/08/Sentinel7-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/06/08/Sentinel7-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="规则配置持久化"><a href="#规则配置持久化" class="headerlink" title="规则配置持久化"></a>规则配置持久化</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功后可以动态增加各种流控降级规则。Sentinel 提供两种方式修改规则：</p><ul><li>通过 API 直接修改 (<code>loadRules</code>)</li><li>通过 <code>DataSource</code> 适配不同数据源修改</li></ul><p>通过 API 修改比较直观，可以通过以下几个 API 修改不同的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FlowRuleManager.loadRules(List&lt;FlowRule&gt; rules); <span class="comment">// 修改流控规则</span></span><br><span class="line">DegradeRuleManager.loadRules(List&lt;DegradeRule&gt; rules); <span class="comment">// 修改降级规则</span></span><br></pre></td></tr></table></figure><p>手动修改规则（硬编码方式）一般仅用于测试和演示，生产上一般通过动态规则源的方式来动态管理规则。</p><h2 id="规则管理模式"><a href="#规则管理模式" class="headerlink" title="规则管理模式"></a>规则管理模式</h2><p>Sentinel的控制台规则管理有三种模式：Sentinel的规则默认是保存在内存中，Sentinel重启之后规则就会丢失</p><table><thead><tr><th><strong>推送模式</strong></th><th><strong>说明</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">原始模式</a></td><td>API 将规则推送至客户端并直接更新到内存中，扩展写数据源（<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">WritableDataSource</a>），默认就是这种</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境</td></tr><tr><td>[Pull <a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">模式</a></td><td>扩展写数据源（<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">WritableDataSource</a>），  客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件 等</td><td>简单，无任何依赖；规则持久化</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。</td></tr><tr><td><strong><a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">Push</a></strong><a href="https://github.com/alibaba/Sentinel/wiki/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Sentinel">模式</a></td><td>扩展读数据源（<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">ReadableDataSource</a>），规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用  Nacos、Zookeeper  等配置中心。这种方式有更好的实时性和一致性保证。<strong>生产环境下一般采用</strong>  <strong>push</strong>  <strong>模式的数据源。</strong></td><td>规则持久化；一致性；</td><td>引入第三方依赖</td></tr></tbody></table><h3 id="原始模式"><a href="#原始模式" class="headerlink" title="原始模式"></a>原始模式</h3><p>控制台配置的规则直接推送到Sentinel客户端，也就是我们的应用。然后保存在内存中，服务重启则丢失。</p><img src="image-20230609154151569.png" alt="image-20230609154151569" style="zoom: 50%;"><h3 id="Pull模式"><a href="#Pull模式" class="headerlink" title="Pull模式"></a>Pull模式</h3><p>实现拉模式的数据源最简单的方式是继承 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AutoRefreshDataSource.java"><code>AutoRefreshDataSource</code></a> 抽象类，然后实现 <code>readSource()</code> 方法，在该方法里从指定数据源读取字符串格式的配置数据。比如 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-dynamic-file-rule/src/main/java/com/alibaba/csp/sentinel/demo/file/rule/FileDataSourceDemo.java">基于文件的数据源</a>。</p><p>控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p><img src="image-20230609154244371.png" alt="image-20230609154244371" style="zoom:50%;"><h3 id="Push模式"><a href="#Push模式" class="headerlink" title="Push模式"></a>Push模式</h3><p>实现推模式的数据源最简单的方式是继承 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AbstractDataSource.java"><code>AbstractDataSource</code></a> 抽象类，在其构造方法中添加监听器，并实现 <code>readSource()</code> 从指定数据源读取字符串格式的配置数据。比如 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-nacos-datasource/src/main/java/com/alibaba/csp/sentinel/demo/datasource/nacos/NacosDataSourceDemo.java">基于 Nacos 的数据源</a>。</p><p>控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。</p><p>常见的有两种玩法：</p><ul><li><strong>sentinel-core + sentinel-datasource-nacos（规则配置中心）</strong><ul><li>直接在Nacos界面配置Sentinel规则配置文件，在使用Sentinel的应用中自定义Nacos监听器对Nacos配置文件变更进行监听并进行解析和loadRule进行限流降级，实现Sentinel的规则持久化操作。</li></ul></li><li><strong>sentinel-dashboard（控制台） + sentinel-datasource-nacos（规则配置中心）</strong><ul><li>结合sentinel-dashboard可视化UI，在sentinel-dashboard中配置的规则直接push到Nacos中，然后使用Sentinel的应用中监听Nacos的配置文件的变更，并进行loadRule操作实现限流降级。</li><li>需要对Sentinel-Dashboard的源码进行二次开发。</li></ul></li></ul><p>我们推荐<strong>通过控制台设置规则后将规则推送到统一的规则中心，客户端实现</strong> <code>ReadableDataSource</code> <strong>接口端监听规则中心实时获取变更</strong>，流程如下：</p><img src="45406233-645e8380-b698-11e8-8199-0c917403238f.png" alt="push-rules-from-dashboard-to-config-center" style="zoom: 50%;"><blockquote><p>Sentinel 目前支持以下数据源扩展：</p><ul><li>Pull-based: 动态文件数据源、<a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-consul">Consul</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-eureka">Eureka</a></li><li>Push-based: <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-zookeeper">ZooKeeper</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-redis">Redis</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-nacos">Nacos</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-apollo">Apollo</a>, <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-datasource-etcd">etcd</a></li></ul></blockquote><h3 id="注册数据源"><a href="#注册数据源" class="headerlink" title="注册数据源"></a>注册数据源</h3><p>通常需要调用以下方法将数据源注册至指定的规则管理器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="keyword">new</span> <span class="title class_">NacosDataSource</span>&lt;&gt;(remoteAddress, groupId, dataId, parser);</span><br><span class="line">FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br></pre></td></tr></table></figure><p>若不希望手动注册数据源，可以借助 Sentinel 的 <code>InitFunc</code> SPI 扩展接口。只需要实现自己的 <code>InitFunc</code> 接口，在 <code>init</code> 方法中编写注册数据源的逻辑。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.init;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceInitFunc</span> <span class="keyword">implements</span> <span class="title class_">InitFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">remoteAddress</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">groupId</span> <span class="operator">=</span> <span class="string">&quot;Sentinel:Demo&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;com.alibaba.csp.sentinel.demo.flow.rule&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="keyword">new</span> <span class="title class_">NacosDataSource</span>&lt;&gt;(remoteAddress, groupId, dataId,</span><br><span class="line">            source -&gt; JSON.parseObject(source, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;() &#123;&#125;));</span><br><span class="line">        FlowRuleManager.register2Property(flowRuleDataSource.getProperty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着将对应的类名添加到位于资源目录（通常是 <code>resource</code> 目录）下的 <code>META-INF/services</code> 目录下的 <code>com.alibaba.csp.sentinel.init.InitFunc</code> 文件中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.test.init.DataSourceInitFunc</span><br></pre></td></tr></table></figure><p>这样，当初次访问任意资源的时候，Sentinel 就可以自动去注册对应的数据源了。</p><h3 id="sentinel-core-sentinel-datasource-nacos（规则配置中心）"><a href="#sentinel-core-sentinel-datasource-nacos（规则配置中心）" class="headerlink" title="sentinel-core + sentinel-datasource-nacos（规则配置中心）"></a>sentinel-core + sentinel-datasource-nacos（规则配置中心）</h3><p>示例：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/tree/master/sentinel-demo/sentinel-demo-nacos-datasource">sentinel-demo-nacos-datasource</a></p><h3 id="sentinel-dashboard（控制台）-sentinel-datasource-nacos（规则配置中心）"><a href="#sentinel-dashboard（控制台）-sentinel-datasource-nacos（规则配置中心）" class="headerlink" title="sentinel-dashboard（控制台） + sentinel-datasource-nacos（规则配置中心）"></a>sentinel-dashboard（控制台） + sentinel-datasource-nacos（规则配置中心）</h3><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/dynamic-rule-configuration.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 6」-- 系统自适应保护 &amp; 来源控制</title>
      <link href="/2023/06/07/Sentinel6-%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%9D%E6%8A%A4/"/>
      <url>/2023/06/07/Sentinel6-%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="系统自适应保护"><a href="#系统自适应保护" class="headerlink" title="系统自适应保护"></a>系统自适应保护</h1><p>Sentinel 系统自适应保护从整体维度对应用入口流量进行控制，结合应用的 Load、总体平均 RT、入口 QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开始之前，先回顾一下 Sentinel 做系统自适应保护的目的：</p><ul><li>保证系统不被拖垮</li><li>在系统稳定的前提下，保持系统的吞吐量</li></ul><p>长期以来，系统自适应保护的思路是根据硬指标，即系统的负载 (load1) 来做系统过载保护。当系统负载高于某个阈值，就禁止或者减少流量的进入；当 load 开始好转，则恢复流量的进入。这个思路给我们带来了不可避免的两个问题：</p><ul><li>load 是一个“果”，如果根据 load 的情况来调节流量的通过率，那么就始终有延迟性。也就意味着通过率的任何调整，都会过一段时间才能看到效果。当前通过率是使 load 恶化的一个动作，那么也至少要过 1 秒之后才能观测到；同理，如果当前通过率调整是让 load 好转的一个动作，也需要 1 秒之后才能继续调整，这样就浪费了系统的处理能力。所以我们看到的曲线，总是会有抖动。</li><li>恢复慢。想象一下这样的一个场景（真实），出现了这样一个问题，下游应用不可靠，导致应用 RT 很高，从而 load 到了一个很高的点。过了一段时间之后下游应用恢复了，应用 RT 也相应减少。这个时候，其实应该大幅度增大流量的通过率；但是由于这个时候 load 仍然很高，通过率的恢复仍然不高。</li></ul><p><a href="https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_BBR">TCP BBR</a> 的思想给了我们一个很大的启发。我们应该根据系统能够处理的请求，和允许进来的请求，来做平衡，而不是根据一个间接的指标（系统 load）来做限流。最终我们追求的目标是 <strong>在系统不被拖垮的情况下，提高系统的吞吐率，而不是 load 一定要到低于某个阈值</strong>。如果我们还是按照固有的思维，超过特定的 load 就禁止流量进入，系统 load 恢复就放开流量，这样做的结果是无论我们怎么调参数，调比例，都是按照果来调节因，都无法取得良好的效果。</p><p>Sentinel 在系统自适应保护的做法是，用 load1 作为启动控制流量的值，而允许通过的流量由处理请求的能力，即请求的响应时间以及当前系统正在处理的请求速率来决定。</p><h2 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h2><p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的总体 Load、RT、入口 QPS 和线程数四个维度监控应用数据，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p>系统保护规则是应用整体维度的，而不是资源维度的，并且<strong>仅对入口流量生效</strong>。入口流量指的是进入应用的流量（<code>EntryType.IN</code>），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。</p><p>系统规则支持以下的阈值类型：</p><ul><li><strong>Load</strong>（仅对 Linux/Unix-like 机器生效）：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 <code>maxQps * minRt</code> 计算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0）。</li><li><strong>RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先用经典图来镇楼:</p><p><img src="50813887-bff10300-1352-11e9-9201-437afea60a5a.png" alt="TCP-BBR-pipe"></p><p>我们把系统处理请求的过程想象为一个水管，到来的请求是往这个水管灌水，当系统处理顺畅的时候，请求不需要排队，直接从水管中穿过，这个请求的RT是最短的；反之，当请求堆积的时候，那么处理请求的时间则会变为：排队时间 + 最短处理时间。</p><ul><li>推论一: 如果我们能够保证水管里的水量，能够让水顺畅的流动，则不会增加排队的请求；也就是说，这个时候的系统负载不会进一步恶化。</li></ul><p>我们用 T 来表示(水管内部的水量)，用RT来表示请求的处理时间，用P来表示进来的请求数，那么一个请求从进入水管道到从水管出来，这个水管会存在 <code>P * RT</code>　个请求。换一句话来说，当 <code>T ≈ QPS * Avg(RT)</code> 的时候，我们可以认为系统的处理能力和允许进入的请求个数达到了平衡，系统的负载不会进一步恶化。</p><p>接下来的问题是，水管的水位是可以达到了一个平衡点，但是这个平衡点只能保证水管的水位不再继续增高，但是还面临一个问题，就是在达到平衡点之前，这个水管里已经堆积了多少水。如果之前水管的水已经在一个量级了，那么这个时候系统允许通过的水量可能只能缓慢通过，RT会大，之前堆积在水管里的水会滞留；反之，如果之前的水管水位偏低，那么又会浪费了系统的处理能力。</p><ul><li>推论二:　当保持入口的流量使水管出来的流量达到最大值的时候，可以最大利用水管的处理能力。</li></ul><p>然而，和 TCP BBR 的不一样的地方在于，还需要用一个系统负载的值（load1）来激发这套机制启动。</p><blockquote><p>注：这种系统自适应算法对于低 load 的请求，它的效果是一个“兜底”的角色。<strong>对于不是应用本身造成的 load 高的情况（如其它进程导致的不稳定的情况），效果不明显。</strong></p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们提供了系统自适应限流的示例：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/system/SystemGuardDemo.java">SystemGuardDemo</a>。</p><h1 id="来源访问控制（黑白名单）"><a href="#来源访问控制（黑白名单）" class="headerlink" title="来源访问控制（黑白名单）"></a>来源访问控制（黑白名单）</h1><p>很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的黑白名单控制的功能。黑白名单根据资源的请求来源（<code>origin</code>）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p><blockquote><p>调用方信息通过 <code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数传入。</p></blockquote><h2 id="规则配置"><a href="#规则配置" class="headerlink" title="规则配置"></a>规则配置</h2><p>黑白名单规则（<code>AuthorityRule</code>）非常简单，主要有以下配置项：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>limitApp</code>：对应的黑名单/白名单，不同 origin 用 <code>,</code> 分隔，如 <code>appA,appB</code></li><li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式</li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>比如我们希望控制对资源 <code>test</code> 的访问设置白名单，只有来源为 <code>appA</code> 和 <code>appB</code> 的请求才可通过，则可以配置如下白名单规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AuthorityRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorityRule</span>();</span><br><span class="line">rule.setResource(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">rule.setStrategy(RuleConstant.AUTHORITY_WHITE);</span><br><span class="line">rule.setLimitApp(<span class="string">&quot;appA,appB&quot;</span>);</span><br><span class="line">AuthorityRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure><p>详细示例请参考 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/authority/AuthorityDemo.java">AuthorityDemo</a>.</p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 5」-- 熔断降级</title>
      <link href="/2023/06/07/Sentinel5-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
      <url>/2023/06/07/Sentinel5-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><img src="62410811-cd871680-b61d-11e9-9df7-3ee41c618644.png" alt="chain" style="zoom:50%;"><p>现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p><blockquote><p><strong>注意</strong>：本文档针对 Sentinel 1.8.0 及以上版本。1.8.0 版本对熔断降级特性进行了全新的改进升级，请使用最新版本以更好地利用熔断降级的能力。</p></blockquote><h2 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h2><p>Sentinel 提供以下几种熔断策略：</p><ul><li>**慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)**：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li><li>**异常比例 (<code>ERROR_RATIO</code>)**：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li><li>**异常数 (<code>ERROR_COUNT</code>)**：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li></ul><p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  entry = SphU.entry(resource);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write your biz code here.</span></span><br><span class="line">  <span class="comment">// &lt;&lt;BIZ CODE&gt;&gt;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!BlockException.isBlockException(t)) &#123;</span><br><span class="line">    Tracer.trace(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开源整合模块，如 Sentinel Dubbo Adapter, Sentinel Web Servlet Filter 或 <code>@SentinelResource</code> 注解会自动统计业务异常，无需手动调用。</p><h2 id="熔断降级规则说明"><a href="#熔断降级规则说明" class="headerlink" title="熔断降级规则说明"></a>熔断降级规则说明</h2><p>熔断降级规则（DegradeRule）包含下面几个重要的属性：</p><table><thead><tr><th align="center">Field</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，即规则的作用对象</td><td align="left"></td></tr><tr><td align="center">grade</td><td align="left">熔断策略，支持慢调用比例/异常比例/异常数策略</td><td align="left">慢调用比例</td></tr><tr><td align="center">count</td><td align="left">慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值</td><td align="left"></td></tr><tr><td align="center">timeWindow</td><td align="left">熔断时长，单位为 s</td><td align="left"></td></tr><tr><td align="center">minRequestAmount</td><td align="left">熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td><td align="left">5</td></tr><tr><td align="center">statIntervalMs</td><td align="left">统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td><td align="left">1000 ms</td></tr><tr><td align="center">slowRatioThreshold</td><td align="left">慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td><td align="left"></td></tr></tbody></table><h2 id="熔断器事件监听"><a href="#熔断器事件监听" class="headerlink" title="熔断器事件监听"></a>熔断器事件监听</h2><p>Sentinel 支持注册自定义的事件监听器监听熔断器状态变换事件（state change event）。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EventObserverRegistry.getInstance().addStateChangeObserver(<span class="string">&quot;logging&quot;</span>,</span><br><span class="line">    (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (newState == State.OPEN) &#123;</span><br><span class="line">            <span class="comment">// 变换至 OPEN state 时会携带触发时的值</span></span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;%s -&gt; OPEN at %d, snapshotValue=%.2f&quot;</span>, prevState.name(),</span><br><span class="line">                TimeUtil.currentTimeMillis(), snapshotValue));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(String.format(<span class="string">&quot;%s -&gt; %s at %d&quot;</span>, prevState.name(), newState.name(),</span><br><span class="line">                TimeUtil.currentTimeMillis()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>慢调用比例熔断示例：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/degrade/SlowRatioCircuitBreakerDemo.java">SlowRatioCircuitBreakerDemo</a></p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 4」-- 热点参数限流</title>
      <link href="/2023/06/07/Sentinel4-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/"/>
      <url>/2023/06/07/Sentinel4-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h1><h2 id="热点参数规则"><a href="#热点参数规则" class="headerlink" title="热点参数规则"></a>热点参数规则</h2><p>热点参数规则（<code>ParamFlowRule</code>）类似于流量控制规则（<code>FlowRule</code>）：</p><table><thead><tr><th align="center">属性</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，必填</td><td align="left"></td></tr><tr><td align="center">count</td><td align="left">限流阈值，必填</td><td align="left"></td></tr><tr><td align="center">grade</td><td align="left">限流模式</td><td align="left">QPS 模式</td></tr><tr><td align="center">durationInSec</td><td align="left">统计窗口时间长度（单位为秒），1.6.0 版本开始支持</td><td align="left">1s</td></tr><tr><td align="center">controlBehavior</td><td align="left">流控效果（支持快速失败和匀速排队模式），1.6.0 版本开始支持</td><td align="left">快速失败</td></tr><tr><td align="center">maxQueueingTimeMs</td><td align="left">最大排队等待时长（仅在匀速排队模式生效），1.6.0 版本开始支持</td><td align="left">0ms</td></tr><tr><td align="center">paramIdx</td><td align="left">热点参数的索引，必填，对应 <code>SphU.entry(xxx, args)</code> 中的参数索引位置</td><td align="left"></td></tr><tr><td align="center">paramFlowItemList</td><td align="left">参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 <code>count</code> 阈值的限制。<strong>仅支持基本类型和字符串类型</strong></td><td align="left"></td></tr><tr><td align="center">clusterMode</td><td align="left">是否是集群参数流控规则</td><td align="left"><code>false</code></td></tr><tr><td align="center">clusterConfig</td><td align="left">集群流控相关配置</td><td align="left"></td></tr></tbody></table><p>我们可以通过 <code>ParamFlowRuleManager</code> 的 <code>loadRules</code> 方法更新热点参数规则，下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ParamFlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowRule</span>(resourceName)</span><br><span class="line">    .setParamIdx(<span class="number">0</span>)</span><br><span class="line">    .setCount(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 针对 int 类型的参数 PARAM_B，单独设置限流 QPS 阈值为 10，而不是全局的阈值 5.</span></span><br><span class="line"><span class="type">ParamFlowItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamFlowItem</span>().setObject(String.valueOf(PARAM_B))</span><br><span class="line">    .setClassType(<span class="type">int</span>.class.getName())</span><br><span class="line">    .setCount(<span class="number">10</span>);</span><br><span class="line">rule.setParamFlowItemList(Collections.singletonList(item));</span><br><span class="line"></span><br><span class="line">ParamFlowRuleManager.loadRules(Collections.singletonList(rule));</span><br></pre></td></tr></table></figure><h2 id="热点限流"><a href="#热点限流" class="headerlink" title="热点限流"></a>热点限流</h2><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：</p><ul><li>商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制</li><li>用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制</li></ul><p>热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><img src="sentinel-hot-param-overview-1.png" alt="Sentinel Parameter Flow Control" style="zoom: 50%;"><p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>要使用热点参数限流功能，需要引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-parameter-flow-control<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后为对应的资源配置热点参数限流规则，并在 <code>entry</code> 的时候传入相应的参数，即可使热点参数限流生效。</p><blockquote><p>注：若自行扩展并注册了自己实现的 <code>SlotChainBuilder</code>，并希望使用热点参数限流功能，则可以在 chain 里面合适的地方插入 <code>ParamFlowSlot</code>。</p></blockquote><p>那么如何传入对应的参数以便 Sentinel 统计呢？我们可以通过 <code>SphU</code> 类里面几个 <code>entry</code> 重载方法来传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">entry</span><span class="params">(String name, EntryType type, <span class="type">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title function_">entry</span><span class="params">(Method method, EntryType type, <span class="type">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException</span><br></pre></td></tr></table></figure><p>其中最后的一串 <code>args</code> 就是要传入的参数，有多个就按照次序依次传入。比如要传入两个参数 <code>paramA</code> 和 <code>paramB</code>，则可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// paramA in index 0, paramB in index 1.</span></span><br><span class="line"><span class="comment">// 若需要配置例外项或者使用集群维度流控，则传入的参数只支持基本类型。</span></span><br><span class="line">SphU.entry(resourceName, EntryType.IN, <span class="number">1</span>, paramA, paramB);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。正确的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    entry = SphU.entry(resourceName, EntryType.IN, <span class="number">1</span>, paramA, paramB);</span><br><span class="line">    <span class="comment">// Your logic here.</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">    <span class="comment">// Handle request rejection.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">        entry.exit(<span class="number">1</span>, paramA, paramB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>@SentinelResource</code> 注解方式定义的资源，若注解作用的方法上有参数，Sentinel 会将它们作为参数传入 <code>SphU.entry(res, args)</code>。比如以下的方法里面 <code>uid</code> 和 <code>type</code> 会分别作为第一个和第二个参数传入 Sentinel API，从而可以用于热点规则判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;myMethod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">doSomething</span><span class="params">(String uid, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">  <span class="comment">// some logic here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sentinel-Dashboard热点限流配置"><a href="#Sentinel-Dashboard热点限流配置" class="headerlink" title="Sentinel-Dashboard热点限流配置"></a>Sentinel-Dashboard热点限流配置</h2><h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h3><p><strong>热点参数限流对默认的SpringMVC的Controller层资源无效，如果需要使用热点规则，需要使用 <code>@SentileResource</code> 注解进行单独标识。</strong></p><p>热点参数限流是分别统计参数值相同的请求数，判断是否超过QPS阈值。</p><img src="dashboard12.png" style="zoom:50%;"><p>如上图，有请求<code>goods/&#123;id&#125;</code>的资源，其中id是热点参数，其值有两种 1,3；如果需要对请求参数<code>id=1</code>进行限流，则需要进行热点参数限流：</p><img src="dashboard13.png" style="zoom: 33%;"><p>在热点参数限流的高级选项中，可以对部分参数进行<font color="green">例外配置</font>：</p><img src="dashboard14.png" style="zoom:33%;"><p>结合上一个配置，<strong>这里的含义是对索引值为0号（即请求资源时的第一个参数）的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：</strong></p><ul><li><strong>如果参数值是100，则每1秒允许的QPS为10；</strong></li><li><strong>如果参数值是101，则每1秒允许的QPS为10；</strong></li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 3 」-- 流量控制&amp;规则</title>
      <link href="/2023/06/07/Sentinel3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
      <url>/2023/06/07/Sentinel3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="流量控制-amp-规则"><a href="#流量控制-amp-规则" class="headerlink" title="流量控制&amp;规则"></a>流量控制&amp;规则</h1><h2 id="流量控制规则-FlowRule"><a href="#流量控制规则-FlowRule" class="headerlink" title="流量控制规则 (FlowRule)"></a>流量控制规则 (FlowRule)</h2><h3 id="流量规则的定义"><a href="#流量规则的定义" class="headerlink" title="流量规则的定义"></a>流量规则的定义</h3><p>重要属性：</p><table><thead><tr><th align="center">Field</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，资源名是限流规则的作用对象</td><td align="left"></td></tr><tr><td align="center">count</td><td align="left">限流阈值</td><td align="left"></td></tr><tr><td align="center">grade</td><td align="left">限流阈值类型，QPS 或线程数模式</td><td align="left">QPS 模式</td></tr><tr><td align="center">limitApp</td><td align="left">流控针对的调用来源</td><td align="left"><code>default</code>，代表不区分调用来源</td></tr><tr><td align="center">strategy</td><td align="left">调用关系限流策略：直接、链路、关联</td><td align="left">根据资源本身（直接）</td></tr><tr><td align="center">controlBehavior</td><td align="left">流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流</td><td align="left">直接拒绝</td></tr></tbody></table><p>同一个资源可以同时有多个限流规则。</p><h3 id="通过代码定义流量控制规则"><a href="#通过代码定义流量控制规则" class="headerlink" title="通过代码定义流量控制规则"></a>通过代码定义流量控制规则</h3><p>理解上面规则的定义之后，我们可以通过调用 <code>FlowRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFlowQpsRule</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">FlowRule</span> <span class="variable">rule1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">    rule1.setResource(resource);</span><br><span class="line">    <span class="comment">// Set max qps to 20</span></span><br><span class="line">    rule1.setCount(<span class="number">20</span>);</span><br><span class="line">    rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    rule1.setLimitApp(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    rules.add(rule1);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>FlowSlot</code> 会根据预设的规则，结合前面 <code>NodeSelectorSlot</code>、<code>ClusterNodeBuilderSlot</code>、<code>StatistcSlot</code> 统计出来的实时信息进行流量控制。</p><p>限流的直接表现是在执行 <code>Entry nodeA = SphU.entry(资源名字)</code> 的时候抛出 <code>FlowException</code> 异常。<code>FlowException</code> 是 <code>BlockException</code> 的子类，您可以捕捉 <code>BlockException</code> 来自定义被限流之后的处理逻辑。</p><p>同一个资源可以对应多条限流规则。<code>FlowSlot</code> 会对该资源的所有限流规则依次遍历，直到有规则触发限流或者所有规则遍历完毕。</p><p>一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><ul><li><code>resource</code>：资源名，即限流规则的作用对象</li><li><code>count</code>: 限流阈值</li><li><code>grade</code>: 限流阈值类型，QPS 或线程数</li><li><code>strategy</code>: 根据调用关系选择策略</li></ul><h3 id="基于QPS-并发数的流量控制"><a href="#基于QPS-并发数的流量控制" class="headerlink" title="基于QPS/并发数的流量控制"></a>基于QPS/并发数的流量控制</h3><p>流量控制主要有两种统计类型，一种是统计线程数，另外一种则是统计 QPS。类型由 <code>FlowRule.grade</code> 字段来定义。其中，0 代表根据并发数量来限流，1 代表根据 QPS 来进行流量控制。其中线程数、QPS 值，都是由 <code>StatisticSlot</code> 实时统计获取的。</p><p>可以通过下面的命令查看实时统计信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8719/cnode?id=resourceName</span><br></pre></td></tr></table></figure><p>输出内容格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx id   thread  pass  blocked   success  total Rt   1m-pass   1m-block   1m-all   exeption</span><br><span class="line">2   abc647 0     46     0           46     46   1       2763      0         2763     0</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>thread： 代表当前处理该资源的线程数；</li><li>pass： 代表一秒内到来到的请求；</li><li>blocked： 代表一秒内被流量控制的请求数量；</li><li>success： 代表一秒内成功处理完的请求；</li><li>total： 代表到一秒内到来的请求以及被阻止的请求总和；</li><li>RT： 代表一秒内该资源的平均响应时间；</li><li>1m-pass： 则是一分钟内到来的请求；</li><li>1m-block： 则是一分钟内被阻止的请求；</li><li>1m-all： 则是一分钟内到来的请求和被阻止的请求的总和；</li><li>exception： 则是一秒内业务本身异常的总和。</li></ul><h4 id="2-1-并发线程数流量控制"><a href="#2-1-并发线程数流量控制" class="headerlink" title="2.1 并发线程数流量控制"></a>2.1 并发线程数流量控制</h4><p>线程数限流用于保护业务线程数不被耗尽。例如，当应用所依赖的下游应用由于某种原因导致服务不稳定、响应延迟增加，对于调用者来说，意味着吞吐量下降和更多的线程数占用，极端情况下甚至导致线程池耗尽。为应对高线程占用的情况，业内有使用隔离的方案，比如通过不同业务逻辑使用不同线程池来隔离业务自身之间的资源争抢（线程池隔离），或者使用信号量来控制同时请求的个数（信号量隔离）。这种隔离方案虽然能够控制线程数量，但无法控制请求排队时间。当请求过多时排队也是无益的，直接拒绝能够迅速降低系统压力。Sentinel线程数限流不负责创建和管理线程池，而是简单统计当前请求上下文的线程个数，如果超出阈值，新的请求会被立即拒绝。例子参见：<a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/FlowThreadDemo.java">ThreadDemo</a></p><h4 id="2-2-QPS流量控制"><a href="#2-2-QPS流量控制" class="headerlink" title="2.2 QPS流量控制"></a>2.2 QPS流量控制</h4><p>当 QPS 超过某个阈值的时候，则采取措施进行流量控制。流量控制的手段包括下面 3 种，对应 <code>FlowRule</code> 中的 <code>controlBehavior</code> 字段：</p><ul><li><p>直接拒绝（<code>RuleConstant.CONTROL_BEHAVIOR_DEFAULT</code>）方式。该方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出<code>FlowException</code>。这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。具体的例子参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/FlowQpsDemo.java">FlowqpsDemo</a>。</p></li><li><p>冷启动（<code>RuleConstant.CONTROL_BEHAVIOR_WARM_UP</code>）方式。该方式主要用于系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮的情况。具体的例子参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/WarmUpFlowDemo.java">WarmUpFlowDemo</a>。</p><p>通常冷启动的过程系统允许通过的 QPS 曲线如下图所示：</p></li></ul><img src="warmup.gif" alt="冷启动过程 QPS 曲线" style="zoom:67%;"><ul><li><p>匀速器（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>）方式。这种方式严格控制了请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。具体的例子参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/flow/PaceFlowDemo.java">PaceFlowDemo</a>。</p><p>该方式的作用如下图所示：</p></li></ul><img src="queue.gif" alt="img" style="zoom: 40%;"><p>这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求。</p><h3 id="基于调用关系的流量控制"><a href="#基于调用关系的流量控制" class="headerlink" title="基于调用关系的流量控制"></a>基于调用关系的流量控制</h3><p>调用关系包括调用方、被调用方；方法又可能会调用其它方法，形成一个调用链路的层次关系。Sentinel 通过 <code>NodeSelectorSlot</code> 建立不同资源间的调用的关系，并且通过 <code>ClusterNodeBuilderSlot</code> 记录每个资源的实时统计信息。</p><p>有了调用链路的统计信息，我们可以衍生出多种流量控制手段。</p><h4 id="3-1-根据调用方限流"><a href="#3-1-根据调用方限流" class="headerlink" title="3.1 根据调用方限流"></a>3.1 根据调用方限流</h4><p><code>ContextUtil.enter(resourceName, origin)</code> 方法中的 <code>origin</code> 参数标明了调用方身份。这些信息会在 <code>ClusterBuilderSlot</code> 中被统计。可通过以下命令来展示不同的调用方对同一个资源的调用数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8719/origin?id=nodeA</span><br></pre></td></tr></table></figure><p>调用数据示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: nodeA</span><br><span class="line">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class="line">1   caller1 0         0         0          0        0     0         0          0</span><br><span class="line">2   caller2 0         0         0          0        0     0         0          0</span><br></pre></td></tr></table></figure><p>上面这个命令展示了资源名为 <code>nodeA</code> 的资源被两个不同的调用方调用的统计。</p><p>限流规则中的 <code>limitApp</code> 字段用于根据调用方进行流量控制。该字段的值有以下三种选项，分别对应不同的场景：</p><ul><li><code>default</code>：表示不区分调用者，来自任何调用者的请求都将进行限流统计。如果这个资源名的调用总和超过了这条规则定义的阈值，则触发限流。</li><li><code>&#123;some_origin_name&#125;</code>：表示针对特定的调用者，只有来自这个调用者的请求才会进行流量控制。例如 <code>NodeA</code> 配置了一条针对调用者<code>caller1</code>的规则，那么当且仅当来自 <code>caller1</code> 对 <code>NodeA</code> 的请求才会触发流量控制。</li><li><code>other</code>：表示针对除 <code>&#123;some_origin_name&#125;</code> 以外的其余调用方的流量进行流量控制。例如，资源<code>NodeA</code>配置了一条针对调用者 <code>caller1</code> 的限流规则，同时又配置了一条调用者为 <code>other</code> 的规则，那么任意来自非 <code>caller1</code> 对 <code>NodeA</code> 的调用，都不能超过 <code>other</code> 这条规则定义的阈值。</li></ul><p>同一个资源名可以配置多条规则，规则的生效顺序为：**{some_origin_name} &gt; other &gt; default**</p><h4 id="3-2-根据调用链路入口限流：链路限流"><a href="#3-2-根据调用链路入口限流：链路限流" class="headerlink" title="3.2 根据调用链路入口限流：链路限流"></a>3.2 根据调用链路入口限流：链路限流</h4><p><code>NodeSelectorSlot</code> 中记录了资源之间的调用链路，这些资源通过调用关系，相互之间构成一棵调用树。这棵树的根节点是一个名字为 <code>machine-root</code> 的虚拟节点，调用链的入口都是这个虚节点的子节点。</p><p>一棵典型的调用树如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          machine-root</span><br><span class="line">              /       \</span><br><span class="line">             /         \</span><br><span class="line">       Entrance1     Entrance2</span><br><span class="line">          /             \</span><br><span class="line">         /               \</span><br><span class="line">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure><p>上图中来自入口 <code>Entrance1</code> 和 <code>Entrance2</code> 的请求都调用到了资源 <code>NodeA</code>，Sentinel 允许只根据某个入口的统计信息对资源限流。比如我们可以设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.CHAIN</code>，同时设置 <code>FlowRule.ref_identity</code> 为 <code>Entrance1</code> 来表示只有从入口 <code>Entrance1</code> 的调用才会记录到 <code>NodeA</code> 的限流统计当中，而对来自 <code>Entrance2</code> 的调用漠不关心。</p><p>调用链的入口是通过 API 方法 <code>ContextUtil.enter(name)</code> 定义的。</p><h4 id="3-3-具有关系的资源流量控制：关联流量控制"><a href="#3-3-具有关系的资源流量控制：关联流量控制" class="headerlink" title="3.3 具有关系的资源流量控制：关联流量控制"></a>3.3 具有关系的资源流量控制：关联流量控制</h4><p>当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢，举例来说，<code>read_db</code> 和 <code>write_db</code> 这两个资源分别代表数据库读写，我们可以给 <code>read_db</code> 设置限流规则来达到写优先的目的：设置 <code>FlowRule.strategy</code> 为 <code>RuleConstant.RELATE</code> 同时设置 <code>FlowRule.ref_identity</code> 为 <code>write_db</code>。这样当写库操作过于频繁时，读数据的请求会被限流。</p><h2 id="开发中使用"><a href="#开发中使用" class="headerlink" title="开发中使用"></a>开发中使用</h2><p>在实际的开发中，常见的是在servlet的Filter层嵌入Sentinel流控。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Entry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphO;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.Tracer;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> com.maple.sentinecore.errorcode.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在仅导入Sentinel-Core依赖的场景下,使用Sentinel API自定义目标资源.</span></span><br><span class="line"><span class="comment"> * 在使用Spring-Cloud和Sentinel的整合包时,默认Controller层的所有URL自动注册为Sentinel的资源,不需要手动进行注册.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 类型强转</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求的uri地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> httpServletRequest.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;客户端请求|url:[&#123;&#125;]&quot;</span>, uri);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端请求|url:&quot;</span> + uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置限流规则</span></span><br><span class="line">        initFlowRules(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行限流</span></span><br><span class="line">        <span class="comment">// flowControlWithException(uri);</span></span><br><span class="line">        flowControlWithBoolean(uri, httpServletResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续执行过滤器链</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义注册Sentinel监控的目标资源.</span></span><br><span class="line"><span class="comment">     * 抛出异常的方式定义资源.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flowControlWithException</span><span class="params">(String uri)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将目标uri定义为资源,对其进行限流</span></span><br><span class="line">            entry = SphU.entry(uri);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为Sentinel的流控降级异常</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">blockException</span> <span class="operator">=</span> BlockException.isBlockException(throwable);</span><br><span class="line">            <span class="keyword">if</span> (blockException) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[flowControlWithException]|执行限流拦截策略...&quot;</span>);</span><br><span class="line">                log.error(<span class="string">&quot;[flowControlWithException]|Sentinel触发限流异常|e:&quot;</span>, throwable);</span><br><span class="line">                <span class="comment">// Maple TODO | 2023/5/11 : 执行限流拦截策略</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 业务异常</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动调用Tracer.trace(throwable)来记录业务异常,否则对应的业务异常不会统计到Sentinel的异常计数中.</span></span><br><span class="line">                <span class="comment">// 这样会导致如果使用异常数来进行熔断降级时会导致异常数统计不准.</span></span><br><span class="line">                Tracer.trace(throwable); <span class="comment">// 追踪业务异常,便于StatisticsSlot进行业务异常数统计.</span></span><br><span class="line">                log.error(<span class="string">&quot;[flowControlWithException]|SystemException&quot;</span>);</span><br><span class="line">                <span class="comment">// Maple TODO | 2023/5/15 : 系统异常处理</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放Sentinel的资源</span></span><br><span class="line">                <span class="comment">// SphU.entry(xxx) 需要与 entry.exit() 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 ErrorEntryFreeException 异常。</span></span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义注册Sentinel监控的目标资源.</span></span><br><span class="line"><span class="comment">     * 返回布尔值方式定义资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flowControlWithBoolean</span><span class="params">(String uri, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> SphO.entry(uri);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 目标资源通过限流控制,正常处理业务</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Maple TODO | 2023/6/1 : 业务处理</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// finally必须要执行</span></span><br><span class="line">                SphO.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 资源访被阻止,被限流或者降级</span></span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;[flowControlWithBoolean]|执行限流拦截策略...&quot;</span>);</span><br><span class="line">            log.error(<span class="string">&quot;[flowControlWithBoolean]|Sentinel触发限流&quot;</span>);</span><br><span class="line">            <span class="comment">// Maple TODO | 2023/6/1 : 拦截处理</span></span><br><span class="line"></span><br><span class="line">            <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">            <span class="type">byte</span>[] bytes = ErrorCode.SENTINEL_FLOWEXCEPTION.toString().getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            writer.write(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义限流规则 - QPS限流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri 目标资源地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initFlowRules</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">        <span class="comment">// 设置限流的目标资源</span></span><br><span class="line">        rule.setResource(uri);</span><br><span class="line">        <span class="comment">// 设置限流的类型|QPS or 线程数</span></span><br><span class="line">        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">        <span class="comment">// 设置QPS阈值</span></span><br><span class="line">        rule.setCount(<span class="number">1</span>);</span><br><span class="line">        rules.add(rule);</span><br><span class="line">        <span class="comment">// 加载限流规则</span></span><br><span class="line">        FlowRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中异常码为个人自定义二方工具包：<a href="https://gitee.com/maple_eitba/maple-commons">maple-commons</a></p></blockquote><h2 id="Sentinel-dashboard流控配置"><a href="#Sentinel-dashboard流控配置" class="headerlink" title="Sentinel-dashboard流控配置"></a>Sentinel-dashboard流控配置</h2><h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><p>可以为每个资源定义流控规则，在簇点链路界中点击目标资源后面的<code>+流控</code> 按钮，就会出现设置页面，如图：</p><img src="dashboard5.png" style="zoom:30%;"><ul><li>资源名：表示需要进行流控的目标资源名称，就是展示在簇点链路页面中所有资源的名称</li><li>针对来源：一般都是default</li><li>阈值类型：QPS or 线程数<ul><li>QPS是指对访问目标资源的QPS进行限制</li><li>线程数是指对访问目标资源的并发度进行限制</li></ul></li><li>单机阈值：单节点的访问限制值</li></ul><p>其含义是限制 <code>/order/&#123;orderId&#125;</code> 这个资源的单机QPS为5，即每秒只允许5次请求，超出的请求会被拦截并报错。</p><h4 id="流控高级选项"><a href="#流控高级选项" class="headerlink" title="流控高级选项"></a>流控高级选项</h4><p>限流规则中有两个高级选项，可以对流控模式和流控效果进行进一步的细化，如图：</p><img src="dashboard6.png" style="zoom:33%;"><h5 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h5><ul><li><p><strong>直接</strong>：统计当前资源的请求，触发阈值时对当前资源直接限流，默认模式；</p></li><li><p><strong>关联</strong>：统计与当前资源相关的另一个资源，<font color="green">当另一个资源触发阈值时，对当前资源限流；</font></p><ul><li>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。因此当修改订单业务触发阈值时，需要对查询订单业务限流。</li><li>满足下面条件可以使用关联模式：<ul><li>两个有竞争关系的资源；</li><li>一个优先级较高，一个优先级较低；<strong>当优先级高的资源达到阈值之后对优先级低的资源进行限流，高优先级的资源不受影响。</strong></li></ul></li></ul></li></ul><img src="dashboard7.png" style="zoom:35%;"><ul><li><strong>链路</strong>：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流；<ul><li>Sentinel默认只标记<code>Controller</code>层中的方法为资源，如果要标记其它方法，需要利用<code>@SentinelResource</code>注解，如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO 逻辑处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Sentinel默认会将<code>Controller</code>方法做<code>context</code> 整合 ，这会导致链路模式的流控失效，需要修改<code>application.yml</code>，添加配置：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure><ul><li>使用场景：<ul><li>例如有两条请求链路：<code>/test1 -&gt; /common</code> 和  <code>test2 -&gt; /common</code> 如果只希望统计从<code>/test2</code>进入到<code>/common</code>的请求，则可以这样配置：</li></ul></li></ul><img src="dashboard8.png" style="zoom:40%;"><h5 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h5><p>流控效果是指请求达到流控阈值时采取的措施，包括三种：</p><ul><li><p><strong>快速失败</strong>：请求达到阈值后，新的请求会被立即拒绝并抛出<code>FlowException异常</code>。默认流控效果。</p></li><li><p><strong>warm up</strong>：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p><ul><li><p>warm up也叫预热模式，是应对服务冷启动的一种方案（整体实现的方案和Dubbo的服务预热很类似）。请求阈值初始值是<code> threshold / coldFactor</code>，持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3。</p><p>例如，设置QPS的threshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10。整个过程如图：</p><img src="dashboard9.png" style="zoom:45%;"></li></ul></li><li><p><strong>排队等待</strong>：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</p><ul><li><p>当请求超过QPS阈值时，快速失败 和 warm up 都会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>例如：QPS = 5，意味着理论上每200ms处理一个队列中的请求；timeout = 2000，意味着预期等待超过2000ms的请求会被拒绝并抛出异常。如果队列中已经存在了10个请求，那么后续的请求等待时间理论上就是 10 * 200 ms = 2000ms，已经到达timeout时间了，请求就会被拒绝。</p><img src="dashboard10.png" style="zoom:50%;"></li><li><p>排队等待的限流效果其实就是流量整形</p></li><li><img src="dashboard11.png" style="zoom:50%;"></li></ul></li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/flow-control.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 2」-- Sentinel基本使用</title>
      <link href="/2023/06/07/Sentinel2-Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/06/07/Sentinel2-Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel基本使用"><a href="#Sentinel基本使用" class="headerlink" title="Sentinel基本使用"></a>Sentinel基本使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。</p><p>我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:</p><ol><li><strong>定义资源</strong></li><li><strong>定义规则</strong></li><li><strong>检验规则是否生效</strong></li></ol><p>先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。</p><blockquote><p>对于主流的框架，我们提供适配，只需要按照适配中的说明配置，Sentinel 就会默认定义提供的服务，方法等为资源。</p></blockquote><h2 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h2><h3 id="方式一：主流框架的默认适配"><a href="#方式一：主流框架的默认适配" class="headerlink" title="方式一：主流框架的默认适配"></a>方式一：主流框架的默认适配</h3><p>为了减少开发的复杂程度，我们对大部分的主流框架，例如 Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux、Reactor 等都做了适配。您只需要引入对应的依赖即可方便地整合 Sentinel。可以参见：<a href="https://sentinelguard.io/zh-cn/docs/open-source-framework-integrations.html">主流框架的适配</a>。</p><blockquote><p>我们在实际开发中一般都是根据应用项目使用的框架来使用对应的Sentinel适配框架。</p></blockquote><h3 id="方式二：抛出异常的方式定义资源"><a href="#方式二：抛出异常的方式定义资源" class="headerlink" title="方式二：抛出异常的方式定义资源"></a>方式二：抛出异常的方式定义资源</h3><p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.5.0 版本开始可以利用 try-with-resources 特性</span></span><br><span class="line"><span class="comment">// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;resourceName&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// 被保护的业务逻辑</span></span><br><span class="line">  <span class="comment">// do something here...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">  <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">  <span class="comment">// 在此处进行相应的处理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别地</strong>，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 <code>Tracer.trace(ex)</code> 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 <code>Tracer.trace(ex)</code>。</p><p>1.5.0 之前的版本的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 务必保证finally会被执行</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 资源名可使用任意有业务语义的字符串</span></span><br><span class="line">  entry = SphU.entry(<span class="string">&quot;自定义资源名&quot;</span>);</span><br><span class="line">  <span class="comment">// 被保护的业务逻辑</span></span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">  <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">  <span class="comment">// 进行相应的处理操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">    entry.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>SphU.entry(xxx)</code> 需要与 <code>entry.exit()</code> 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 <code>ErrorEntryFreeException</code> 异常。</p><h3 id="方式三：返回布尔值方式定义资源"><a href="#方式三：返回布尔值方式定义资源" class="headerlink" title="方式三：返回布尔值方式定义资源"></a>方式三：返回布尔值方式定义资源</h3><p><code>SphO</code> 提供 if-else 风格的 API。用这种方式，当资源发生了限流之后会返回 <code>false</code>，这个时候可以根据返回值，进行限流之后的逻辑处理。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 资源名可使用任意有业务语义的字符串</span></span><br><span class="line"><span class="keyword">if</span> (SphO.entry(<span class="string">&quot;自定义资源名&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// 务必保证finally会被执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被保护的业务逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    SphO.exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">  <span class="comment">// 进行相应的处理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式四：注解方式定义资源"><a href="#方式四：注解方式定义资源" class="headerlink" title="方式四：注解方式定义资源"></a>方式四：注解方式定义资源</h3><p>Sentinel 提供了 <code>@SentinelResource</code> 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 <code>BlockException</code> 等。使用 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-extension/sentinel-annotation-aspectj">Sentinel Annotation AspectJ Extension</a> 的时候需要引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SentinelResource-注解"><a href="#SentinelResource-注解" class="headerlink" title="@SentinelResource 注解"></a>@SentinelResource 注解</h4><blockquote><p>注意：注解方式埋点不支持 private 方法。</p></blockquote><p><code>@SentinelResource</code> 用于定义资源，并提供可选的异常处理和 fallback 配置项。 <code>@SentinelResource</code> 注解包含以下属性：</p><ul><li><p><code>value</code>：资源名称，必需项（不能为空）</p></li><li><p><code>entryType</code>：entry 类型，可选项（默认为 <code>EntryType.OUT</code>）</p></li><li><p><code>blockHandler</code> / <code>blockHandlerClass</code>: <code>blockHandler</code> 对应处理 <code>BlockException</code> 的函数名称，可选项。blockHandler 函数访问范围需要是 <code>public</code>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 <code>BlockException</code>。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</p></li><li><p><code>fallback</code>：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li><li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p><code>defaultFallback</code></p><p>（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所以类型的异常（除了exceptionsToIgnore里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要为空，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li><li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul></li><li><p><code>exceptionsToIgnore</code>（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</p></li></ul><blockquote><p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（<code>DegradeException</code>）进行处理，<strong>不能针对业务异常进行处理</strong>。</p></blockquote><p>特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 <code>BlockException</code> 时只会进入 <code>blockHandler</code> 处理逻辑。若未配置 <code>blockHandler</code>、<code>fallback</code> 和 <code>defaultFallback</code>，则被限流降级时会将 <code>BlockException</code> <strong>直接抛出</strong>。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 static 函数.</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;test&quot;, blockHandler = &quot;handleException&quot;, blockHandlerClass = &#123;ExceptionUtil.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原函数</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;hello&quot;, blockHandler = &quot;exceptionHandler&quot;, fallback = &quot;helloFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="type">long</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Hello at %d&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloFallback</span><span class="params">(<span class="type">long</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Halooooo %d&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">exceptionHandler</span><span class="params">(<span class="type">long</span> s, BlockException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// Do some log here.</span></span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Oops, error occurred at &quot;</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 1.4.0 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.4.0 以前的版本需要自行调用 <code>Tracer.trace(ex)</code> 来记录业务异常。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>AspectJ</strong></p><p>若您的应用直接使用了 AspectJ，那么您需要在 <code>aop.xml</code> 文件中引入对应的 Aspect：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">&quot;com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Spring AOP</strong></p><p>若您的应用使用了 Spring AOP，您需要通过配置的方式将 <code>SentinelResourceAspect</code> 注册为一个 Spring Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SentinelAspectConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SentinelResourceAspect <span class="title function_">sentinelResourceAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SentinelResourceAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提供了 Spring AOP 的示例，可以参见 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/tree/master/sentinel-demo/sentinel-demo-annotation-spring-aop">sentinel-demo-annotation-spring-aop</a>。</p><h3 id="方式五：异步调用支持"><a href="#方式五：异步调用支持" class="headerlink" title="方式五：异步调用支持"></a>方式五：异步调用支持</h3><p>Sentinel 支持异步调用链路的统计。在异步调用中，需要通过 <code>SphU.asyncEntry(xxx)</code> 方法定义资源，并通常需要在异步的回调函数中调用 <code>exit</code> 方法。以下是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">AsyncEntry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.asyncEntry(resourceName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步调用.</span></span><br><span class="line">    doAsync(userId, result -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在此处处理异步调用的结果.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在回调结束后 exit.</span></span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">    <span class="comment">// Request blocked.</span></span><br><span class="line">    <span class="comment">// Handle the exception (e.g. retry or fallback).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SphU.asyncEntry(xxx)</code> 不会影响当前（调用线程）的 Context，因此以下两个 entry 在调用链上是平级关系（处于同一层），而不是嵌套关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用链类似于：</span></span><br><span class="line"><span class="comment">// -parent</span></span><br><span class="line"><span class="comment">// ---asyncResource</span></span><br><span class="line"><span class="comment">// ---syncResource</span></span><br><span class="line">asyncEntry = SphU.asyncEntry(asyncResource);</span><br><span class="line">entry = SphU.entry(normalResource);</span><br></pre></td></tr></table></figure><p>若在异步回调中需要嵌套其它的资源调用（无论是 <code>entry</code> 还是 <code>asyncEntry</code>），只需要借助 Sentinel 提供的上下文切换功能，在对应的地方通过 <code>ContextUtil.runOnContext(context, f)</code> 进行 Context 变换，将对应资源调用处的 Context 切换为生成的异步 Context，即可维持正确的调用链路关系。Context 维持的方式：通过 ThreadLocal 传递，只有在入口 <code>enter</code> 的时候生效。由于 Context 是通过 ThreadLocal 传递的，因此对于异步调用链路，线程切换的时候会丢掉 Context，因此需要手动通过 <code>ContextUtil.runOnContext(context, f)</code> 来变换 context。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        entry = SphU.entry(<span class="string">&quot;handleResultForAsync&quot;</span>);</span><br><span class="line">        <span class="comment">// Handle your result here.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">        <span class="comment">// Blocked for the result handler.</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">            entry.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">AsyncEntry</span> <span class="variable">entry</span> <span class="operator">=</span> SphU.asyncEntry(resourceName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Asynchronous invocation.</span></span><br><span class="line">        doAsync(userId, result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 在异步回调中进行上下文变换，通过 AsyncEntry 的 getAsyncContext 方法获取异步 Context</span></span><br><span class="line">            ContextUtil.runOnContext(entry.getAsyncContext(), () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 此处嵌套正常的资源调用.</span></span><br><span class="line">                    handleResult(result);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    entry.exit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">        <span class="comment">// Request blocked.</span></span><br><span class="line">        <span class="comment">// Handle the exception (e.g. retry or fallback).</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的调用链就类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-parent</span><br><span class="line">---asyncInvocation</span><br><span class="line">-----handleResultForAsync</span><br></pre></td></tr></table></figure><p>更详细的示例可以参考 Demo 中的 <a href="https://gitee.com/maple_eitba/maple-sentinel-1.8.1/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/AsyncEntryDemo.java">AsyncEntryDemo</a>，里面包含了普通资源与异步资源之间的各种嵌套示例。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/basic-api-resource-rule.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim基础</title>
      <link href="/2023/05/29/Vim/"/>
      <url>/2023/05/29/Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim基础"><a href="#Vim基础" class="headerlink" title="Vim基础"></a>Vim基础</h1><h2 id="Vim的操作模式"><a href="#Vim的操作模式" class="headerlink" title="Vim的操作模式"></a>Vim的操作模式</h2><p>Vim有四种操作模式，分别为：</p><ul><li><strong>正常模式(normal-mode)</strong></li><li><strong>插入模式(insert-mode)</strong></li><li><strong>命令模式(command-mode)</strong></li><li><strong>可视模式(visual-mode)</strong></li></ul><h3 id="①-正常模式"><a href="#①-正常模式" class="headerlink" title="①  正常模式"></a>①  正常模式</h3><p>正常模式主要用来浏览和修改文本内容的。</p><p>一般的打开Vim之后默认的都是正常模式。在任何模式下，只要按下 <code>Esc 键</code>就可以返回正常模式。</p><h3 id="②-插入模式"><a href="#②-插入模式" class="headerlink" title="② 插入模式"></a>② 插入模式</h3><p>插入模式是用来向文本中添加内容的。</p><p><strong>i</strong>：表示进入插入模式，并在光标所在字符前开始输入；</p><p><strong>a</strong>：表示进入插入模式，并在光标所在字符后开始输入；</p><p><strong>o</strong> (字母o)：表示进入插入模式并在光标所在行的下一新行开始输入；</p><p><strong>s</strong>：表示进入插入模式，并删除光标所在的字符；</p><p><strong>I</strong>：在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。如果行首有空格，则在    空格之后输入文字并进入插入模式；</p><p><strong>A</strong>：在行尾开始输入文字并进入插入模式。这个好用，您不必管光标在此行的什麽地方，只要按 A 就会在行尾等着您输入文字；</p><p><strong>O</strong> (大写字母O)：在光标所在行的上面单独开一新行来输入文字并进入插入模式；</p><p><strong>S</strong>：删除光标所在行并进入插入模式；</p><h3 id="③-命令模式"><a href="#③-命令模式" class="headerlink" title="③ 命令模式"></a>③ 命令模式</h3><p>命令模式则多用于操作文件。不是操作文本文件的内容，而是对文件本身进行操作，例如：保存文件等；或者用来改变编辑器本身的状态，例如：设定多栏窗口、标签或者退出编辑器等。</p><h3 id="④-可视模式"><a href="#④-可视模式" class="headerlink" title="④ 可视模式"></a>④ 可视模式</h3><p>可视模式相当于高亮选取文本后的普通模式。</p><p>可视模式具有子模式，以行为单位进行选取的可视行模式，使用<code>“V”</code>键进入（也就是<code>Shift+v</code>）；和以块为单位进行选取的可视块模式，使用<code>“Ctrl+v”</code>键进入。</p><h2 id="模式之间的切换"><a href="#模式之间的切换" class="headerlink" title="模式之间的切换"></a>模式之间的切换</h2><h3 id="其它模式-gt-正常模式"><a href="#其它模式-gt-正常模式" class="headerlink" title="其它模式==&gt;正常模式"></a>其它模式==&gt;正常模式</h3><ul><li>按 Esc键</li></ul><h3 id="正常模式-gt-插入模式"><a href="#正常模式-gt-插入模式" class="headerlink" title="正常模式==&gt;插入模式"></a>正常模式==&gt;插入模式</h3><ul><li>按 i 在光标前插入</li><li>按 I 在行首插入</li><li>按 a 在光标后插入</li><li>按 s 删除光标所在的字符再插入</li><li>按 A 在行末插入</li><li>按 o 在当前行之下新建行</li><li>按 O 在当前行之上新建行</li><li>按 S 删除光标所在行再插入</li></ul><h3 id="正常模式-gt-命令模式"><a href="#正常模式-gt-命令模式" class="headerlink" title="正常模式==&gt;命令模式"></a>正常模式==&gt;命令模式</h3><ul><li>按（shift 加 冒号）或 /</li></ul><h3 id="正常模式-gt-可视模式"><a href="#正常模式-gt-可视模式" class="headerlink" title="正常模式==&gt;可视模式"></a>正常模式==&gt;可视模式</h3><ul><li>按 v 可视模式</li><li>按 V 可视块模式</li></ul><p>以下是正常模式【一般模式】、插入模式【编辑模式】和命令模式之间的转换图，没有视图模式是因为其就是高亮后的正常模式。</p><img src="vim1.png" style="zoom:33%;"><h2 id="命令模式下的基本操作"><a href="#命令模式下的基本操作" class="headerlink" title="命令模式下的基本操作"></a>命令模式下的基本操作</h2><p><strong>:w</strong> 保存编辑后的文件内容，但不退出vim编辑器。</p><p>这个命令的作用是把内存缓冲区【一个隐藏目录】中的数据写到启动vim时指定的文件中。</p><p><strong>:w!</strong> 强制写文件，即强制覆盖原有文件。</p><p>如果原有文件的访问权限不允许写入文件，例如，原有的文件为只读文件，则可使用这个命令强制写入。但是，这种命令用法仅当用户是文件的属主时才适用，而超级用户则不受此限制<strong>。</strong></p><p><strong>:w filename</strong> 把编辑处理后的结果写到指定的文件中保存，不退出vim。</p><p><strong>:w! filename</strong> 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件。</p><p><strong>:wq</strong> 保存文件并退出vim。</p><p><strong>:wq!</strong> 强制保存文件，并退出vim。</p><p><strong>:wq! filename</strong> 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件，并退出vim编辑器。</p><p><strong>:q</strong> 不保存文件，退出vim【在没有做任何修改的前提下可以退出；如果有修改操作使用该命令会有提示该命令无法生效】。</p><blockquote><p><strong>提示内容：</strong>E37: 已修改但尚未保存 (可用 ! 强制执行)</p></blockquote><p><strong>:q!</strong> 不保存文件，强制退出vim【在有无修改操作的情况下都可以使用】。</p><p><strong>:e!</strong> 放弃所有修改，从上次保存文件开始再编辑。</p><h2 id="Vim常用快捷键"><a href="#Vim常用快捷键" class="headerlink" title="Vim常用快捷键"></a>Vim常用快捷键</h2><p><strong>【正常模式】yy + p</strong> ：拷贝当前行；</p><p>​    在正常模式下，使用yy复制当前行，p粘贴当前行。</p><p><strong>【正常模式】数字yy + p</strong>：多行拷贝，拷贝当前行向下的指定数字行；如：3yy + p，拷贝当前行的下三行【包括当前行】至当前行的下一行；</p><p><strong>【正常模式】/关键字</strong> <strong>+ Ente</strong>r：在文件中查找某个单词，如果有多个结果，使用 n 进行切换；</p><p><strong>【正常模式】G</strong>：跳至文档的最末行；</p><p><strong>【正常模式】gg</strong>：跳至文档的首行；</p><p>【<strong>正常模式】n</strong>：撤销操作；</p><p><strong>【正常模式】数字 + shift + g</strong>：跳转至指定行的行首；</p><ol><li>第一步：显示行号，<code>:set nu</code>；</li><li>第二步：输入指定行数，如：10；</li><li>第三步：输入<code>shift + g</code>；</li></ol><img src="vim2.jpeg" style="zoom:80%;"><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://www.jianshu.com/p/14fde3a5ed25">Vim四种模式切换与基本命令</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「设计模式」- 单例模式</title>
      <link href="/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>在类加载的时候直接将Singleton对象提前创建好，等需要用的时候调用<code>getSingleton()</code>方法获取即可。</p><p>提前创建，是一种空间换时间的方式，无法实现延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 特点:</span></span><br><span class="line"><span class="comment"> * 1. 空间换时间 -- 一上来就创建对象(慢),后面直接用就好;</span></span><br><span class="line"><span class="comment"> * 2. 线程安全;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法,其他类不能访问该构造方法，即无法通过构造器来实例化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有当前类的实例对象,让外部对象无法直接对其进行访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK源码中的典型实现： <code>java.lang.Runtime</code>类 和 <code>Unsafe</code>类（只不过获取Unsafe实例时往往使用反射打破单例模式强行创建）。</p><p>JVM中的Runtime类就是饿汉式单例模型的典型实现，只能通过 <code>Runtime.getRuntime()</code>方法获取其实例对象。</p></blockquote><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>等需要使用单例对象的时候才去实例化对象，是一种时间换空间的延迟加载方式，线程不安全，实际开发中一般不用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式(延迟加载模式)</span></span><br><span class="line"><span class="comment"> * 特点:</span></span><br><span class="line"><span class="comment"> * 1. 时间换空间 -- 一上来只是声明(快),等需要的时候再创建对象</span></span><br><span class="line"><span class="comment"> * 2. 线程不安全;在多线程访问时,懒汉式可能会创建多个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在多线程时，线程1执行到这一步,刚刚创建完对象执行权就被别的线程抢占了，</span></span><br><span class="line">            <span class="comment">// 另外一个线程执行到上一句的判断时依旧成立，就会再次进入并创建一个对象，这就不是单例了</span></span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于synchronized-线程安全型懒汉式"><a href="#基于synchronized-线程安全型懒汉式" class="headerlink" title="基于synchronized 线程安全型懒汉式"></a>基于synchronized 线程安全型懒汉式</h2><p>对于上述线程安全的问题，可以使用synchronized关键字加锁来保证线程安全，不过，加锁会导致串行化，会在一定程度上影响代码性能。</p><blockquote><p>不过随着JDK对synchroniezd锁的优化，这种性能损耗也是越来越小，可以忽略不计。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供公共的访问方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            s = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DCL（Double-Check-Lock）"><a href="#DCL（Double-Check-Lock）" class="headerlink" title="DCL（Double Check Lock）"></a>DCL（Double Check Lock）</h2><p>DCL（Double Check Lock），双重检查锁，比线程安全型的懒汉式运行效率更高。</p><p>对获取单例对象的请求有<strong>分流</strong>，只在获取不到单例对象的时候才会去创建对象；在单例对象存在时直接获取，方法的执行效率高；</p><p><strong>DCL存在的问题:</strong></p><p>由于JVM在编译和运行的时候都会对代码进行一定的优化，比如：指令重排；因此可能会导致NullPointerException – Singleton对象创建过程有指定重排。</p><p>当一个线程执行请求获取单例对象，进入同步代码块创建一个单例对象；另外一个线程也尝试获取单例对象，判断得知单例对象已经创建，直接返回创建的对象供其使用，但是在使用的过程中可能会出现空指针异常，因为指令重排可能会导致对象是创建出来了，但尚未完成初始化，所以另外一个线程获取的对象内部可能有值为null的属性；</p><blockquote><p>JVM中对象的实例化过程简单地说：加载、链接、初始化、使用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经创建了对象，就直接返回已创建的对象，不需要获取锁这一环节了。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 再次判断对象是否为空是针对获取锁阻塞的场景，如果其他线程已经获取锁并创建了实例对象，等当期线程获取到锁时，对象已经被创建了。</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="禁止指令重排的DCL"><a href="#禁止指令重排的DCL" class="headerlink" title="禁止指令重排的DCL"></a>禁止指令重排的DCL</h2><p>volatile 关键字会禁止指令重排，保证创建对象的过程是有序的，即可保证使用的对象都是已经完成了初始化操作的完整对象；</p><blockquote><p>JVM使用指令重排的目的就是优化性能，所以频繁使用volatile禁止指令重排会影响性能；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// Singleton对象的创建过程不会进行指令重排。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Holder"><a href="#Holder" class="headerlink" title="Holder"></a>Holder</h2><p>懒加载|线程安全|效率高，充分利用了JVM的类加载机制。</p><blockquote><p>JVM中的类加载机制为懒加载，一个应用在启动的时候不会一上来就直接加载应用中所有引入的类，而是加载应用启动时有使用的类，剩余没有加载的类只有在用到的使用才会加载。所以从Java应用启动的时候，就会创建一个方法区，随着业务场景的调用，使用到的类越来越多，方法区中的已使用内存也会越来越大，直到该应用中所有用到的类都经历了加载，那么方法区中的已使用内存大小就会趋于稳定不变。</p><p>当然了，也有例外，方法区中存放的是类信息和字符串常量池（JDK1.6），针对这两块在程序运行时还有有可能会越来越大。</p><p>类信息：运行时不断地增加加载的类。</p><ol><li>自定义类加载器，去自定目录下加载自定义类；</li><li>反射，通过反射不断地生成Class文件；</li></ol><p>字符串常量池：不断地创建字符串对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒加载|线程安全|效率高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用静态内部类的类变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="comment">// static保证唯一性，充分利用类加载机制。类只会被加载一次，所以只会创建一个Singleton对象。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>线程安全|懒加载|高效|优雅</p><p>充分利用枚举项的构造器只会执行一次的特性来创建单例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法,其他类不能访问该构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 充分利用了枚举项的构造函数只会执行一次的特点来进行单例对象的实例化;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">SingletionEnum</span> &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton singleton;</span><br><span class="line">        </span><br><span class="line">        SingletionEnum() &#123;</span><br><span class="line">            <span class="built_in">this</span>.singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletionEnum.INSTANCE.getSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打破单例"><a href="#打破单例" class="headerlink" title="打破单例"></a>打破单例</h1><p>Singleton单例模式从其定义出发就是永远获取的是同一个对象，但是可以通过反射来打破单例；</p><p>单例实现的核心就是通过私有化构造器，让外界无法通过构造器来创建对象，而是在类的内部维护了一个对象的引用，来实现单例；而反射可以在系统运行时通过Class对象来获取对象的构造器，包括私有构造器，然后通过获取的构造器对象来创建对象；这样就打破了单例模式。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式不是绝对的，可以通过反射来破解单例;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量|共享</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块只会在类加载的时候执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获取私有构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置对私有构造器的访问</span></span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 通过私有构造器来创建一个对象</span></span><br><span class="line">            singleton = (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码获取的就是一个新的单例对象，和<code>Singleton.getIntance()</code>获取的不是同一个对象；但是利用上述方法获取的都是同一个对象；因为创建对象的过程是在静态代码块中，所以创建对象的过程只会在类加载的时候执行一次，所以通过<code>create()</code>方法获取的都是同一个对象；</p><p>也可以写的更过分，将单例粉碎了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(Singleton.class.getName());</span><br><span class="line">            <span class="comment">// 获取私有构造器</span></span><br><span class="line">            Constructor&lt;?&gt; declaredConstructor = aClass.getDeclaredConstructor();</span><br><span class="line">            <span class="comment">// 设置对私有构造器的访问</span></span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 通过私有构造器来创建一个对象</span></span><br><span class="line">            singleton = (Singleton) declaredConstructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码每获取一次对象，都是通过反射重新创建一个新的对象，返回的结果没有一个是相同的，都是新生成的对象，单例已经不复存在了。</p><hr>]]></content>
      
      
      <categories>
          
          <category> OOA&amp;OOD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析面向对象和面向过程</title>
      <link href="/2023/05/23/%E6%B5%85%E6%9E%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/05/23/%E6%B5%85%E6%9E%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析面向对象和面向过程"><a href="#浅析面向对象和面向过程" class="headerlink" title="浅析面向对象和面向过程"></a>浅析面向对象和面向过程</h1><p><font color="green"><strong>面向过程和面向对象都是对软件分析、设计和开发的一种思想，它指导着开发者以不同的方式去分析、设计和开发软件。</strong></font> </p><p>早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的不足也越来越明显，随之应运而生的就是面向对象思想，并成为目前开发者们使用的主流思想。两者都贯穿于软件分析、设计和开发各个阶段，根据面向对象思想的使用场景，又可以分别称为 <strong>面向对象分析（OOA）</strong>、<strong>面向对象设计（OOD）</strong>和<strong>面向对象编程（OOP）</strong>。</p><blockquote><p>C语言是一种典型的面向过程语言，Java是一种典型的面向对象语言。</p></blockquote><p>面向过程思想思考问题时，我们首先思考“怎么按<strong>步骤</strong>实现？”并将步骤对应成方法，一步一步，最终完成。 这种适合简单的任务，不需要过多协作的情况下。比如，如何开车？我们很容易就列出实现步骤：</p><p><code>点火</code> –&gt; <code>挂挡</code> –&gt; <code>给油</code> –&gt; <code>走你</code></p><p>面向过程适合简单、不需要太多模块协作的事务，重点关注如何一步一步地执行。</p><p>但是当我们思考比较复杂的设计任务时，比如“如何造车？”，就会发现列出1234这样的步骤，是不可能的。因为造车太复杂，需要很多部门协作才能完成。此时面向对象思想就非常适用了。</p><p>面向对象(Oriented-Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？” 比如：思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。</p><p>其次应该思考”应该让谁来实现?”，这个”谁”就是对象 , 对象如何实现我们不关注，只关注对象本身。</p><p>我们会从“车由什么组成”开始思考。发现车由如下对象组成：</p><ul><li>轮胎</li><li>发送机</li><li>底盘</li><li>外壳</li><li>…</li></ul><p>为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤，等等；这样，发现各个模块可以分别同时进行车部件的制造，互相不用关心彼此，直到最终进行组装，大大提高了效率。但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开执行者、离不开面向过程思维！</p><p><strong>区别：</strong></p><ul><li>面向过程：目标事物相对比较简单，可以使用线性的思维去解决</li><li>面向对象：目标事物相对复杂，无法使用简单线性的思维去解决</li></ul><p><strong>共同点：</strong></p><ul><li>面向过程和面向对象都是解决实际问题的一种思维方式；</li><li><font color="red"><strong>面向过程和面向对象二者是相辅相成的，并不是对立的。</strong></font></li><li><font color="green"><strong>解决复杂问题，通过面向对象思想便于我们从宏观上把握事物之间的复杂关系、方便梳理整个系统；而具体到内部微观实现层面，还是需要使用面向过程思想来进行一步一步的处理。</strong></font></li></ul><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://blog.csdn.net/m0_62886303/article/details/123377192">浅谈面向对象和面向过程</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象，面向过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析数仓</title>
      <link href="/2023/05/18/%E6%B5%85%E6%9E%90%E6%95%B0%E4%BB%93/"/>
      <url>/2023/05/18/%E6%B5%85%E6%9E%90%E6%95%B0%E4%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析数仓"><a href="#浅析数仓" class="headerlink" title="浅析数仓"></a>浅析数仓</h1><p>随着互联网及物联网等技术发展，越来越多的数据被生成，如何有效利用这些数据就成为了企业决胜的法宝了。大型公司会基于数据做出BI、推荐系统、决策支持、统计分析、报表等业务。</p><h2 id="OLTP-VS-OLAP"><a href="#OLTP-VS-OLAP" class="headerlink" title="OLTP VS OLAP"></a>OLTP VS OLAP</h2><p>1970年随着关系数据库理论的提出，诞生了一系列经典的RDBMS，如MySQL、Oracle、SQL Server、DB2等。这些RDBMS为社会信息化的发展做出的重大贡献。然而随着数据库使用范围的不断扩大，它被逐步划分为<strong>操作型数据库</strong>OLTP（在线事务处理）跟<strong>分析型数据库</strong>OLAP（在线分析处理）。</p><h3 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h3><p><strong>操作型数据库OLTP</strong>（On-Line Transaction Processing 在线事务处理）也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对记录进行CRUD。OLTP模式下用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。</p><h3 id="OLAP"><a href="#OLAP" class="headerlink" title="OLAP"></a>OLAP</h3><p><strong>分析型数据库OLAP</strong>（On-Line Analytical Processing）叫在线分析处理，主要用于历史数据分析。这类数据库作为公司的单独数据存储，负责利用历史数据对公司各<strong>主题域</strong>进行统计分析。为啥要分成操作型跟分析型呢？原因是他们有太多不同了！</p><img src="dw1.png" style="zoom:80%;"><h3 id="操作型OLTP-VS-分析型OLAP"><a href="#操作型OLTP-VS-分析型OLAP" class="headerlink" title="操作型OLTP VS 分析型OLAP"></a>操作型OLTP VS 分析型OLAP</h3><p>之所以区分为操作型跟分析型，那是因为这俩的核心功能不同！前者主要是面向操作，后者主要是面向分析，在细节上存在众多差异。</p><h4 id="数据组成差别"><a href="#数据组成差别" class="headerlink" title="数据组成差别"></a>数据组成差别</h4><ul><li>数据时间范围不同：一般操作型数据库只存放90天内数据，分析型数据存放数年内数据，所以这俩要进行物理分离。</li><li>数据细节差异不同：操作型数据库主要存放细节数据，汇总数据是动态技术而成的。分析型数据库中既存放细节数据又存放用户关系的汇总数据。</li><li>数据时间表示不同：操作型数据库反应的是当前状态，分析师数据库中既有当前状态又有过去各时刻的快照数据。</li></ul><h4 id="技术差别"><a href="#技术差别" class="headerlink" title="技术差别"></a>技术差别</h4><ul><li>查询数量跟频率不同：操作型数据库查询频率高但量小，分析型数据库查询量大但频率低。</li><li>数据更新不同：操作型数据库设计到用户CRUD。<font color="cornflowerblue">分析型数据库属于归档性质存储，只提供查询。</font></li><li>数据冗余性不同：<font color="cornflowerblue">操作型数据库在设计表的时候就会减少数据冗余避免更新复杂。</font>分析型数据库中则只有查询功能，因此数据冗余性一般都存在。</li></ul><h4 id="功能差别"><a href="#功能差别" class="headerlink" title="功能差别"></a>功能差别</h4><ul><li>数据读者不同：操作型数据的使用者是业务环节下的各个角色，比如用户、商家等。分析型数据库一般只有研发跟数据分析人员专门使用。</li><li>定位不同：操作型数据库主要是面向应用层的数据库，是为了支持具体业务而存在的。分析型数据库是针对特定业务主体域的分析人物而创建的，是面向主体型数据库。</li></ul><h2 id="数仓"><a href="#数仓" class="headerlink" title="数仓"></a>数仓</h2><h3 id="数仓简介"><a href="#数仓简介" class="headerlink" title="数仓简介"></a>数仓简介</h3><p>随着人类IT发展，数据越来越多被产生，并且这些数据还可能跨部门，跨业务。如何把数据集成起来进行OLAP是个巨大挑战。数据仓库(Data Warehouse)应运而生，数据仓库是一个<strong>面向主题的</strong>、集成的、相对稳定的、反映历史变化的数据集合，用于支持管理中的决策制定。数据仓库是伴随着企业信息化发展起来的，在企业信息化的过程中，随着信息化工具的升级和新工具的应用，数据量变的越来越大，数据格式越来越多，决策要求越来越苛刻，数据仓库技术也在不停的发展。数据仓库的趋势：</p><ul><li>实时数据仓库以满足实时化&amp;自动化决策需求。</li><li>大数据&amp;数据湖以支持大量&amp;复杂数据类型(文本、图像、视频、音频)。</li></ul><p>对于数仓可以理解为原来各个数据孤岛中的数据可能存储位置、存储格式、编程语言等各个方面不同。数仓要做的就是把数据按照所需格式提取出来，进行转换、过滤、清洗。最终装载到数据仓库，整个过程也<strong>ETL</strong>。</p><ul><li><strong>提取 Extraction</strong>：表示从操作型数据库搜集指定数据。</li><li><strong>转换 Transformation</strong>：表示将数据转化为指定格式，并进行数据清洗保证数据质量。</li><li><strong>加载 Load</strong>：加载过程表示将转换过后满足指定格式的数据加载进数据仓库。</li></ul><p>随着数仓的不断普及跟使用，<strong>信息产业就开始从以关系型数据库为基础的运营式系统慢慢向决策支持系统发展。</strong>这个<strong>决策支持系统</strong>，其实就是我们现在说的<strong>商务智能（Business Intelligence），即BI</strong>。可以这么说，数据仓库为OLAP解决了数据来源问题，数据仓库和OLAP互相促进发展，进一步驱动了商务智能的成熟，但真正将商务智能赋予智能的，其实是数据挖掘。</p><h3 id="数仓特征"><a href="#数仓特征" class="headerlink" title="数仓特征"></a>数仓特征</h3><h4 id="面向主题"><a href="#面向主题" class="headerlink" title="面向主题"></a>面向主题</h4><p><strong>面向主题特性</strong>是数据仓库和操作型数据库的根本区别。</p><ol><li>操作型数据库是为了支撑各种业务而建立，是按照业务功能进行组织的。</li><li>分析型数据库则是为了对从各种繁杂业务中抽象出来的分析主题进行分析而建立。</li><li><font color="cornflowerblue">所谓主题是指用户使用数据仓库进行决策时所关心的重点方面</font>，如：收入、客户、销售渠道等。<strong>所谓面向主题，是指数据仓库内的信息是按主题进行组织的</strong>。</li></ol><h4 id="集成性"><a href="#集成性" class="headerlink" title="集成性"></a>集成性</h4><p>集成性指数据仓库中的信息不是从各个业务系统中简单抽取出来的，而是经过一系列加工、整理和汇总的过程，因此数据仓库中的信息是关于整个企业的一致的全局信息。</p><h4 id="企业范围"><a href="#企业范围" class="headerlink" title="企业范围"></a>企业范围</h4><p>数据仓库内的数据是面向公司全局的。比如：某个主题域为成本，则全公司和成本有关的信息都会被汇集进来。</p><h4 id="历史性"><a href="#历史性" class="headerlink" title="历史性"></a>历史性</h4><p>较之操作型数据库，数据仓库的时间跨度通常比较长。前者通常保存几个月，后者可能几年甚至几十年。</p><h4 id="时变性"><a href="#时变性" class="headerlink" title="时变性"></a>时变性</h4><p>时变性是指数据仓库包含来自其时间范围不同时间段的数据快照。有了这些数据快照以后，用户便可将其汇总，通过这些信息，可以对企业的发展历程和未来趋势做出定量分析和预测。</p><h3 id="数仓架构"><a href="#数仓架构" class="headerlink" title="数仓架构"></a>数仓架构</h3><p>数仓的整体建构图：</p><img src="dw2.png" style="zoom: 50%;"><h2 id="数仓分层架构"><a href="#数仓分层架构" class="headerlink" title="数仓分层架构"></a>数仓分层架构</h2><p>数仓分层并没有严格的固定格式，各个业务可以根据自身的业务架构和决策支持个性化数仓分层机构，常见的通用的数仓分层有三层架构和四层架构，如下：</p><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li><strong>数据运营层（ ODS ）</strong></li><li><strong>数据仓库层（DW）</strong><ul><li><strong>DWD：数据明细层：DWD（Data Warehouse Detail）</strong></li><li><strong>DWM：数据中间层：DWM（Data WareHouse Middle）</strong></li><li><strong>DWS：数据服务层：DWS（Data WareHouse Servce）</strong></li></ul></li><li><strong>数据应用层（APP）</strong></li></ul><p>如下图所示。简单来讲，我们可以理解为：ODS层存放的是接入的原始数据，DW层是存放我们要重点设计的数据仓库中间层数据，APP是面向业务定制的应用数据。</p><img src="dw6.png" style="zoom: 67%;"><h3 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h3><p>将三层架构中的DWD和DWS凸显出来并弱化DWM层就形成了四层架构，如下图：</p><img src="dw7.png" style="zoom: 25%;"><p>数据分层是数据仓库设计中一个十分重要的环节，良好的分层设计能够让整个数据体系更容易被理解和使用。</p><p><img src="dw3.png"></p><h3 id="图解数据分层"><a href="#图解数据分层" class="headerlink" title="图解数据分层"></a>图解数据分层</h3><img src="dw4.png" style="zoom: 33%;"><h3 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h3><p>数据仓库中涉及到的问题：</p><ol><li>为什么要做数据仓库？</li><li>为什么要做数据质量管理？</li><li>为什么要做元数据管理？</li><li>数仓分层中每个层的作用是什么？</li><li>……</li></ol><p>在实际的工作中，我们都希望自己的数据能够有顺序地流转，设计者和使用者能够清晰地知道数据的整个声明周期，比如下面左图。但是，实际情况下，我们所面临的数据状况很有可能是复杂性高、且层级混乱的，我们可能会做出一套表依赖结构混乱，且出现循环依赖的数据体系，比如下面的右图。</p><img src="dw5.png" style="zoom:80%;"><p>为了解决我们可能面临的问题，需要一套行之有效的数据组织、管理和处理方法，来让我们的数据体系更加有序，这就是<strong>数据分层</strong>。数据分层的好处：</p><ul><li>清晰数据结构：让每个数据层都有自己的作用和职责，在使用和维护的时候能够更方便和理解</li><li>复杂问题简化：将一个复杂的任务拆解成多个步骤来分步骤完成，每个层只解决特定的问题</li><li>统一数据口径：通过数据分层，提供统一的数据出口，统一输出口径</li><li>减少重复开发：规范数据分层，开发通用的中间层，可以极大地减少重复计算的工作</li></ul><h3 id="数据分层"><a href="#数据分层" class="headerlink" title="数据分层"></a>数据分层</h3><p>每个公司的业务都可以根据自己的业务需求分层不同的层次；目前比较流行的数据分层：数据运营层、数据仓库层、数据服务层。</p><h4 id="数据运营层ODS"><a href="#数据运营层ODS" class="headerlink" title="数据运营层ODS"></a>数据运营层ODS</h4><p>数据运营层：Operation Data Store 数据准备区，也称为贴源层。数据源中的数据，经过抽取、洗净、传输，也就是ETL过程之后进入本层。现在可选择的大数据同步技术也比较多，如：<strong>datax</strong>，<strong>canal</strong>，<strong>kafka</strong>等。这一层的主要目的是把源系统的数据基本原样（有些数据敏感等级高不同步）的同步到大数据平台，因此比较容易进行方案的统一。该层的主要功能：</p><ul><li>ODS是后面数据仓库层的准备区；</li><li>为DWD层提供原始数据；</li><li>减少对业务系统的影响；</li></ul><p>为了考虑后续可能需要追溯数据问题，因此对于这一层就不建议做过多的数据清洗工作，原封不动地接入原始数据即可，这层的数据是后续数据仓库加工数据的来源。数据来源的方式：</p><ol><li>业务库：sqoop定时抽取数据；实时方面考虑使用canal监听mysql的binlog日志，实时接入即可</li><li>埋点日志：日志一般是以文件的形式保存，可以选择使用flume来定时同步；可以使用spark streaming或者Flink、Kafka来实时接入</li><li>消息队列：来自ActiveMQ、Kafka的数据等</li></ol><h4 id="数据仓库层"><a href="#数据仓库层" class="headerlink" title="数据仓库层"></a>数据仓库层</h4><p> DW为数据仓库层，DW层的数据应该是一致的、准确的、干净的数据。主要有清洗，拆分，整合，标准化，备份，隔离几个任务。即对源系统数据进行清洗后的数据。这一层的数据一般是遵循数据库第三范式的，在DW层会保存BI系统中所有的历史数据，例如保存10年的数据。数据仓库层从上到下，又可以分为3个层：数据细节层DWD、数据中间层DWM、数据服务层DWS。</p><p><strong>数据细节层DWD，data warehouse details</strong></p><p>该层是业务层和数据仓库的隔离层，保持和ODS层一样的数据颗粒度；主要是对ODS数据层做一些数据的清洗和规范化的操作，比如去除空数据、脏数据、离群值等。</p><p>为了提高数据明细层的易用性，该层通常会才采用一些维度退化方法，将维度退化至事实表中，减少事实表和维表的关联。</p><p><strong>数据中间层DWM | Data Warehouse Middle</strong></p><p>该层是在DWD层的数据基础上，对数据做一些轻微的聚合操作，生成一些列的中间结果表，提升公共指标的复用性，减少重复加工的工作。</p><blockquote><p>简答来说，对通用的核心维度进行聚合操作，算出相应的统计指标。</p></blockquote><p><strong>数据服务层DWS | Data Warehouse Service</strong></p><p>该层是基于DWM上的基础数据，整合汇总成分析某一个主题域的数据服务层，一般是宽表，用于提供后续的业务查询，OLAP分析，数据分发等。一般来说，该层的数据表会相对较少；一张表会涵盖比较多的业务内容，由于其字段较多，因此一般也会称该层的表为<strong>宽表</strong>。</p><p><strong>数据应用层ADS | Application Data Service</strong></p><p>该层主要是提供给数据产品和数据分析使用的数据，一般会存放在ES、Redis、PostgreSql等系统中供线上系统使用；也可能存放在hive或者Druid中，供数据分析和数据挖掘使用，比如常用的数据报表就是存在这里的。</p><h3 id="事实表-Fact-Table"><a href="#事实表-Fact-Table" class="headerlink" title="事实表 Fact Table"></a>事实表 Fact Table</h3><p>事实表是指存储有事实记录的表，比如：系统日志、销售记录等。事实表的记录在不断地增长，比如电商的商品订单表，就是类似的情况，所以事实表的体积通常是远大于其他表。</p><h3 id="维表层Dimension-DIM"><a href="#维表层Dimension-DIM" class="headerlink" title="维表层Dimension | DIM"></a>维表层Dimension | DIM</h3><p>维度表（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联，相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。维度表主要是包含两个部分：</p><ul><li>高基数维度数据：一般是用户资料表、商品资料表类似的资料表，数据量可能是千万级或者上亿级别</li><li>低基数维度数据：一般是配置表，比如：枚举字段对应的中文含义，或者日期维表等；数据量可能就是个位数或者几千几万。</li></ul><p>常见的维度表有：日期表（存储与日期对应的周、月、季度等的属性）、地点表（包含国家、省／州、城市等属性）等。</p><p><font color="red"><strong>分层的核心思想就是解耦，再解耦，把复杂的问题简单化!</strong></font></p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.jianshu.com/p/5ac1a3a88c39">了解啥是数仓</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTMzMjE2NA==&mid=2247484463&idx=1&sn=5d2bfe658f07e9862ddf49fcc62365d7&chksm=9f736b04a804e212d4c1c8a7f3cafab4ca53dfad686f23d7dd96aecb003c8591d35884717169&scene=27">数据仓库系统架构和数仓分层体系介绍</a></p><p><a href="https://www.cnblogs.com/itboys/p/10592871.html">数据仓库–通用的数据仓库分层方法</a></p><p><a href="https://zhuanlan.zhihu.com/p/377978194">详解数据仓库分层</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数仓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析CAP理论&amp;Base理论</title>
      <link href="/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA/"/>
      <url>/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析CAP理论-amp-Base理论"><a href="#浅析CAP理论-amp-Base理论" class="headerlink" title="浅析CAP理论&amp;Base理论"></a>浅析CAP理论&amp;Base理论</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><strong>CAP理论是分布式应用的理论基础，虽然所有的分布式系统在设计时都会向其看齐，但事实上的所有分布式系统都不可能同时满足CAP三种特性：</strong></p><h3 id="一致性-C-Consistency"><a href="#一致性-C-Consistency" class="headerlink" title="一致性 [C: Consistency]"></a>一致性 [C: Consistency]</h3><p>在分布式环境中，一致性是指数据在多个副本（分布式节点）之间能否保持数据强一致的特性。在一致性的要求下，当一个系统在数据一致状态下执行更新操作后，应该保证系统的数据仍然处于一致状态。</p><h3 id="可用性-A-Available"><a href="#可用性-A-Available" class="headerlink" title="可用性 [A: Available]"></a>可用性 [A: Available]</h3><p>可用性是指系统提供的服务必须一直处于可用的状态，对用户的每一个请求操作总是能够在有限时间内返回结果。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p><h3 id="分区容错性-P-Partition-Tolerance"><a href="#分区容错性-P-Partition-Tolerance" class="headerlink" title="分区容错性 [P: Partition Tolerance]"></a>分区容错性 [P: Partition Tolerance]</h3><p>分布式系统在遇到任何网络分区故障的时候，仍然能够保证对外提供满足一致性或者可用性的服务，除非是整个网络环境都发生了故障。分区容错性要求应用虽然是一个分布式系统，但看上去是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p><p>这三个基本需求，任何一个分布式系统最多只能同时满足其中的两项，其中<strong>P是必须的，所以往往选择实现CP或者AP。</strong></p><p>此处的一致性表示实时的强一致性，而不是最终一致性；例如：Redis的主从集群只能保持最终一致性，在发生网络分区时，主从同步的过程中会出现数据不一致的场景，但是等网络恢复之后，从节点会进行一系列操作去追赶主节点的数据变更，数据最终会达到数据一致性，在此期间Redis集群整体依然能够提供服务（可用性），所以，<strong>Redi主从集群是AP！</strong></p><p>Zookeeper集群是数据强一致性的，如果发生网络分区，Zookeeper集群针对写请求（事务请求）无法完成半数机制场景下，Zookeeper集群是不可用的（即无法保证可用性），所以，<strong>Zookeeper集群是CP！</strong></p><blockquote><p><strong>Zookeeper不可用场景：</strong></p><ul><li>Zookeeper不能保证每次服务请求的可用性。(在极端环境下，Zookeeper可能会丢失一些请求，消费者程序需要重新请求才能获取结果)，所以说Zookeeper不能保证服务的持续可用性；</li><li>进行Leader选举时，整个集群都是不可用的。</li></ul></blockquote><h3 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h3><p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p><img src="image1.png" style="zoom: 25%;"><blockquote><p>图中指示Redis是CP是针对单机而言的 – Redis单机是CP，Redis主从集群是AP。</p></blockquote><p><strong>CA without P</strong>：如果不要求P（不允许网络分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。也就是节点应用。</p><p><strong>CP without A</strong>：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统，在此期间集群整体是不可用的。</p><p><strong>AP wihtout C</strong>：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p><p>根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul><h1 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h1><p>BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。接下来看一下BASE中的三要素：</p><h3 id="基本可用-Basically-Available"><a href="#基本可用-Basically-Available" class="headerlink" title="基本可用 | Basically Available"></a>基本可用 | Basically Available</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性 — 注意，这绝不等价于系统不可用。比如：</p><p>（1）响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；</p><p>（2）系统功能上的损失。正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；</p><h3 id="软状态-Soft-state"><a href="#软状态-Soft-state" class="headerlink" title="软状态 | Soft state"></a>软状态 | Soft state</h3><p>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；</p><h3 id="最终一致性-Eventually-consistent"><a href="#最终一致性-Eventually-consistent" class="headerlink" title="最终一致性 | Eventually consistent"></a>最终一致性 | Eventually consistent</h3><p>最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于分布式系统的项目，使用中没有强制要求一定是CAP中要达到某几种，具体根据各自业务场景所需来制定相应的策略而选择适合的产品服务等。例如：支付订单场景中，由于分布式本身就在数据一致性上面很难保证，从A服务到B服务的订单数据有可能由于服务宕机或其他原因而造成数据不一致性。因此此类场景会酌情考虑：AP，不强制保证数据一致性，但保证数据最终一致性。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
            <tag> Base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Cloud-2-2」-- Eureka内部机制及源码分析</title>
      <link href="/2023/05/16/Spring-Cloud-2-2-Eureka%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/16/Spring-Cloud-2-2-Eureka%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka-内部机制及源码分析"><a href="#Eureka-内部机制及源码分析" class="headerlink" title="Eureka 内部机制及源码分析"></a>Eureka 内部机制及源码分析</h1><h2 id="Eureka-运作原理"><a href="#Eureka-运作原理" class="headerlink" title="Eureka 运作原理"></a>Eureka 运作原理</h2><p>Eureka-server 对外提供的是 restful 风格的服务，以http动词的形式对url资源进行操作：<code>get</code>、 <code>post</code>、 <code>put</code>、 <code>delete</code>，只要利用这些restful接口我们就能对项目实现注册和发现，只不过eureka已经帮我们使用java语言封装好了client端的代码，让开发者只需要在项目中依赖Eureka Client就能实现注册和发现。</p><p><strong>只要能发起 Http 请求，那就可以向Eureka Server进行服务注册和发现，不管是什么语言。</strong></p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>当Eureka Client项目启动时，就会向Eureka Server发送自己的元数据（原始数据），如：运行的 ip、端口 port、健康的状态监控等。使用的是HTTP/ResuFul 请求风格。Eureka Server会在自己内部保留这些元数据（JVM内存中），形成一个服务列表。注册过程中为避免网络问题，会尝试3次。Eureka提供的是ResutFul风格的HTTP请求，Eureka封装的Java客户端底层使用的是<a href="https://baike.baidu.com/item/Jersey/17577306?fr=aladdin">Jersey框架</a>进行HTTP请求。</p><h4 id="注册调用链路"><a href="#注册调用链路" class="headerlink" title="注册调用链路"></a>注册调用链路</h4><img src="eureka6.png" style="zoom:90%;"><h4 id="核心类-com-netflix-discovery-DiscoveryClient"><a href="#核心类-com-netflix-discovery-DiscoveryClient" class="headerlink" title="核心类 com.netflix.discovery.DiscoveryClient"></a>核心类 com.netflix.discovery.DiscoveryClient</h4><p><strong>注册方法 | com.netflix.discovery.DiscoveryClient#register( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register with the eureka service by making the appropriate REST call.</span></span><br><span class="line"><span class="comment">   * Eureka Client注册方法入口.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  logger.info(PREFIX + <span class="string">&quot;&#123;&#125;: registering service...&quot;</span>, appPathIdentifier);</span><br><span class="line">  EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Eureka Client向目标URL进行注册，其实就是将实例的具体信息发送至Eureka Server端</span></span><br><span class="line">    httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.warn(PREFIX + <span class="string">&quot;&#123;&#125; - registration failed &#123;&#125;&quot;</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(PREFIX + <span class="string">&quot;&#123;&#125; - registration status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重试封装层 | com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient#execute()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;R&gt; EurekaHttpResponse&lt;R&gt; <span class="title function_">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> &#123;</span><br><span class="line">  List&lt;EurekaEndpoint&gt; candidateHosts = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">endpointIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123; <span class="comment">// numberOfRetries固定值，默认为3次，当注册失败时会自动尝试3次</span></span><br><span class="line">    <span class="type">EurekaHttpClient</span> <span class="variable">currentHttpClient</span> <span class="operator">=</span> delegate.get();</span><br><span class="line">    <span class="type">EurekaEndpoint</span> <span class="variable">currentEndpoint</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (currentHttpClient == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (candidateHosts == <span class="literal">null</span>) &#123;</span><br><span class="line">        candidateHosts = getHostCandidates();</span><br><span class="line">        <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransportException</span>(<span class="string">&quot;There is no known eureka server; cluster server list is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransportException</span>(<span class="string">&quot;Cannot execute request on any known server&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      currentEndpoint = candidateHosts.get(endpointIdx++);</span><br><span class="line">      currentHttpClient = clientFactory.newClient(currentEndpoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 注册</span></span><br><span class="line">      EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</span><br><span class="line">      <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</span><br><span class="line">        delegate.set(currentHttpClient);</span><br><span class="line">        <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Request execution succeeded on retry #&#123;&#125;&quot;</span>, retry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      logger.warn(<span class="string">&quot;Request execution failure with status code &#123;&#125;; retrying on another server if available&quot;</span>, response.getStatusCode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Request execution failed with message: &#123;&#125;&quot;</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></span><br><span class="line">    delegate.compareAndSet(currentHttpClient, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (currentEndpoint != <span class="literal">null</span>) &#123;</span><br><span class="line">      quarantineSet.add(currentEndpoint);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransportException</span>(<span class="string">&quot;Retry limit reached; giving up on completing the request&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Jersey封装层 | com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient#register</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title function_">register</span><span class="params">(InstanceInfo info)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">urlPath</span> <span class="operator">=</span> <span class="string">&quot;apps/&quot;</span> + info.getAppName();</span><br><span class="line">  <span class="type">ClientResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 底层使用Jersey框架进行RestFul风格的HTTP请求 | serviceUrl为目标Eureka Server的地址</span></span><br><span class="line">    <span class="type">Builder</span> <span class="variable">resourceBuilder</span> <span class="operator">=</span> jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br><span class="line">    addExtraHeaders(resourceBuilder);</span><br><span class="line">    response = resourceBuilder</span><br><span class="line">      .header(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>) <span class="comment">// 压缩</span></span><br><span class="line">      .type(MediaType.APPLICATION_JSON_TYPE) <span class="comment">// json格式</span></span><br><span class="line">      .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">      .post(ClientResponse.class, info); <span class="comment">// POST请求</span></span><br><span class="line">    <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Jersey HTTP POST &#123;&#125;&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;&quot;</span>, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                   response == <span class="literal">null</span> ? <span class="string">&quot;N/A&quot;</span> : response.getStatus());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">      response.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Eureka Client启动的时候，会向我们指定的 <code>serviceUrl</code> 发送请求，把自己节点的数据用json格式以post 请求的方式发送过到Eureka Server端。当返回的状态码为 <code>204</code> 的时候，表示注册成功。</p><h3 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h3><p>项目Eureka Client启动成功了，除了向Eureka Server注册自己成功，还会定时的向Eureka Server发送心跳请求，表示自己还活着。</p><h3 id="服务下线-主动下线"><a href="#服务下线-主动下线" class="headerlink" title="服务下线 | 主动下线"></a>服务下线 | 主动下线</h3><p>当项目关闭时，会给 eureka-server 报告，说明自己要下机了。</p><h3 id="服务剔除-主动剔除、被动下线"><a href="#服务剔除-主动剔除、被动下线" class="headerlink" title="服务剔除 | 主动剔除、被动下线"></a>服务剔除 | 主动剔除、被动下线</h3><p>当项目超过了指定时间没有向 eureka-server 汇报自己，那么 eureka-server 就会认为此节点死掉了，会把它剔除掉，也不会放流量和请求到此节点了。</p><p>注册中心有一个容器保留各个注册的服务的信息：IP、端口号、续约时间、健康状态等等。</p><p>注册中心有一个剔除机制（定时删除下线的客户端）。</p><p>客户端可以设置续约时间（心跳）。</p><p>客户端可以从注册中心的拉取一份服务列表信息缓存到本地，但是会有脏读问题。</p><p>客户端可以设置拉取服务列表的时间间隔，时间间隔越短，脏读问题出现的概率越小，但是对客户端性能会有影响。</p><h3 id="Eureka保护机制"><a href="#Eureka保护机制" class="headerlink" title="Eureka保护机制"></a>Eureka保护机制</h3><p>正常情况下Eureka Server接收心跳失败的比率在15分钟之内，低于85%的节点，Eureka server会认为这个实例出现了网络故障，直接删除这个有问题的服务。这样在网络抖动和网络不稳定的情况下就会出现误删除有效的Eureka Client。Eureka Server保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。为了防止Eureka Client可以正常运行，但是与Eureka Server网络不畅通情况下（网络延迟等原因），在保护模式开启的情况下，Eureka Server不会立刻将Eureka Client服务剔除，以避免误删除。</p><p>Eureka保护机制的核心就是AP！</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="comment"># server配置,eureka-server既是服务端又是客户端,也就是说,它不仅可以提供客户端注册,同时本身也可以注册到其他server上.</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">10000</span> <span class="comment"># 服务端定时剔除下线的实例信息的间隔时间/ms</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment"># 续约百分比,超过85%的应用没有发送心跳续约,那么eureka会保护服务,不会剔除任何一个实例(eureka会认为是自己的网络问题,AP)</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span> <span class="comment"># Eureka Server的自我保护机制,避免因为网络原因造成误删除,生产环境建议打开</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">instance:</span> <span class="comment"># instance实例配置</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="comment"># 实例ID名称: 主机名:应用名:端口号</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># 主机名称或者服务节点IP</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 服务列表以IP形式展示</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 服务实例的心跳续约时间间隔,需要比上面的eviction-interval-timer-in-ms配置值小</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">20</span> <span class="comment"># Eureka Server至上一次收到Eureka Client心跳之后,等待下一次心跳的超时时间,这个时间内若没有收到下一次心跳,就剔除该客户端实例.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 指定注册中心的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVER_URL:http://localhost:8761/eureka&#125;</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="string">$&#123;REGISTER_WITH_EUREKA:false&#125;</span> <span class="comment"># 先将server自己注册自己关掉|默认是开启的(集群模式需要开启,单机一般关闭)</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 应用是否去拉取服务列表到本地</span></span><br></pre></td></tr></table></figure><h4 id="保护流程"><a href="#保护流程" class="headerlink" title="保护流程"></a>保护流程</h4><ol><li>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比（这个15分钟是在源码当中有个每15分钟执行一次的定时任务），如果低于85%就会触发自我保护机制。</li><li>触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期，但这些服务也并不是永远不会过期（该现象可能出现在如果网络不通但是EurekaClient未出现岩机）。</li><li>Eureka在启动完成后，每隔60秒会检查一次服务健康状态（这个10秒就是上面提到的Eureka Server查看心跳是否收到默认的配置：eviction-interval-timer-in-ms）</li><li>如果这些被保护起来失效的服务过一段时间后（默认90秒，这个20秒就是上面提到的心跳最大等待时间：lease-expiration-duration-in-seconds）还是没有恢复，就会把这些服务剔除。如果在此期间服务恢复了并且实例心跳占比高于85%时，就会自动关闭自我保护机制。</li></ol><p>如果换做别的注册中心，如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是网络延迟问题，而保护机制是为了解决此问题而产生的。</p><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://blog.csdn.net/qq_43170213/article/details/115049535">Spring Cloud Eureka</a></li><li><a href="https://blog.csdn.net/weixin_43888891/article/details/125325794">什么是Eureka？</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Cloud-2-1」-- Eureka Quick Start</title>
      <link href="/2023/05/16/Spring%20Cloud2-Eureka/"/>
      <url>/2023/05/16/Spring%20Cloud2-Eureka/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h1><p>Eureka是服务注册发现中心。Eureka 来源于古希腊词汇，意为“发现了”。在软件领域， Eureka是Netflix公司开源的一个<strong>服务注册与发现</strong>的组件，和Netflix公司其它的一些服务组件(例如：负载均衡、 熔断器、网关等) 一起被Spring Cloud社区整合为Spring Cloud Netflix模块。 Eureka是Netflix贡献给Spring Cloud的一个开源框架。</p><p>同为注册中心，相比动物管理员Zookeeper，Spring Cloud Eureka有什么区别呢？</p><p><strong><font color="green">核心点在于分布式微服务中的CAP定理！</font></strong></p><blockquote><p><strong>问：为什么 Zookeeper 不适合做注册中心?</strong></p><p>Zookeeper 注重数据的一致性，Eureka 则侧重服务的可用性。</p><ul><li>在 Zookeeper中，若Leader挂了，则Zookeeper集群整体不对外提供服务了，直到重新选举出一个新的Leader出来(选举时间大约120s 左右)，才能继续对外提供服务。</li><li>Eureka注重服务的可用性，当Eureka集群只要有一台活着，它就能对外提供服务。</li></ul><p><strong>Zookeeper是CP，而Eureka是AP</strong>，</p><p>CAP理论相关请见博文：<a href="/maple/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA">浅析CAP理论&amp;Base理论</a> </p></blockquote><h2 id="Eureka-Quick-Start-Demo"><a href="#Eureka-Quick-Start-Demo" class="headerlink" title="Eureka Quick Start Demo"></a>Eureka Quick Start Demo</h2><h3 id="单Eureka-Server"><a href="#单Eureka-Server" class="headerlink" title="单Eureka Server"></a>单Eureka Server</h3><p>设计一个Eureka的快速开始Demo，结果如下图所示：</p><img src="eureka1.png" style="zoom: 33%;"><p>Eureka Server作为服务注册中心，向所有Eureka Client提供服务注册的能力（Eureka Server自身具备Eureka Client一样的注册能力，单机部署Eureka Server时体现不出来，集群模式部署Eureka Server的时候就体现出来了，因为各个Eureka Server相互之间也是需要进行注册），所有注册的Eureka Client都可以和Eureka Server进行通信，请求获取注册到Eureka Server上的Eureka Client的服务列表，这就是服务发现。</p><p>在实际开发中，如果使用Eureka进行服务治理，一般都是单独创建一个Eureka Server应用作为服务注册中心独立部署。不过由于Eureka版本的停更，同时其他注册中心组件Nacos、Consul等出现，可能项目开发中使用Eureka的场景越来越少了，但有些旧的微服务代码中还是有Eureka的痕迹，可以作为学习了解的对象。</p><blockquote><p>Eureka Demo地址：<a href="https://gitee.com/maple_eitba/maple-springcloud/tree/master/maple-eureka">Eureka Quick Start Demo</a></p></blockquote><h4 id="Eureka的UI"><a href="#Eureka的UI" class="headerlink" title="Eureka的UI"></a>Eureka的UI</h4><p>代码运行执行，访问：<code>http://localhost:8761/</code>，如下图：</p><img src="eureka2.png" style="zoom: 50%;"><p>其中：</p><p>Status表示服务节点的状态：</p><ul><li><strong>UP</strong>: 服务是上线的，括号里面是具体服务实例的个数，提供服务的最小单元 ；</li><li><strong>DOWN</strong>: 服务是下线的；</li><li><strong>UN_KONW</strong>: 服务的状态未知；</li></ul><h4 id="Eureka-Server的配置"><a href="#Eureka-Server的配置" class="headerlink" title="Eureka Server的配置"></a>Eureka Server的配置</h4><p>常用的配置项如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="comment"># 如果Eureka的client配置中没有指定注册中心的地址service-url,并且自己注册自己配置没有关闭,那么应用的端口号就必须设置为8761,否则Eureka</span></span><br><span class="line"><span class="comment"># 启动之后会抛出异常,并且无法成功注册到Eureka Server上.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server-1</span>  <span class="comment"># 应用名称,不要使用特殊字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka的配置分为三类: server配置, client配置, instance实例配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span> <span class="comment"># server配置,eureka-server既是服务端又是客户端,也就是说,它不仅可以提供客户端注册,同时本身也可以注册到其他server上.</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">10000</span> <span class="comment"># 服务端定时剔除下线的实例信息的间隔时间/ms</span></span><br><span class="line">    <span class="attr">renewal-percent-threshold:</span> <span class="number">0.85</span> <span class="comment"># 续约百分比,超过85%的应用没有发送心跳续约,那么eureka会保护服务,不会剔除任何一个实例(eureka会认为是自己的网络问题,AP)</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span> <span class="comment"># Eureka Server的自我保护机制,避免因为网络原因造成误删除,生产环境建议打开</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">instance:</span> <span class="comment"># instance实例配置</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">$&#123;eureka.instance.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="comment"># 实例ID名称: 主机名:应用名:端口号</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># 主机名称或者服务节点IP</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 服务列表以IP形式展示</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">5</span> <span class="comment"># 服务实例的心跳续约时间间隔,需要比上面的eviction-interval-timer-in-ms配置值小</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">20</span> <span class="comment"># Eureka Server至上一次收到Eureka Client心跳之后,等待下一次心跳的超时时间,这个时间内若没有收到下一次心跳,就剔除该客户端实例.</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># 指定注册中心的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">$&#123;EUREKA_SERVER_URL:http://localhost:8761/eureka&#125;</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="string">$&#123;REGISTER_WITH_EUREKA:false&#125;</span> <span class="comment"># 先将server自己注册自己关掉|默认是开启的(集群模式需要开启,单机一般关闭)</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span> <span class="comment"># 应用是否去拉取服务列表到本地</span></span><br></pre></td></tr></table></figure><p>关于端口port的配置需要注意，如果Eureka的client配置中没有指定注册中心的地址service-url，并且自己注册自己配置没有关闭，那么应用的端口号就必须设置为8761，否则Eureka启动之后会抛出异常，并且无法成功注册到Eureka Server上。异常信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">2023-05-16 18:13:00.233  INFO 54488 --- [extShutdownHook] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application EUREKA-SERVER-1 with eureka with status DOWN</span><br><span class="line">2023-05-16 18:13:00.233  INFO 54488 --- [extShutdownHook] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1684231980233, current=DOWN, previous=UP]</span><br><span class="line">2023-05-16 18:13:00.234  INFO 54488 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_EUREKA-SERVER-1/localhost:eureka-server-1:8762: registering service...</span><br><span class="line">2023-05-16 18:13:00.235  INFO 54488 --- [nfoReplicator-0] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint&#123; serviceUrl=&#x27;http://localhost:8761/eureka/&#125;, exception=java.net.ConnectException: Connection refused (Connection refused) stacktrace=com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:187)</span><br><span class="line">at com.sun.jersey.api.client.filter.GZIPContentEncodingFilter.handle(GZIPContentEncodingFilter.java:123)</span><br><span class="line">at com.netflix.discovery.EurekaIdentityHeaderFilter.handle(EurekaIdentityHeaderFilter.java:27)</span><br><span class="line">at com.sun.jersey.api.client.Client.handle(Client.java:652)</span><br><span class="line">at com.sun.jersey.api.client.WebResource.handle(WebResource.java:682)</span><br><span class="line">at com.sun.jersey.api.client.WebResource.access$200(WebResource.java:74)</span><br><span class="line">at com.sun.jersey.api.client.WebResource$Builder.post(WebResource.java:570)</span><br><span class="line">at com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient.register(AbstractJerseyEurekaHttpClient.java:57)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient.execute(MetricsCollectingEurekaHttpClient.java:73)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56)</span><br><span class="line">at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:876)</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121)</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101)</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">at org.apache.http.conn.scheme.PlainSocketFactory.connectSocket(PlainSocketFactory.java:121)</span><br><span class="line">at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:180)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:144)</span><br><span class="line">at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:134)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:605)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:440)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:835)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:118)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)</span><br><span class="line">at com.sun.jersey.client.apache4.ApacheHttpClient4Handler.handle(ApacheHttpClient4Handler.java:173)</span><br><span class="line">... 30 more</span><br><span class="line"></span><br><span class="line">2023-05-16 18:13:00.235  WARN 54488 --- [nfoReplicator-0] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: java.net.ConnectException: Connection refused (Connection refused)</span><br><span class="line">2023-05-16 18:13:00.236  WARN 54488 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_EUREKA-SERVER-1/localhost:eureka-server-1:8762 - registration failed Cannot execute request on any known server</span><br><span class="line"></span><br><span class="line">com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:876) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121) [eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101) [eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]</span><br><span class="line"></span><br><span class="line">2023-05-16 18:13:00.236  WARN 54488 --- [nfoReplicator-0] c.n.discovery.InstanceInfoReplicator     : There was a problem with the instance info replicator</span><br><span class="line"></span><br><span class="line">com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$1.execute(EurekaHttpClientDecorator.java:59) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.register(EurekaHttpClientDecorator.java:56) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.DiscoveryClient.register(DiscoveryClient.java:876) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator.run(InstanceInfoReplicator.java:121) ~[eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at com.netflix.discovery.InstanceInfoReplicator$1.run(InstanceInfoReplicator.java:101) [eureka-client-1.10.14.jar:1.10.14]</span><br><span class="line">at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_201]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_201]</span><br><span class="line">at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]</span><br></pre></td></tr></table></figure><p><strong>原因分析：</strong></p><p>因为Eureka Server中如果没有配置注册中心的地址，并且Eureka Server会注册的本身时，Eureka Sever在启动之后就会使用源码中默认的硬编码写的URL地址为：<code>http://localhost:8761</code>，尝试对本身进行注册。从上述异常中的代码调用链中追溯可以找到源码中默认配置类为：</p><p><code>org.springframework.cloud.netflix.eureka.EurekaClientConfigBean。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default Eureka URL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8761&quot;</span> + DEFAULT_PREFIX+ <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default availability zone if none is resolved based on region.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_ZONE</span> <span class="operator">=</span> <span class="string">&quot;defaultZone&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// serviceUrl初始化时会放入默认的Map集合：</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; serviceUrl = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();&#123;</span><br><span class="line">  <span class="built_in">this</span>.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法就是配置文件中的，eureka:client:service-url配置项，如果没有配置，其中就只有默认的URL，</span></span><br><span class="line"><span class="comment">// Eureka Server注册自身的时候就会向http://localhost:8761发送注册请求，如果端口号不是8761，</span></span><br><span class="line"><span class="comment">// 就会抛出上述异常信息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setServiceUrl</span><span class="params">(Map&lt;String, String&gt; serviceUrl)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.serviceUrl = serviceUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集群Eureka-Server"><a href="#集群Eureka-Server" class="headerlink" title="集群Eureka Server"></a>集群Eureka Server</h3><p><strong>集群Demo架构图</strong></p><img src="eureka3.png" style="zoom:50%;"><blockquote><p>Eureka Demo地址：<a href="https://gitee.com/maple_eitba/maple-springcloud/tree/master/maple-eureka">Eureka Quick Start Demo</a></p><p>在本地部署Eureka Server集群时需要注意，如果所有的Eureka Server的IP都是本机，Eureka会认为只是同一个服务启动了多台，其间并没有数据交互，不是集群，需要修改操作系统的配置文件自定义IP地址别名，然后在Eureka Server配置文件中利用别名以示区分即可。</p></blockquote><p>Eureka Server集群是去中心化设计，没有主从的概念，所有的节点都是对等的，每个节点互相注册，只要集群中各有一个节点存活，就能对外提供服务注册和服务发现能力，保证服务的可用性。</p><blockquote><p>Eureka是AP，没有主从，<font color="red"><strong>一旦有主从就会涉及到主从的选举，同步会造成一定的时间内不可用。</strong></font></p></blockquote><p><strong>Eureka Server集群内部数据流图：</strong></p><img src="eureka4.png" style="zoom: 67%;"><hr><p><strong>参考文档：</strong></p><ul><li><a href="https://blog.csdn.net/qq_43170213/article/details/115049535">Spring Cloud Eureka</a></li><li><a href="https://blog.csdn.net/weixin_43888891/article/details/125325794">什么是Eureka？</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Cloud - 1」-- 浅析分布式架构和微服务架构</title>
      <link href="/2023/05/16/Spring%20Cloud1-%E5%88%86%E5%B8%83%E5%BC%8Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/05/16/Spring%20Cloud1-%E5%88%86%E5%B8%83%E5%BC%8Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析分布式架构和微服务架构"><a href="#浅析分布式架构和微服务架构" class="headerlink" title="浅析分布式架构和微服务架构"></a>浅析分布式架构和微服务架构</h1><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p>在《分布式系统原理与范型》一书中有如下定义：</p><blockquote><p>“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p></blockquote><p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储等任务。其目的是利用更多的机器，处理更多的数据。</p><p><strong>分布式系统（distributed system）是建立在网络之上的软件系统。</strong></p><p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、提升CPU核数）无法明显改善时，应用程序也无法进一步优化的场景，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。</p><p>因此，随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不紊的演进。</p><blockquote><p>分布式的典型代表：Dubbo。当然了，Dubbo现在也提供了微服务的生态。</p></blockquote><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>任何技术的演进都是有迹可循的，任何新技术的出现都是为了解决原有技术无法解决的需求，所以，微服务的出现就是因为原来单体应用架构已经无法满足当前互联网产品的技术需求。微服务的设计就是为了解决不因为某个模块的升级和BUG影响整体的系统业务。</p><p><strong>微服务架构，核心就是为了解决应用微服务化之后的服务治理问题。</strong></p><p>在微服务架构之前还有一个概念：SOA（Service-Oriented Architecture）– 面向服务的体系架构。</p><p>微服务的特征：</p><p>单一职责的。一个微服务应该都是单一职责的，这才是“微”的体现，一个微服务解决一个业务问题（注意是一个业务问题而不是一个接口）。<br>面向服务的。将自己的业务能力封装并对外提供服务，这是继承SOA的核心思想，一个微服务本身也可能使用到其它微服务的能力。</p><p>应用微服务化之后，会出现一些问题：</p><ul><li>服务发现问题。一个微服务如何发现其他微服务呢？最简单的方式就是每个微服务里面配置其他微服务的地址，但是当微服务数量众多的时候，这样做明显不现实。所以需要使用到微服务架构中的一个最重要的组件：服务注册中心，所有服务都注册到服务注册中心，同时利用服务发现机制可以从服务注册中心获取当前可用的服务清单。</li><li>服务配置管理的问题。当服务数量超过一定程度之后，如果需要在每个服务里面分别维护每一个服务的配置文件，运维人员估计要哭了。那么，就需要用到微服务架构里面第二个重要的组件：配置中心。</li><li>服务治理问题，当客户端或外部应用调用服务的时候怎么处理呢？服务A可能有多个节点，服务A、服务B和服务C的服务地址都不同，服务授权验证在哪里做？这时，就需要使用到服务网关提供统一的服务入口，最终形成典型微服务架构：</li></ul><img src="springcloud1.png" style="zoom:67%;"><p>这便是一个典型的微服务架构，当然微服务的服务治理还涉及很多内容，比如：</p><ul><li>通过熔断、限流等机制保证高可用；</li><li>微服务之间调用的负载均衡；</li><li>分布式事务（2PC、3PC、TCC、LCN等）；</li><li>服务调用链跟踪等等。</li></ul><p><font color="red"><strong>服务治理主要作用是改变运行时服务的行为和选址逻辑、限流熔断、负载权重、配置读写、日志追踪等目的。</strong></font></p><h2 id="分布式和微服务的区别"><a href="#分布式和微服务的区别" class="headerlink" title="分布式和微服务的区别"></a>分布式和微服务的区别</h2><p>分布式和微服的架构很相似，只是部署的方式不一样而已。分布式服务架构与微服务架构概念的区别与联系：</p><h3 id="分布式-–-分散压力"><a href="#分布式-–-分散压力" class="headerlink" title="分布式 – 分散压力"></a>分布式 – 分散压力</h3><ul><li>不同模块部署在不同服务器上;<ul><li>作用：分布式解决网站高并发带来性能问题；</li></ul></li><li>集群：相同的服务；<ul><li>多台服务器部署相同应用构成一个集群；</li><li>作用：通过负载均衡设备共同对外提供服务；</li></ul></li><li>SOA［组装服务/ESB企业服务总线］;<ul><li>业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力;</li><li>通过服务的组合和编排来实现上层的业务流程;</li><li>作用：简化维护，降低整体风险，伸缩灵活;</li></ul></li></ul><h3 id="微服务-–-分散能力"><a href="#微服务-–-分散能力" class="headerlink" title="微服务 – 分散能力"></a>微服务 – 分散能力</h3><ul><li>架构设计概念：各服务间隔离（分布式也是隔离），自治（分布式依赖整体组合），其它特性（单一职责，边界，异步通信，独立部署），是分布式概念更加严格的执行;</li><li>作用：各服务可独立应用，组合服务也可系统应用（巨石应用［monolith］的简化实现策略 – 平台思想）.</li></ul><blockquote><p>将所有功能都部署在一个web容器中运行的系统就叫做<strong>巨石应用</strong>。</p></blockquote><p><font color="red"><strong>核心：分布式重在资源共享与加快计算机计算速度。 分布式:分散压力。微服务:分散能力。</strong></font></p><blockquote><p><strong>问题：分布式是否属于微服务？</strong></p><p>关于这个问题，搜罗了蛮多博文，答案也不完全一致，有属于也有不属于。</p><p>个人理解：如果不对微服务的’微’字太较真，或者分布式节点上部署的应用业务粒度足够小，那可以认为分布式属于微服务。</p><p>但是反过来就不成立了。因为微服务就是将业务模块拆分成一个独立的服务单元，然后基于网络通信通过接口来实现数据的交互，微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，它可以是同一个服务器。这也是分布式和微服务的一个细微差别。</p></blockquote><h2 id="微服务架构的理解"><a href="#微服务架构的理解" class="headerlink" title="微服务架构的理解"></a>微服务架构的理解</h2><p>在应用的初始阶段，单体架构无论是在开发速度、运维难度上，还是服务器的成本上都有着显著的优势。在一个产品的前景不明确的初始阶段，使用单体架构是非常明智的选择。随着应用业务的发展和业务复杂度的提高，这种架构明显存在很多的不足，主要体现在以下 3 个方面: </p><ol><li>业务越来越复杂，单体应用的代码量越来越大，代码的可读性、可维护性和可扩展性下降， 新人接手代码所需的时间成倍增加，业务扩展带来的代价越来越大。</li><li>随着用户越来越多，程序承受的并发越来越高，单体应用的并发能力有限。</li><li>测试的难度越来越大，单体应用的业务都在同个程序中，随着业务的扩张、复杂度的增加， 单体应用修改业务或者增加业务或许会给其他业务带来定的影响，导致测试难度增加。</li></ol><p>微服务（不是一个框架 而是一种架构思想），是著名的 oo （面向对象， Object Oriented ）专家 Martin Fowler 提出来的，它是用来描述将软件应用程序设计为独立部署的服务的种特殊方式。微服务架将业务整体构按领域划分为独立的服务单元，有自动化运维、容错、快速演进的特点，它能够解决传统单体架构系统的痛点，同时也能满足越来越复杂的业务需求。</p><blockquote><p>Martin Fowler 对微服务的理解：</p><p>简而言之，微服务架构的风格，就是将单一程序开发成一个微服务， 每个微服务运行在自己的进程中，并使用轻量级通信机制，通常是 HTTP RESTFUL API 。这些服务围绕业务能力来划分构建的，并通过完全自动化部署机制来独立部署这些服务可以使用不同的编程语言，以及不同数据存储技术，以保证最低限度的集中式管理。</p></blockquote><h2 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h2><h3 id="微服务单元基于业务划分"><a href="#微服务单元基于业务划分" class="headerlink" title="微服务单元基于业务划分"></a>微服务单元基于业务划分</h3><p>微服务的“微”到底需要定义到什么样的程度，这是个非常难以界定的概念，可以从几个方面来界定: </p><ul><li>是根据代码量来定义，根据代码的多少来判断程序的大小: </li><li>是根据开发时间的长短来判断；</li><li>是根据业务粒度的大小来划分；</li></ul><p>根据 Martin Fowler 的定义，<strong>微服务的“微”是按照业务来划分的</strong> 。一个大的业务可以拆分成若干小的业务， 小的业务又可以拆分成若干更小的业务，业务到底怎么拆分才算合适，这需要开发人员根据领域划分和职责划分自己去决定。</p><h3 id="微服务基于HTTP协议进行通信"><a href="#微服务基于HTTP协议进行通信" class="headerlink" title="微服务基于HTTP协议进行通信"></a>微服务基于HTTP协议进行通信</h3><p>按照业务划分的微服务单元独立部署并运行在各自的进程中。微服务单元之间的通信方般倾向于使用 HTTP 这种简单的通信机制，更多的时候是使用 RESTfulAPI 。这种接受请求、处理业务逻辑、返回数据的 HTTP 模式非常高效，并且这种通机制与平台和语言无关。</p><h3 id="微服务的数据库独立"><a href="#微服务的数据库独立" class="headerlink" title="微服务的数据库独立"></a>微服务的数据库独立</h3><p>在单体架构中，所有的业务都共用一个数据库。随着业务量的增加，数据库的表的数量越来越多，难以管理和维护，并且数据量的增加会导致数据库服务器压力越来越大，查询速度越来越慢。 微服务的特点就是按业务划分服务，服务与服务之间无耦合，就数据库也是独立的，典型的微服务架构就是每个微服务都有自己独立的数据库，数据库之间没有何联系，这样做的好处在于随着业务的不断扩张，服务与服务之间不需要提供数据库集成，而是提供 API 接口相互调用，还有个好处是数据库独立，单业务的数据量少，易于维护，数据库性能有着明显的优势，数据库的迁移也很方便。</p><h3 id="微服务的自动化部署-CI-CD-持续集成-持续交付"><a href="#微服务的自动化部署-CI-CD-持续集成-持续交付" class="headerlink" title="微服务的自动化部署(CI /CD)(持续集成 持续交付)"></a>微服务的自动化部署(CI /CD)(持续集成 持续交付)</h3><p>在微服务架构中，系统会被拆分为若干个微服务，每个微服务又是一个独立的应用程序。单体架构的应用程序只需要部署一次，而微服务架构有多少个服务就需要部署多少次。随着服务数量的增加，如果微服务按照单体架构的部署方式，部署的难度会呈指数增加。业务的粒度划分得越细，微服务的数量就越多，这时需要更稳定的部署机制。随着技术的发展，尤其是 Docker 容器技术的推进，以及自动化部署工具（例如开源组件 Jenkins）的出现，微服务的自动化部署(CI持续集成 /CD持续交付)变得越来越简单。 自动化部署可以提高部署的效率，减少人为的控制，部署过程中出现错误的概率降低，部署过程的每一步自动化，提高软件的质量。构建一个自动化部署的系统，虽然在前期需要开发人员或者运维人员的学习，但对于整个软件系统来说是一个全新的概念。在软件系统的整个生命周期之中，每一步是由程序控制的，而不是人为控制，软件的质量提高到了一个新的高度。随着 DevOps 这种全新概念的推进，自动化部署必然会成为微服务部署的优配方式。</p><h3 id="微服务的集中化管理"><a href="#微服务的集中化管理" class="headerlink" title="微服务的集中化管理"></a>微服务的集中化管理</h3><p>微服务系统是按业务单元来划分服务的，服务数量越多，管理起来就越复杂，因此微服务必须使用集中化管理。目前流行的微服务框架中，例如： Spring Cloud 采用 Eureka、Nacos 等来进行注册服务和服务发现，另外， Zookeeper、 Consul 等业都是非常优秀的服务集中化管理框架。只不过基于CAP理论，这个开源框架的侧重点不同，开发者可以视业务场景选择合适的框架。</p><h3 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h3><p>为了防止“雪崩效应”事件的发生，分布式系统采用了熔断机制。在用 SpringCloud 构建的微服务系统中，采用了熔断器（即 Hystrix 组件的 Circuit Breaker）去做熔断。</p><h2 id="微服务的优劣势"><a href="#微服务的优劣势" class="headerlink" title="微服务的优劣势"></a>微服务的优劣势</h2><h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><p>相对于单体服务来说，微服务具有很多的优势，主要体现在以下方面。</p><ol><li>将一个复杂的业务分解成若干小的业务，每个业务拆分成一个服务，服务的边界明确，将复杂的问题简单化。服务按照业务拆分，代码也是按照业务来拆分，代码的可读性和可扩展性增加。</li><li>服务与服务之间没有耦合，随着业务的增加，可以根据业务再拆分服务，具有极强的横向扩展能力。随着应用的用户量的增加，井发量增加，可以将微服务集群化部署，从而增加系统的负载能力。简而言之，微服务系统的微服务单元具有很强的横向扩展能力。</li><li>服务与服务通过HTT网络通信协议来交互，单个微服务内部高度内聚，服务与服务之间完全独立，无耦合。这使得微服务可以采用任何的开发语言和技术来实现。开发人员不再被强迫使用公司以前的技术或者已经过时的技术，而是可以自由选择最适合业务场景的或者最适合自己的开发语言和技术，提高开发效率、降低开发成本。</li><li>如果是一个单体的应用，由于业务的复杂性、代码的耦合性，以及可能存在的历史问题。 在重写一个单体应用时，要求重写的应用的人员了解所有的业务，所以重写单体应用是非常困难的，并且重写风险也较高。如果是微服务系统，由于微服务系统是按照业务的进行拆分的，并且有坚实的服务边界，所以重写某个服务就相当于重写某一个业务的代码。</li><li>微服务在 CAP 理论中采用的是 AP 架构，即具有高可用和分区容错的特点。高可用主要体现在系统 7 x 24 小时不间断的服务，它要求系统有大量的服务器集群，从而提高了系统 的负载能力。另外，分区容错也使得系统更加健壮。</li></ol><h3 id="微服务的不足"><a href="#微服务的不足" class="headerlink" title="微服务的不足"></a>微服务的不足</h3><p>凡事都有两面性，微服务也不例外，微服务相对于单体应用来说具有很多的优势，当然也有它 的不足，主要体现在如下方面:</p><ol><li>微服务的复杂度</li><li>分布式事务问题。</li><li>服务的划分（按照功能划分还是按照组件来划分呢）分工 ，领域模型划分。</li><li>服务的部署（是否是自动化部署）。</li></ol><p>在微服务架构中，有三大难点，那就是<font color="cornflowerblue"><strong>服务故障的传播性(熔断)、服务划分 和 分布式事务</strong></font>。在微服务设计时，一定要考虑清楚这三个场景，从而选择合适的框架。目前比较流行的微服务框架有 Spring 社区的 Spring Cloud、 Google 公司的 Kubemetes 等。</p><ul><li>为了解决服务故障的传播性，一般的微服务框架都有熔断机制组件，如：Hystrix、Sentinel等。</li><li>服务的划分是标准的划分方案的，一般来说根据业务来划分服务，领域驱动设计具有指导作用。</li><li>分布式事务一般的解决办法就是两阶段提交或者三阶段提 交，不管使用哪一种都存在事务失败导致数据不一致的情况，关键时刻还得人工去恢复数据。</li></ul><p> 总之，微服务的设计一定是渐进式的，并且是随着业务的发展而发展的。</p><h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud 作为 Java 语言的微服务框架，它依赖于 Spring Boot，有快速开发、持续交付和容易部署等特点。 Spring Cloud 的组件非常多，涉及微服务的方方面面，井在开源社区 Spring 和 Netflix、 Pivotal 两大公司的推动下越来越完善，如今 alibaba 也加入到其中。Spring Cloud 在开发部署上继承了Spring Boot 的一些优点，提高其在开发和部署上的效率。 Spring Cloud 的首要目标就是通过提供一系列开发组件和框架，帮助开发者迅速搭建一个分布式的微服务系统。 Spring Cloud 是通过包装其他技术框架来实现的，其提供了开发分布式微服务系统的一些常用组件，例如：服务注册和发现、 配置中心、熔断器、远程调用，路由、微代理、控制总线、全局锁、分布式会话等。</p><h3 id="SpringCloud-常用组件表"><a href="#SpringCloud-常用组件表" class="headerlink" title="SpringCloud 常用组件表"></a>SpringCloud 常用组件表</h3><table><thead><tr><th>组件功能</th><th>组件名称</th></tr></thead><tbody><tr><td>服务的注册和发现</td><td>Eureka、Nacos、Consul</td></tr><tr><td>服务的负载均衡</td><td>Ribbon – 负载均衡 + 服务调用 <br> Dubbo（严格的说，Dubbo只是内部集成了LoadBalance的能力，一般并不会作为负载均衡器使用）</td></tr><tr><td>服务的相互调用</td><td>OpenFeign – 基于Controller的restful风格的HTTP协议进行网络通信 <br>Dubbo – 基于Netty进行网络通信</td></tr><tr><td>服务的容错</td><td>Hystrix、Sentinel</td></tr><tr><td>服务网关</td><td>Gateway、Zuul</td></tr><tr><td>服务配置的统一管理</td><td>Config-server、Nacos、Apollo</td></tr><tr><td>服务消息总线</td><td>Bus</td></tr><tr><td>服务安全组件</td><td>Security、Oauth2.0</td></tr><tr><td>服务监控</td><td>Admin、jvm</td></tr><tr><td>链路追踪</td><td>Sleuth、Zipkin</td></tr></tbody></table><p>SpringCloud 只是微服务架构的一种具体实现方式，目前开发中常用的落地实现有三种:</p><ul><li>Dubbo + Zookeeper 半自动化的微服务实现架构</li><li>SpringCloud Netflix 一站式微服务架构</li><li>SpringCloud Alibaba 新的一站式微服务架构</li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/qq_43842093/article/details/122612285">分布式和微服务是什么？二者的区别又是什么？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon</title>
      <link href="/2023/05/15/Spring%20Cloud3-Ribbon/"/>
      <url>/2023/05/15/Spring%20Cloud3-Ribbon/</url>
      
        <content type="html"><![CDATA[<p>轮训算法的实现</p><p><code>%</code>取模运算的结果得到一个整型的周期函数，让得到的结果总是小于除数的。</p><ul><li>1 % 2 = 1</li><li>2 % 2 = 0</li><li>3 % 2 = 1</li><li>4 % 2 =0</li><li>…</li></ul><p>这样就得到一个[0,1]区间的一个周期函数。</p><p>CAS在Java层面是无锁的状态，但是在JVM层面还是有锁的，总线锁或者缓存锁。</p><p>基于CAS的自旋锁，如果有线程同时操作可能会导致短暂的CPU飙升，还有总所周知的ABA问题。</p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java SPI</title>
      <link href="/2023/05/15/Java-SPI/"/>
      <url>/2023/05/15/Java-SPI/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>SPI（Service Provider Interface），是一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，其核心是基于“<strong>面向接口编程＋策略模式＋配置文件</strong>”组合实现的<font color="red"><strong>动态加载机制</strong></font>。</p><blockquote><p>SPI是一种机制，Java SPI只是它的其中一种实现。</p></blockquote><p>SPI整体机制如图：</p><img src="b9a8c10eb304b7ea80f005eba6492199.jpeg" alt="img" style="zoom: 40%;"><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的<code>META-INF/services/</code>目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类的全路径名。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的<code>META-INF/services/</code>中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行反射加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><h2 id="SPI和API的区别"><a href="#SPI和API的区别" class="headerlink" title="SPI和API的区别"></a>SPI和API的区别</h2><p>在现今的微服务的框架下，我们最常见的是提供API服务，也就是接口和实现都部署在同一个集群中，向外通过Http/Rpc协议进行暴露，外部调用方通过引入jar包的方式，使用我们的服务，常用的框架，如：Dubbo，Feign，Ribbon等便是如此。</p><p>这里实际包含两个问题，<strong>第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？</strong></p><p><strong>SPI接口位于调用方所在的包中</strong></p><ul><li>概念上更依赖调用方。</li><li>组织上位于调用方所在的包中。</li><li>实现位于独立的包中。</li><li>常见的例子是：插件模式的插件。</li><li>例如：<ul><li>数据库驱动加载接口实现类的加载 – JDBC加载不同类型数据库的驱动；</li><li>日志门面接口实现类加载 – SLF4J加载不同提供商的日志实现类；</li><li>Spring – Spring中大量使用了SPI，比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI（Converter SPI、Formatter SPI）等；</li><li>Dubbo – Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口；</li></ul></li></ul><blockquote><p>JDK中原生SPI接口，请参考博文：<a href="https://xie.infoq.cn/article/3747510d5b814e43792c3886f">Java Core「6」反射与 SPI 机制</a></p></blockquote><p><strong>API接口位于实现方所在的包中</strong></p><ul><li>概念上更接近实现方。</li><li>组织上位于实现方所在的包中。</li><li>实现和接口在一个包中。<ul><li>例如：微服务中提供的接口API，OpenFeign中的所有Controller层方法。</li></ul></li></ul><h2 id="SPI-的使用"><a href="#SPI-的使用" class="headerlink" title="SPI 的使用"></a>SPI 的使用</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>SPI一般使用在一个接口有多个实现的场景，可以在外界无感的情况下实现接口实现的动态切换，内部会有一个类的动态加载的过程。</p><blockquote><h2 id="动态类加载"><a href="#动态类加载" class="headerlink" title="动态类加载"></a>动态类加载</h2><h3 id="类的动态加载有两种方式："><a href="#类的动态加载有两种方式：" class="headerlink" title="类的动态加载有两种方式："></a>类的动态加载有两种方式：</h3><ul><li><strong>自定义类加载器ClassLoader在代码运行时来进行加载指定的类</strong><ul><li>ClassLoader 类：ClassLoader 是用于加载类的一个抽象类，Java 提供了多种实现，比如 URLClassLoader 和 AppClassLoader。使用 ClassLoader 加载类的方式更加灵活，可以从不同的位置加载类，比如本地文件系统、网络等等。</li></ul></li><li><strong>反射（SPI是基于反射实现的）</strong><ul><li><code>Class.forName()</code> 方法：该方法根据类的完整路径名加载类，返回对应的 Class 对象。需要注意的是，该方法可能会抛出 <code>ClassNotFoundException</code> 异常，需要进行捕获或声明抛出。</li></ul></li></ul><h3 id="Class-forName-和-ClassLoader-的区别"><a href="#Class-forName-和-ClassLoader-的区别" class="headerlink" title="Class.forName() 和 ClassLoader 的区别"></a>Class.forName() 和 ClassLoader 的区别</h3><p>使用 <code>Class.forName()</code> 加载类时，会自动初始化该类，包括执行静态代码块和初始化静态成员变量。而使用 ClassLoader 加载类时，可以控制类的初始化时机，只有在需要使用类时才会进行初始化。</p><h3 id="加载外部类和本地类的区别"><a href="#加载外部类和本地类的区别" class="headerlink" title="加载外部类和本地类的区别"></a>加载外部类和本地类的区别</h3><p>Java 中的类可以分为两类：<strong>外部类</strong>和<strong>本地类</strong>。<strong>外部类是指存储在磁盘上的类文件</strong>，而<strong>本地类是指在当前程序中定义的类</strong>。</p><p>加载外部类时需要指定类文件的路径，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.maple.MyClass&quot;</span>, <span class="literal">true</span>, ClassLoader.getSystemClassLoader());</span><br></pre></td></tr></table></figure><p>其中：第一个参数是类的完整路径名，第二个参数表示是否进行初始化，第三个参数是 ClassLoader。</p><p>加载本地类则可以直接使用目标类，这是利用Java类加载机制，默认是懒加载的，用到的时候才会进行加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">myObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure></blockquote><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>定义一个顶层接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RobotInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一些底层实现<br>实现1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.jdk.spi.intf.RobotInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">RobotInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m Bumblebee&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimusPrime</span> <span class="keyword">implements</span> <span class="title class_">RobotInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, I&#x27;m Optimus Prime.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个配置文件，特定目录下，特定名称，特定内容<br>在类路径（Spring架构下是src/main/resources 下即可）下创建<code>/META-INF/services</code>文件夹，然后文件夹里创建<strong>以顶层接口全路径为名的文件</strong>，如图：</p><img src="spi3.png" style="zoom:80%;"><p>文件内容为每一个实现类的全路径为一行，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.jdk.spi.impl.Bumblebee</span><br><span class="line">com.jdk.spi.impl.OptimusPrime</span><br></pre></td></tr></table></figure><p>测试SPI：</p><p>执行过程：根据入参获取META-INF/services/目录下的目标配置文件，一行一行读取配置内容得到所有实现类的全路径，最后通过反射进行实例化并调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">// 默认使用的是线程上下文类加载器,但是JDK默认是没有具体的实现,而是使用系统类加载器作为线程上下文类加载器来使用.</span></span><br><span class="line">  <span class="comment">// 到此也只是完成了目标类和对应的类加载器的封装 -- 懒加载迭代器.</span></span><br><span class="line">  ServiceLoader&lt;RobotInterface&gt; serviceLoader = ServiceLoader.load(RobotInterface.class);</span><br><span class="line">  <span class="comment">// 执行迭代器的时候才进行类加载并通过反射实例化对象,最后调用目标方法.</span></span><br><span class="line">  serviceLoader.forEach(RobotInterface::sayHello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, I&#x27;m Bumblebee</span><br><span class="line">Hello, I&#x27;m Optimus Prime.</span><br></pre></td></tr></table></figure><h2 id="SPI的优缺点"><a href="#SPI的优缺点" class="headerlink" title="SPI的优缺点"></a>SPI的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>使用Java SPI机制的优势是实现<strong>解耦</strong>，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类；</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的<code>META-INF/services</code>目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>注意到实现类的加载过程，是通过java.util.ServiceLoader进行实现。通过iterator，遍历每一个实现类，而没有按需加载。</p><ul><li>不能按需加载。虽然 ServiceLoader 做了延迟载入，但是基本只能通过遍历全部获取，也就是接口的实现类得全部载入并实例化一遍。容易造成资源浪费。</li><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式迭代获取，不能根据某个参数来获取对应的实现类。</li><li>多线程并发使用 ServiceLoader 类的实例存在安全隐患。</li><li>实现类不能通过有参构造器实例化。</li></ul><blockquote><p><strong>注意事项</strong><br><strong>接口实现类必须提供一个无参的构造器！，因为实例化接口实现类的时候是利用class.newInstance()方法，其是利用无参构造来实例化的。</strong></p></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>其实就是利用线程上下文类加载器来对指定路径下的文件进行类加载，然后通过反射来实例化对象，核心就是<code>Class.forName()</code>，并封装成一个Iterable对象（LazyIterator懒迭代器），实现遍历调用。<br>LazyIterator 懒迭代器在执行迭代的时候才进行反射操作，并通过反射实例化对象，最后调用目标方法来完成具体业务执行。</p><p><strong>ServiceLoader.load()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定自定义类加载的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取线程线程的上下文类加载器</span></span><br><span class="line">  <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用线程上下文类加载器(如果为null, 就是用系统类加载器)对目标service接口的所有实现类进行加载, 并封装成为Iterator对象.</span></span><br><span class="line">  <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">  service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">  loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl; <span class="comment">// 线程上下文类加载器为空就使用系统类加载器</span></span><br><span class="line">  acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">  reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">  providers.clear(); <span class="comment">// 清空缓存</span></span><br><span class="line">  <span class="comment">// 懒加载的迭代器,即在开始进行迭代时才会执行类加载动作并通过反射创建对象并调用目标方法</span></span><br><span class="line">  lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LazyIterator</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">  <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">  nextName = <span class="literal">null</span>;</span><br><span class="line">  Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射进行类加载并获取到Class对象.</span></span><br><span class="line">    c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射实例化对象并进行类型转换.</span></span><br><span class="line">    <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">    providers.put(cn, p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">    fail(service,<span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，Java 应用运行的初始线程的上下文类加载器就是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 </p><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 <code>javax.xml.parsers</code>包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 <code>javax.xml.parsers.DocumentBuilderFactory</code>类中的 <code>newInstance()</code>方法用来生成一个新的 <code>DocumentBuilderFactory</code>的实例。这里的实例的真正的类是继承自 <code>javax.xml.parsers.DocumentBuilderFactory</code>，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 <code>org.apache.xerces.jaxp.DocumentBuilderFactoryImpl</code>。而问题在于<strong>，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的； SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的父类加载器。也就是说，类加载器的代理模式无法解决这个问题。线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。这就是JVM中常说的打破类加载的双亲委派模型。</strong></p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/2301_76607156/article/details/129425834">Java 反射：动态类加载和调用教程</a></p><p><a href="https://blog.csdn.net/qq_37080455/article/details/127970892">Java基础五大机制 —— SPI机制基础</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题及解决方案</title>
      <link href="/2023/05/11/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/11/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><h2 id="什么是跨域问题？"><a href="#什么是跨域问题？" class="headerlink" title="什么是跨域问题？"></a>什么是跨域问题？</h2><p>出于浏览器的<font color="red">同源策略</font>限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。<font color="red">同源策略</font>会阻止一个域的<font color="red"><strong>javascript脚本</strong></font>和另外一个域的内容进行交互。<font color="cornflowerblue">所谓同源（即指在同一个域）就是两个页面的URL具有相同的协议（protocol），主机/域名（host）和端口号（port）。</font></p><h2 id="URI、URL和URN的区别"><a href="#URI、URL和URN的区别" class="headerlink" title="URI、URL和URN的区别"></a>URI、URL和URN的区别</h2><p>当我们打开浏览器，要访问一个网站或者一个ftp服务器的时候，输入一串字符串， 比如：<code>https://blog.csdn.net/</code>或者：<code>ftp://192.168.0.111/</code>，这样我们就可以得到一个html格式的页面或者一个文件。那么这个地址是什么意思呢？就必须要从URI、URL、URN讲起。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><strong>URI = Uniform Resource Identifier 统一资源标志符</strong></li><li><strong>URL = Uniform Resource Locator 统一资源定位符</strong></li><li><strong>URN = Uniform Resource Name 统一资源名称</strong></li></ul><p>简单来说，URI是抽象的定义，不管用什么方法表示，只要能定位一个资源，就叫URI。本来设想的使用两种方法定位：1、<strong>URL，用地址定位</strong>；2、<strong>URN 用名称定位</strong>。但是urn没流行起来，导致现在大家说的所有的UR都是默认就是URL。</p><p><strong>举个例子</strong>：去村子找个具体的人（URI），如果用地址：某村多少号房子第几间房的主人，就是URL；如果用身份证号+名字去找就是URN了。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>URI是以一种抽象的，高层次概念定义统一资源标识，而URL则是具体的资源标识的方式。URL是一种URI。</li><li>格式不同：URL的格式一般由下列四部分组成：<ol><li>第一部分是协议(或称为服务方式)；</li><li>第二部分是存有该资源的主机IP地址，也叫域名；</li><li>第三部分是端口号；</li><li>第四部分是主机资源的具体地址。</li></ol></li></ol><p>3、在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema（protocol，协议）必须被指定。</p><h3 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h3><img src="url1.png" style="zoom:40%;"><h2 id="URL结构解析"><a href="#URL结构解析" class="headerlink" title="URL结构解析"></a>URL结构解析</h2><p>URL代表着是统一资源定位符（UniformResourceLocator）。</p><p>作用是为了告诉使用者 某个资源在 Web 上的地址。比如：用HTTP协议访问Web服务器：</p><img src="url2.png" style="zoom:80%;"><p>用FTP协议下载和上传文件的URL：</p><img src="url3.png" style="zoom:80%;"><p>读取客户端计算机本地文件的URL：</p><img src="url4.png" style="zoom:30%;"><p>URL的结构组成如下图：</p><img src="u=72685375,2378383068&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG.jpeg" style="zoom:33%;"><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>尽管 URL 有各种不同的写法， 但它们有一个共同点， 开头部分的内容必须是协议类型，可以是http、ftp、mailto或者https，这部分文字都表示浏览器应当使用的访问方法,会用‘//’为分隔符。决定了后面部分的写法， 因此并不会造成混乱。</p><h4 id="用户名-密码"><a href="#用户名-密码" class="headerlink" title="用户名/密码"></a>用户名/密码</h4><p>用户名密码通常可以省略。</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名是<code>www.gitee.com</code>，在发送请求前，会向DNS服务器请求将域名字符串解析为IP地址。如果已经知道ip，还可以跳过DNS解析那一步，直接把IP当做域名部分使用。</p><p>域名是<font color="cornflowerblue">从右向左</font>进行分析的，依次为：<strong>域名后缀、顶级域名（一级域名）、二级域名、三级域名</strong>，如图：</p><img src="url5.png" style="zoom:50%;"><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>域名后面有些时候会带有端口，和域名之间用’:’分隔，端口不是一个URL的必须的部分。 当网址为http://时，默认端口为80， https://时，默认端口是443， ftp://时，默认端口是21。此时端口号可以省略不写。</p><h4 id="文件路径-文件名"><a href="#文件路径-文件名" class="headerlink" title="文件路径/文件名"></a>文件路径/文件名</h4><p><strong>从域名之后的第一个/开始到最后一个/为止，是虚拟目录的部分</strong>。虚拟目录也不是URL必须的部分，上述实例http协议url中的虚拟目录是：<code>/yikoulinux/chat/blob/master/</code></p><p><strong>从域名最后一个’/‘开始到’?’为止，是文件名部分</strong>；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。</p><p>文件名也不是一个URL的必须部分。</p><p>Demo：判断下列URL与 <code>http://www.example.com:8080</code>是否是跨域？</p><table><thead><tr><th align="center">比较的URL</th><th align="center">是否跨域</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center"><strong>http</strong>://<strong><a href="http://www.example.com/">www.example.com</a></strong>:<strong>8080</strong>/dir/page.html</td><td align="center">否</td><td align="center">协议、主机/域名、端口号等相同</td></tr><tr><td align="center"><strong>http</strong>://username:password@<strong><a href="http://www.example.com/">www.example.com</a></strong>:<strong>8080</strong>/dir/page.html</td><td align="center">否</td><td align="center">协议、主机/域名、端口号等相同</td></tr><tr><td align="center"><a href="http://www.example.com:**81**/dir/page.html">http://www.example.com:**81**/dir/page.html</a></td><td align="center">跨域</td><td align="center">端口号不相同</td></tr><tr><td align="center"><code>https://www.example.com:8080</code></td><td align="center">跨域</td><td align="center">协议不相同</td></tr><tr><td align="center"><code>http://en.example.com:8080</code></td><td align="center">跨域</td><td align="center">主机/域名不相同</td></tr></tbody></table><blockquote><p>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>常见的几种解决方案：</p><ul><li><p><strong>服务器代理</strong></p><ul><li>让请求和响应双方url不同源，域名不同。</li></ul></li><li><p><strong>改发JSONP</strong></p><ul><li>将ajax请求改为JSONP<ul><li>不是ajax</li><li>只能支持<code>get方式</code></li></ul></li></ul></li><li><p><strong>CORS</strong></p><ul><li>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</li><li>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10(ie8通过XDomainRequest能支持CORS)。</li></ul></li><li><p>Spring MVC中提供的**@CrossOrigin注解**</p><ul><li>当域名<code>www.abc.com</code>下的js代码去访问<code>www.def.com</code>域名下的资源，就会受到限制。使用@CrossOrigin可以处理跨域请求，让你能访问不是一个域的文件。</li></ul></li></ul><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/weixin_66375317/article/details/124545878?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168377237516800211595928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168377237516800211595928&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124545878-null-null.142%5Ev86%5Ewechat,239%5Ev2%5Einsert_chatgpt&utm_term=%E8%B7%A8%E5%9F%9F&spm=1018.2226.3001.4187">什么是跨域？跨域解决方法</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通Token令牌 vs. JWT令牌</title>
      <link href="/2023/05/10/%E6%99%AE%E9%80%9AToken%E4%BB%A4%E7%89%8C-vs-JWT%E4%BB%A4%E7%89%8C/"/>
      <url>/2023/05/10/%E6%99%AE%E9%80%9AToken%E4%BB%A4%E7%89%8C-vs-JWT%E4%BB%A4%E7%89%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="普通Token令牌-vs-JWT令牌"><a href="#普通Token令牌-vs-JWT令牌" class="headerlink" title="普通Token令牌 vs. JWT令牌"></a>普通Token令牌 vs. JWT令牌</h1><blockquote><p>SpringSecurityOauth2令牌<br>参考： <a href="https://www.yuque.com/gaoxi-dj1fr/fxgaxe/ivvpqc">SpringSecurityOauth2令牌</a></p></blockquote><h2 id="令牌分类"><a href="#令牌分类" class="headerlink" title="令牌分类"></a>令牌分类</h2><p>常见的令牌有两种：普通令牌Token 和 JWT令牌</p><blockquote><p>JWT令牌请见博文：<a href="/maple/2023/05/05/JWT">浅析JWT</a></p></blockquote><h4 id="普通令牌"><a href="#普通令牌" class="headerlink" title="普通令牌"></a>普通令牌</h4><p>唯一标识存储在数据库或<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中的用户信息，在认证时，SpringSecurity服务端会拿着普通令牌去数据库中查询用户信息来实现认证鉴权。</p><h4 id="JWT令牌"><a href="#JWT令牌" class="headerlink" title="JWT令牌"></a>JWT令牌</h4><p>JWT令牌本身就存储着用户信息，在认证时，SpringSecurity从JWT令牌中按照约定的加密算法，解析出用户信息即可实现认证，不需要借助数据库等进行存储，进一步提高了认证鉴权的性能。</p><h3 id="普通Token令牌"><a href="#普通Token令牌" class="headerlink" title="普通Token令牌"></a>普通Token令牌</h3><p>普通令牌是SpringSecurityOauth2给客户端颁发的一个无含义的令牌，在令牌发布时，SpringSecurityOauth2将用户信息存储到程序指定的存储位置，并用普通令牌唯一标识这个存储信息，当用户再次携带令牌访问时，SpringSecurityOauth2会根据令牌查询用户信息，进而实现权限角色的限制。</p><p>普通令牌需要一个存储用户信息的地方，这个地方可以本地内存，也可以是数据库（Redis、Mysql）。</p><img src="1594967846444-df5a8f3b-aece-4032-86eb-dadfaa5f1661.png" alt="image.png" style="zoom:50%;"><h4 id="基于本地内存存储"><a href="#基于本地内存存储" class="headerlink" title="基于本地内存存储"></a>基于本地内存存储</h4><table><thead><tr><th>测试项</th><th>测试结果</th></tr></thead><tbody><tr><td>同一个认证服务器同一个用户多次调用发布令牌</td><td>会返回同一个令牌（access_token、refresh_token）</td></tr><tr><td>调用刷新token</td><td>1. refresh_token本身是不会变化，无论刷新几次<br>2. 刷新后原access_token立即失效，并生成新的access_token.</td></tr><tr><td>多台认证服务器同一个用户多次调用发布令牌</td><td>1.不同的认证服务器发布令牌各不相同</td></tr><tr><td>用户信息的获取方式</td><td>通过调用<code>/oauth/check_token</code>去获取用户认证信息</td></tr></tbody></table><p><strong>结论</strong></p><ul><li>基于内存存储用户信息的方式，认证服务器将用户信息存储在各自JVM运行时内存中；</li><li>当资源服务器获得access_token后，会通过远程调用认证服务器的<code>/oauth/check_token</code>，校验token，获得用户信息；</li><li>在微服务场景下不适用；</li></ul><h3 id="基于Redis缓存存储"><a href="#基于Redis缓存存储" class="headerlink" title="基于Redis缓存存储"></a>基于Redis缓存存储</h3><table><thead><tr><th>测试项</th><th>测试结果</th></tr></thead><tbody><tr><td>同一个认证服务器同一个用户多次调用发布令牌</td><td>会返回同一个令牌（access_token、refresh_token）</td></tr><tr><td>调用刷新token</td><td>1. refresh_token本身是不会变化，无论刷新几次<br>2. 刷新后原access_token立即失效，并生成新的access_token.</td></tr><tr><td>多台认证服务器同一个用户多次调用发布令牌</td><td>不同的认证服务器发布令牌是相同的，不论哪个认证服务器，都会返回同一个access_token和refresh_token</td></tr><tr><td>用户信息的获取方式</td><td>从Redis数据库中获取</td></tr></tbody></table><p><strong>结论</strong></p><ul><li>基于Redis存储用户信息的方式，认证服务器将用户信息存储到指定的Redis数据库中；</li><li>当资源服务获取到access_token时，会到Redis中获取用户信息；</li><li>在微服务场景下适用；</li></ul><p>其中：access_token就是所说的普通Token。</p><h3 id="JWT令牌-1"><a href="#JWT令牌-1" class="headerlink" title="JWT令牌"></a>JWT令牌</h3><p>JWT令牌的方式就无需数据库的介入，JWT令牌中就包含着用户的信息，SpringSecurityOauth在发布令牌时，会将用户信息放入JWT令牌中，用户拿着JWT令牌时，SpringSecurityOauth从中获取到用户信息，实现用户权限的控制。</p><img src="1594978948208-daf86822-f444-48cd-95e0-f6462d53c856.png" alt="image.png" style="zoom:50%;"><p>JWT不需要后端进行存储。</p><table><thead><tr><th>测试项</th><th>测试结果</th></tr></thead><tbody><tr><td>同一个认证服务器同一个用户多次调用发布令牌</td><td>同一个认证服务器会返回不同的令牌（access_token、refresh_token）</td></tr><tr><td>调用刷新token</td><td>1. refresh_token每请求依次就会变一次<br>2. 刷新后原access_token不会失效，并生成新的access_token.</td></tr><tr><td>多台认证服务器同一个用户多次调用发布令牌</td><td>不同的认证服务器发布令牌是不同的</td></tr><tr><td>用户信息的获取方式</td><td>从JWT令牌中获取</td></tr></tbody></table><p><strong>结论</strong></p><ul><li>基于JWT令牌的认证服务器，用户信息存储到令牌中；</li><li>当资源服务获取到access_token后，会解析这个JWT类型的access_token，从中会获取到用户信息；</li><li>微服务场景下不适用；</li></ul><blockquote><p>JWT令牌也不能说微服务场景下不适用，只是相对于基于数据库存储的普通令牌来说，重复请求的JWT是不一样的，也就是说JWT和用户信息是一种多对一的映射关系，可能微服务场景下，更常见的是令牌和用户是一对一的映射关系。</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="APP服务端接口，用-JWT-or-Redis-Token，分别有什么优势？"><a href="#APP服务端接口，用-JWT-or-Redis-Token，分别有什么优势？" class="headerlink" title="APP服务端接口，用 JWT or Redis+Token，分别有什么优势？"></a>APP服务端接口，用 JWT or Redis+Token，分别有什么优势？</h3><p><strong>JWT属于无状态设计</strong>，用户登陆的信息存放在JWT加密数据里，这种设计下服务器不需要存储JWT密文，只需要解密就能拿到授权信息等用户信息。这种设计是一种利用服务器的计算力减少Token设计下数据库及缓存的压力和设计复杂度，因此它的本质就是不存储登陆授权，而是通过密文本身保存授权信息。</p><p>Token加Redis设计，是一种登陆后分配随机Token，然后记录Token与用户信息这种一一映射关系的设计。</p><p>很明显，这两种设计的区别就在于Token是否是需要服务器存储，每次验权是否需要查询数据库。JWT不需要服务器存储，信息本身就存储于JWT本身，这种模式无需使用数据库。</p><p>但是这种流行的JWT有一个设计上的缺陷，它通过密文传输用户信息，那么服务器在这种基础结构下是无法做到关闭用户登陆授权的操作，如果用户的JWT密文被偷窃，那么黑客就能以用户身份登陆，并且即使知道密文丢失，也无法关闭被偷窃的JWT密文。为了应对这一问题，可以使用<strong>JWT内部验证有效期</strong>和<strong>JWT黑名单模式</strong>，但是有效期始终无法做到及时停止JWT授权，这是一个治标不治本的方法。而JWT黑名单模式，则需要数据库或内存存储黑名单，那么，这实际上违背了JWT的免数据库设计原则。</p><p>因此，如果严格按照两种模式设计，<font color="red">Token模式适合较高安全度和用户登陆等信息分析的系统</font>，如：普通的博客、阅读器等等，这种服务允许不严格的登陆授权，即使密文丢失也不会造成用户的严重损失，却能获得较高的服务性能。</p><p>Token模式，必须配合数据库进行存储和查询，虽然性能相对JWT会低一些（随着数据库和缓存性能的提升，这一次的查询操作其实不会造成明显的性能影响），但Token模式却能做到及时的授权关闭，已经登陆授权可见可查，每一次Token都会有对应的记录。因此<font color="red">Token模式适合较高安全度和用户登陆等信息分析的系统</font>，如政府系统，支付系统等不可能允许高权限的Token被偷窃却不能及时关闭授权。</p><p><strong>结论：</strong></p><ul><li>JWT，适合轻量的系统和权限不严格系统。</li><li>Token，适合重量系统和权限有严格要求的系统。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>普通的Token方式采用的是：<code>登录--&gt;生成随机字符串（Token）--&gt; 服务器保存Token与用户信息的对应关系</code>，对应用户利用Token校验的流程是 <code>Token--&gt;查询Token对应用户信息--&gt;各系统根据用户信息</code> 进行业务处理。</p><p>很明显可以看出，Token模式下的字符串实际上不需要和用户信息有任何关联，生成的Token字符串的要求就是唯一标识，不能被其他用户占有，否则就会出现用户登录后实际上是以其他人身份进行业务处理。如果字符串是随机生成，那么黑客就无法猜测Token的生成规律，也无法从Token直接猜测到用户相关信息。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT采用的生成：<code>登录--&gt;生成带有用户数据的加密字符串（该字符串服务器并不存储，直接下发给客户端</code>）</p><p>校验：<code>客户端将存储的JWT密文带上--&gt;服务器解密密文</code>，获取到用户信息</p><p>可以看出，JWT的凭证不仅要求唯一，还要求密文本身实际上是带有了用户信息，当然这块可以是非敏感信息，这只是实现上的细节区别，和结构本身没有特别大的关联。服务器本身并没有存储这次JWT密文，每次服务器的处理都是直接解密JWT密文。这样做的好处就是服务架构内直接抛弃了登录相关的传统Token系统，并且服务器不再管理登录状态，Token有效状态等问题。</p><p>而JWT带来的问题，凭证实际上的一串密文，更多的用户信息或session信息需要更大的密文来存储，进而每次请求都带上JWT就会使网络传输的内容变大，加大了<strong>网络开销</strong>；凭证是一串密文，那么如果黑客破解了服务器的加密方式，那么密文实际上就是用户的明文信息在网络上传输（这就是传说中的裸奔），黑客可以直接伪造JWT登录或通过JWT密文获取到用户信息；JWT本身不管理JWT的有效性，一旦密文被偷窃，无法做到关闭掉黑客的授权。</p><p><strong>核心缺点</strong>：<font color="red">网络开销</font>、<font color="red">黑客的窃取|篡改|伪装</font>、<font color="red">无法及时关闭授权</font>。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://blog.csdn.net/inthat/article/details/108244652">普通令牌Token和JWT令牌Token区别以及使用场景</a></p><p><a href="https://blog.csdn.net/u014756827/article/details/103047695">APP服务端接口，用JWT还是用Redis和Token，分别有什么优势</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> 令牌 </tag>
            
            <tag> Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM钩子</title>
      <link href="/2023/05/09/JVM%E9%92%A9%E5%AD%90/"/>
      <url>/2023/05/09/JVM%E9%92%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM钩子"><a href="#JVM钩子" class="headerlink" title="JVM钩子"></a>JVM钩子</h1><p>JVM进程在接收到<code>kill -15</code>信号通知的时候，是可以做一些清理动作的，比如：删除临时文件等。当然了，开发者也可以基于该信号自定义做一些额外的操作，比如：让tomcat容器停止，让dubbo服务下线，清理数据等。这种自定义JVM清理动作的方式，是通过JDK中提供的<code>ShutdownHook</code>实现的。JDK提供了<code>Java.Runtime.addShutdownHook(Thread hook)</code> 方法，可以注册一个在JVM关闭时需要执行的钩子方法。</p><blockquote><p>kill命令原理请见博文：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650127782&idx=1&sn=87cc02ab1484b14e0313998da527bedf&chksm=f36ba087c41c29916a572f24f2a9b21cdc7080a75261c7f662d86de558840d13cd0bc93ed1fc&scene=178&cur_album_id=1337197892284809216#rd">kill -9的原理</a></p></blockquote><h2 id="JVM钩子的作用"><a href="#JVM钩子的作用" class="headerlink" title="JVM钩子的作用"></a>JVM钩子的作用</h2><p><strong>JVM钩子方法的执行时机是在所有非守护线程都执行完成之后，在JVM进程退出之前</strong>，利用钩子线程去执行一些清理工作，如：释放资源，文件清理等等。</p><p>我们都知道，在Linux中，Java应用是作为一个独立进程运行的，Java程序的终止就是基于JVM进程的关闭实现的，JVM进程关闭方式分为3种：</p><ul><li><strong>正常关闭</strong>：当最后一个非守护线程运行结束 或者 调用了 <code>System.exit( )</code> 或者 通过其他特定平台的方法关闭 或者 执行 <code>kill [-15]</code>（接收到SIGINT（2）、SIGTERM（15）信号等）；</li><li><strong>异常关闭</strong>：程序运行中遇到<code>RuntimeException</code>异常，或者操作系统程序出现异常导致JVM退出等；</li><li><strong>强制关闭</strong>：通过调用<code>Runtime.halt( )</code>方法 或者 在操作系统中强制 <code>kill -9</code>（接收到SIGKILL（9）信号)</li></ul><blockquote><p><strong>Linux常见的信号有：</strong></p><ul><li><strong>kill -2 PID</strong> —— 正常中断进程（作用等同于：Ctrl + C ）。程序在结束之前，能够保存相关数据，然后再退出。</li><li><strong>kill -9 PID</strong> —— 强制杀死一个进程。</li><li><strong>kill [-15] PID</strong> —— 正常方式关闭（终止）进程。关闭进程时应先考虑使用 <code>kill -15</code> ，以便于其能够预先清理临时文件和释放资源。</li></ul><p><strong>PS：<code>kill -9</code> 作为最后手段，应对那些失控的进程。</strong></p></blockquote><h2 id="JVM钩子的使用场景"><a href="#JVM钩子的使用场景" class="headerlink" title="JVM钩子的使用场景"></a>JVM钩子的使用场景</h2><h3 id="JVM正常关闭-–-钩子生效"><a href="#JVM正常关闭-–-钩子生效" class="headerlink" title="JVM正常关闭 – 钩子生效"></a>JVM正常关闭 – 钩子生效</h3><p>如果有注册钩子，那么当JVM进程中的所有非守护线程执行完任务之后，JVM退出之前会执行钩子里面的任务。</p><p><strong>Demo1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!! </span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p>从上述代码可以看出，我们一般定义的钩子任务都是被封装成一个线程任务，也就是说每个钩子都分别是在一个不同的线程中并发执行的。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h4><p>IDEA中debug上述Demo，发现在JVM进程中当所有的非守护线程结束时，JVM底层的C源码会调用JNI创建一个名为：**DestroyJavaVM线程 **用于执行注册的钩子任务。</p><img src="hook1.png" style="zoom:80%;"><p><strong>DestroyJavaVM线程定义</strong></p><p>从 <code>java.c</code> 源码文件中找到<strong>DestroyJavaVM线程</strong>的定义。如下图：</p><img src="hook2.png" style="zoom:80%;"><blockquote><p>* Wait for all non-daemon threads to end, then destroy the VM.</p><p>* This will actually create a trivial new Java waiter thread named “DestroyJavaVM”, but this will be seen as a different thread from the one that executed main, even though they are the same C thread.  This allows mainThread.join( )  and mainThread.isAlive() to work as expected.</p><p>译文：等待所有非守护线程结束，然后销毁VM。这实际上会创建一个名为“DestroyJavaVM”的Java等待线程，但这将被视为一个不同于执行main的线程，尽管它们是同一个C线程。这允许mainThread.join( )和mainThread.isAlive( )按预期工作。</p></blockquote><p>从上述debug的截图来看，这个<strong>DestroyJavaVM线程</strong>主要就是调用了<code>Shutdown.shutdown()</code>方法来执行注册的钩子。钩子任务的整个执行链路如下图所示：</p><img src="hook3.png" style="zoom:80%;"><p><strong>Shutdown.shutdwon( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by the JNI DestroyJavaVM procedure when the last non-daemon thread has finished. </span></span><br><span class="line"><span class="comment"> * Unlike the exit method, this method does not actually halt the VM.</span></span><br><span class="line"><span class="comment"> * 译文：当最后一个非守护线程执行完成时，由JNI DestroyJavaVM过程调用。与exit方法不同的是，此方法实际上不会停止虚拟机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:       <span class="comment">/* Initiate shutdown */</span></span><br><span class="line">            state = HOOKS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HOOKS:         <span class="comment">/* Stall and then return */</span></span><br><span class="line">        <span class="keyword">case</span> FINALIZERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (Shutdown.class) &#123;</span><br><span class="line">        sequence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.sequence( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The actual shutdown sequence is defined here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it weren&#x27;t for runFinalizersOnExit, this would be simple -- we&#x27;d just</span></span><br><span class="line"><span class="comment"> * run the hooks and then halt.  Instead we need to keep track of whether</span></span><br><span class="line"><span class="comment"> * we&#x27;re running hooks or finalizers.  In the latter case a finalizer could</span></span><br><span class="line"><span class="comment"> * invoke exit(1) to cause immediate termination, while in the former case</span></span><br><span class="line"><span class="comment"> * any further invocations of exit(n), for any n, simply stall.  Note that</span></span><br><span class="line"><span class="comment"> * if on-exit finalizers are enabled they&#x27;re run iff the shutdown is</span></span><br><span class="line"><span class="comment"> * initiated by an exit(0); they&#x27;re never run on exit(n) for n != 0 or in</span></span><br><span class="line"><span class="comment"> * response to SIGINT, SIGTERM, etc.</span></span><br><span class="line"><span class="comment"> * 译文: 实际的关闭顺序在这里定义。</span></span><br><span class="line"><span class="comment"> * 如果没有runFinalizersOnExit，这将是简单的——我们只需运行钩子，然后停止。相反，我们需要跟踪运行的是钩子还是终结器。</span></span><br><span class="line"><span class="comment"> * 在后一种情况下，终结器可以调用exit(1)来导致立即终止，而在前一种情况下，任何对exit(n)的进一步调用，对于任何n，</span></span><br><span class="line"><span class="comment"> * 都只是暂停。注意，如果启用了on-exit终结器，那么如果关闭由一个exit(0)启动，它们就会运行;它们永远不会在退出(n)时运行，</span></span><br><span class="line"><span class="comment"> * 因为n != 0或响应SIGINT、SIGTERM等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sequence</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">/* Guard against the possibility of a daemon thread invoking exit</span></span><br><span class="line"><span class="comment">         * after DestroyJavaVM initiates the shutdown sequence</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (state != HOOKS) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runHooks(); <span class="comment">// 核心 -- 执行钩子</span></span><br><span class="line">    <span class="type">boolean</span> rfoe;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        state = FINALIZERS;</span><br><span class="line">        rfoe = runFinalizersOnExit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rfoe) runAllFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.runHooks( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> slot, <span class="type">boolean</span> registerShutdownInProgress, Runnable hook)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hooks[slot] != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Shutdown hook at slot &quot;</span> + slot + <span class="string">&quot; already registered&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!registerShutdownInProgress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; RUNNING)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hooks[slot] = hook;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run all registered shutdown hooks*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SYSTEM_HOOKS; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable hook;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// acquire the lock to make sure the hook registered during shutdown is visible here.</span></span><br><span class="line">                currentRunningHook = i;</span><br><span class="line">                hook = hooks[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hook != <span class="literal">null</span>) hook.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ThreadDeath) &#123;</span><br><span class="line">                <span class="type">ThreadDeath</span> <span class="variable">td</span> <span class="operator">=</span> (ThreadDeath) t;</span><br><span class="line">                <span class="keyword">throw</span> td;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.run( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationShutdownHooks</span> &#123;</span><br><span class="line">    <span class="comment">/* The set of registered hooks */</span></span><br><span class="line">    <span class="comment">// IdentifyHashMap的解释: https://blog.csdn.net/f641385712/article/details/81880711</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Shutdown.add(<span class="number">1</span> <span class="comment">/* shutdown hook invocation order */</span>,</span><br><span class="line">                <span class="literal">false</span> <span class="comment">/* not registered if shutdown in progress */</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        runHooks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            hooks = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// application shutdown hooks cannot be added if</span></span><br><span class="line">            <span class="comment">// shutdown is in progress.</span></span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.runHooks() – 执行钩子任务的核心方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Iterates over all application hooks creating a new thread for each</span></span><br><span class="line"><span class="comment"> * to run in. Hooks are run concurrently and this method waits for</span></span><br><span class="line"><span class="comment"> * them to finish.</span></span><br><span class="line"><span class="comment"> * 译文: 遍历所有应用程序钩子，为每个要运行的钩子创建一个新线程。钩子任务是并发执行的，这个方法等待它们完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这行代码是钩子任务的灵魂，阻塞当前线程直到所有的钩子任务线程执行完毕。</span></span><br><span class="line">                <span class="comment">// 同时需要注意正是因为该行代码的存在导致在钩子任务中请勿执行耗时长的任务，否则会导致JVM进程长时间无法退出。</span></span><br><span class="line">                hook.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者在注入钩子时使用的<code>addShutdownHook()</code>方法，就是进行注册钩子。</p><p><strong>Runtime.addShutdownHook( )方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShutdownHook</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.add()方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(hooks == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line">    hooks.put(hook, hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，JVM进程正常结束时，注册钩子任务的执行流程源码分析就结束了，从开发者代码注入钩子到执行钩子的触发时机，每一步的对应源码分析都很仔细，后续再熟悉熟悉整个流程。</p><p><strong>Demo2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p><strong>System.exit ( )方法源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    Runtime.getRuntime().exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runtime.exit( )方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        security.checkExit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Shutdown.exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.exit( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by Runtime.exit, which does all the security checks.</span></span><br><span class="line"><span class="comment"> * Also invoked by handlers for system-provided termination events,</span></span><br><span class="line"><span class="comment"> * which should pass a nonzero status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">runMoreFinalizers</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>) runFinalizersOnExit = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:       <span class="comment">/* Initiate shutdown */</span></span><br><span class="line">                state = HOOKS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOOKS:         <span class="comment">/* Stall and halt */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINALIZERS: <span class="comment">// 如果是终结器</span></span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Halt immediately on nonzero status */</span></span><br><span class="line">                    halt(status); <span class="comment">// 关闭JVM</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* Compatibility with old behavior:</span></span><br><span class="line"><span class="comment">                     * Run more finalizers and then halt</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    runMoreFinalizers = runFinalizersOnExit;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runMoreFinalizers) &#123;</span><br><span class="line">        runAllFinalizers();</span><br><span class="line">        halt(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (Shutdown.class) &#123;</span><br><span class="line">        <span class="comment">/* Synchronize on the class object, causing any other thread</span></span><br><span class="line"><span class="comment">         * that attempts to initiate shutdown to stall indefinitely</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sequence(); <span class="comment">// 顺序关系方法，又回到上述正常关闭时执行钩子方法的逻辑了</span></span><br><span class="line">        halt(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，调用`System.exit(0)方法结束JVM进程时，还是会执行钩子任务的。</p><h3 id="JVM异常关闭-–-钩子生效"><a href="#JVM异常关闭-–-钩子生效" class="headerlink" title="JVM异常关闭 – 钩子生效"></a>JVM异常关闭 – 钩子生效</h3><p><strong>JVM进程在发生异常情况导致退出时，</strong>钩子还是会生效。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">at com.maple.system.Demo_System_Exit.main(Demo_System_Exit.java:17)</span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p>从debug可以看出，钩子的执行和JVM进程正常结束时是一样的：</p><img src="hook4.png" style="zoom:80%;"><h3 id="JVM强制关闭-–-钩子不生效"><a href="#JVM强制关闭-–-钩子不生效" class="headerlink" title="JVM强制关闭 – 钩子不生效"></a>JVM强制关闭 – 钩子不生效</h3><p><strong>JVM进程如果是被执行了<code>kill -9</code> 或 <code>Runtime.halt()</code>方法等强制关闭的场景下，</strong>钩子是不生效的。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    Runtime.getRuntime().halt(<span class="number">0</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p><strong>Runtime.halt( )方法分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">halt</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkExit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Shutdown.halt(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.halt( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The halt method is synchronized on the halt lock</span></span><br><span class="line"><span class="comment"> * to avoid corruption of the delete-on-shutdown file list.</span></span><br><span class="line"><span class="comment"> * It invokes the true native halt method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">halt</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (haltLock) &#123;</span><br><span class="line">        halt0(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">halt0</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p>底层直接调用了JNI方法实现JVM进程的强制关闭，整个链路中没有钩子任务的执行逻辑。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Saas</title>
      <link href="/2023/05/08/%E6%B5%85%E6%9E%90Saas/"/>
      <url>/2023/05/08/%E6%B5%85%E6%9E%90Saas/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析Saas"><a href="#浅析Saas" class="headerlink" title="浅析Saas"></a>浅析Saas</h1><h2 id="什么是SAAS平台？"><a href="#什么是SAAS平台？" class="headerlink" title="什么是SAAS平台？"></a>什么是SAAS平台？</h2><p>　　SaaS是随着互联网技术的发展和应用软件的成熟，在21世纪开始兴起的一种完全创新的软件应用模式。</p><p>　　软件运营服务是（Software as a Service，简称SaaS）让用户能够通过<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186?fromModule=lemma_inlink">互联网</a>连接和使用基于<a href="https://baike.baidu.com/item/%E4%BA%91/2363180?fromModule=lemma_inlink">云</a>的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink">应用程序</a>。常见示例有电子邮件、日历和办公工具。 它不需要用户将<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81/6800028?fromModule=lemma_inlink">软件产品</a>安装在自己的电脑或服务器上。</p><p>SaaS提供完整的软件解决方案，用户可以从<a href="https://baike.baidu.com/item/%E4%BA%91%E6%9C%8D%E5%8A%A1/7843499?fromModule=lemma_inlink">云服务</a>提供商处以即用即付方式进行购买。为组织租用应用，组织用户即可通过互联网连接到该应用（通常使用 Web浏览器）。所有<a href="https://baike.baidu.com/item/%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/22471639?fromModule=lemma_inlink">基础结构</a>、<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240?fromModule=lemma_inlink">中间件</a>、<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/216367?fromModule=lemma_inlink">应用软件</a>和应用数据都位于服务提供商的数据中心内。服务提供商负责管理硬件和软件，并根据适当的服务协议确保应用和数据的可用性和安全性。SaaS让组织能够通过最低前期成本的应用快速建成投产。 因为它不需要用户将软件产品安装在自己的电脑或服务器上。而是按某种服务水平协议（<a href="https://baike.baidu.com/item/SLA/2957862?fromModule=lemma_inlink">SLA</a>）直接通过网络向专门的提供商获取自己所需要的、带有相应软件功能的服务。 </p><h2 id="Saas平台的特点"><a href="#Saas平台的特点" class="headerlink" title="Saas平台的特点"></a>Saas平台的特点</h2><p><strong>可以使用先进的应用程序。</strong> 要向用户提供 SaaS 应用，无需购买、安装、更新或维护任何硬件、中间件或软件。SaaS让缺乏自行购买、部署和管理必需基础结构和软件所需资源的企业能够使用<a href="https://baike.baidu.com/item/ERP/22997?fromModule=lemma_inlink">ERP</a>和<a href="https://baike.baidu.com/item/CRM/165070?fromModule=lemma_inlink">CRM</a>等非常先进的企业应用程序。</p><p><strong>只为自己使用的东西付费。</strong>由于SaaS服务将根据使用水平自动扩展和收缩，还能节省费用。</p><p><strong>使用免客户端软件。</strong>用户可以从其Web浏览器直接运行大部分SaaS应用而无需下载和安装任何软件（部分应用需要插件）。这意味着无需为用户购买和安装特殊软件。</p><p><strong>轻松增强员工移动性。</strong>SaaS能够轻松增强员工“移动性”，因为用户可以从任何连接到 Internet 的计算机或移动设备访问SaaS应用和数据。无需考虑将应用开发为可在不同类型的计算机和设备上运行，因为服务提供商已经完成了这部分工作。此外，无需学习专业知识即可处理移动计算带来安全问题。无论使用数据的设备是什么类型，谨慎选择的服务提供商都将确保数据的安全。</p><p><strong>从任何位置访问应用数据。</strong>将数据存储到云后，用户即可通过任何连接到 Internet 的计算机或移动设备访问其信息。并且将应用数据存储到云后，用户的计算机或移动设备发生故障时不会丢失任何数据。</p><h2 id="SAAS平台架构分为哪些？"><a href="#SAAS平台架构分为哪些？" class="headerlink" title="SAAS平台架构分为哪些？"></a>SAAS平台架构分为哪些？</h2><h3 id="1、呈现层"><a href="#1、呈现层" class="headerlink" title="1、呈现层"></a>1、呈现层</h3><p>　　saas平台架构的呈现层可以使用的客户端可能都浏览器或本地客户端。如果是浏览器则需要Web界面技术、交互技术等技术(如：HTMl5技术、CSS3技术、Ajax技术等)的支持，如果是软件客户端则需要远程桌面技术、软件交互技术等技术支持。</p><h3 id="2、调度层"><a href="#2、调度层" class="headerlink" title="2、调度层"></a>2、调度层</h3><p>　　saas平台架构的调度层体现分布式系统的特性之一。调度层首先负责识别并通过AAA认证每个用户请求，然后根据业务处理器的负载、业务特征进行合理的调度。通过应用这样的架构SaaS平台可以横向扩展。此外在存储、缓存等方面为了满足平台的横向扩展需求，调度层也必须具有良好的可扩展性。</p><h3 id="3、业务层"><a href="#3、业务层" class="headerlink" title="3、业务层"></a>3、业务层</h3><p>　　saas平台架构的业务层负责接收调度层转发过来的请求，而且还要通过对接受到的请求执行真正的业务逻辑。一般来说业务逻辑的执行使用一台服务器就够了。因此业务层实际是由一排对等的服务器组成的，每台服务器都执行相同的业务逻辑。</p><h3 id="4、数据层"><a href="#4、数据层" class="headerlink" title="4、数据层"></a>4、数据层</h3><p>　　saas平台架构的数据库集群用于处理存储关系性很强并且对事务性要求很高的业务数据，这类数据目前还要用传统的数据库集群技术来解决，saas平台架构的数据库集群主要是根据业务特征制定数据拆分方案。同时分布式数据库用于存放海量但关系性不强的数据(如：用户的操作日志等)。</p><h2 id="SaaS产品的基本构成"><a href="#SaaS产品的基本构成" class="headerlink" title="SaaS产品的基本构成"></a>SaaS产品的基本构成</h2><p>一个SaaS产品通常由管理平台、租户实例、用户界面三个部分构成，分别对应SaaS产品的平台端、租户端、用户端三大功能模块。</p><img src="1672306672552_saas.png" alt="SaaS产品功能" style="zoom:67%;"><p>目前SaaS产品大多采用“Web+移动端”的用户端组合模式， 在使用体验上与普通的软件产品相似，使用者并不需要关心其是否SaaS系统。SaaS用户端又分为“隔离模式”和“互通模式”。</p><p>隔离模式：一个用户端只对应一个实例，不同实例之间完全隔离，不能互相切换(例如：WebOA、企业邮箱)。</p><img src="1672306162125_73.png" alt="1672306162140_73.png" style="zoom:67%;"><p>互通模式：同一用户端可关联多个实例，用户可在不同实例(企业)之间切换(例如：钉钉、企业微信)。</p><img src="1672306218900_74.png" alt="1672306218911_74.png" style="zoom:67%;"><p>SaaS产品由管理端进行角色权限配置和平台设置、用户管理、实例管理、数据管理等一系列操作。</p><p>用户端设置账号功能和业务化功能， 主要包括注册开通、登录， 实例切换和标准功能和定制化功能(按实例配置)。</p><p>租户端可以管理自身基本信息，如名称、Logo等，给予管理实例的操作账号和角色权限，可以管理租约，进行缴费和续费等操作。有具体的业务后台，可以查看相关的数据统计等。</p><p>持续完善…</p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.bilibili.com/read/cv18241782">一文看懂什么是SAAS平台 SAAS平台架构分为哪些？</a></p><p><a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1/8904485?fromtitle=SaaS&fromid=6703273&fr=aladdin">软件运营服务</a></p><p><a href="http://cd.itheima.com/news/20221229/174603.html">SaaS产品的基本构成及主要功能有哪些？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 业务架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Saas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析JWT</title>
      <link href="/2023/05/05/JWT/"/>
      <url>/2023/05/05/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析JWT"><a href="#浅析JWT" class="headerlink" title="浅析JWT"></a>浅析JWT</h1><p>随着移动互联网的兴起，传统基于session/cookie的web网站认证方式转变为了基于OAuth2等开放授权协议的单点登录模式（SSO），相应的基于服务器session+浏览器cookie的Auth手段也发生了转变，Json Web Token的出现成为了当前的热门的Token Auth机制。</p><blockquote><p>Cookie和Session相关概念请见博文：<a href="/maple/2023/05/05/Cookie-Session/">Cookie-Session</a></p></blockquote><h2 id="Json-Web-Token（JWT"><a href="#Json-Web-Token（JWT" class="headerlink" title="Json Web Token（JWT)"></a>Json Web Token（JWT)</h2><p>Json web token (JWT) 是目前最流行的跨域认证解决方案，JWT是一个开放标准 <a href="https://tools.ietf.org/html/rfc7519">(RFC 7519)</a>，它定义了一种紧凑且独立的方式，可以在客户端与服务器之间作为JSON对象安全地传输信息。</p><blockquote><p>官方定义：JSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties</p></blockquote><img src="jwt1.png" style="zoom:80%;"><p>现在网上大多数介绍JWT的文章实际介绍的都是JWS（JSON Web Signature），这也往往导致了大家对于JWT的误解，但是JWT并不等于JWS，JWS只是JWT的一种实现，除了JWS外，JWE（JSON Web Encryption）也是JWT的一种实现。</p><p>下面就来详细介绍一下JWS与JWE的两种实现方式：</p><h3 id="JSON-Web-Signature（JWS）"><a href="#JSON-Web-Signature（JWS）" class="headerlink" title="JSON Web Signature（JWS）"></a>JSON Web Signature（JWS）</h3><p>JSON Web Signature 是一个有着简单的统一表达形式的字符串。</p><img src="jwt2.png" style="zoom:60%;"><h4 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h4><p>头部用于描述关于该JWT的最基本的信息，例如：Token类型以及签名所用的算法等。</p><blockquote><p>JSON内容要经Base64 编码生成字符串才能成为Header。</p></blockquote><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;jwt&quot;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span> <span class="comment">//加密算法</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure><h4 id="载荷（PayLoad）"><a href="#载荷（PayLoad）" class="headerlink" title="载荷（PayLoad）"></a>载荷（PayLoad）</h4><p>payload的五个字段都是由JWT的标准所定义的。</p><ol><li>iss: 该JWT的签发者；</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方；</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的，即JWT生成的时间；</li></ol><p>还有一些其他的信息没有列举出来，也都是可以按需补充的。</p><blockquote><p>JSON内容要经Base64 编码生成字符串成为PayLoad。</p></blockquote><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Maple&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对其进行base64加密，得到JWT的第二部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ</span><br></pre></td></tr></table></figure><h4 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h4><p>这个部分是由base64加密后的header和base64加密后的payload，使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式，并使用密钥secret进行加密，生成签名。</p><p><strong>示例</strong></p><p>由上述base64加密的Header和PayLoad拼接并加密得到签名部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br></pre></td></tr></table></figure><p><strong>JWS的主要目的是保证了数据在传输过程中不被修改，验证数据的完整性。</strong></p><p>上述示例得到的完整的JWT整体格式为 <code>header.payload.signature</code> ，具体值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ.Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br></pre></td></tr></table></figure><h3 id="JSON-Web-Encryption（JWE）"><a href="#JSON-Web-Encryption（JWE）" class="headerlink" title="JSON Web Encryption（JWE）"></a>JSON Web Encryption（JWE）</h3><p>相对于JWS，JWE则同时保证了安全性与数据完整性。JWE由五部分组成：</p><img src="jwt3.png" style="zoom:80%;"><p>具体生成步骤为：</p><ol><li>JOSE含义与JWS头部相同。</li><li>生成一个随机的Content Encryption Key （CEK）。</li><li>使用RSAES-OAEP 加密算法，用公钥加密CEK，生成JWE Encrypted Key。</li><li>生成JWE初始化向量。</li><li>使用AES GCM加密算法对明文部分进行加密生成密文Ciphertext,算法会随之生成一个128位的认证标记Authentication Tag。</li><li>对五个部分分别进行base64编码。</li></ol><p>可见，JWE的计算过程相对繁琐，不够轻量级，因此适合数据传输而非token认证，但该协议也足够安全可靠，用简短字符串描述了传输内容，兼顾数据的安全性与完整性。</p><h2 id="JWT的使用"><a href="#JWT的使用" class="headerlink" title="JWT的使用"></a>JWT的使用</h2><blockquote><p>一般实际开发中说的JWT，实际上都是JWS，所以下述JWT默认就是JWS。</p></blockquote><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT?"></a>什么是JWT?</h3><p>json web token 通过<strong>数字签名</strong>的方法，以<strong>json对象</strong>为载体，在不同的服务器之间安全的传输信息。<br>简单来说：把信息进行安全的封装，以json的形式进行安全的网络传输。</p><h3 id="JWT的作用"><a href="#JWT的作用" class="headerlink" title="JWT的作用?"></a>JWT的作用?</h3><p>JWT最常见的场景就是<strong>授权认证</strong>，一旦用户进行了登录操作，服务端会返回一个JWT(token)给客户端，后续客户端的每个请求都在请求头中带上JWT(token)，系统在每次处理用户请求之前，都要先进行JWT安全校验，通过之后在进行处理。</p><p>用户在提交登录信息后，服务器校验数据后将通过密文的方式来生成一个字符串token返回给客户端，客户端在之后的请求会把token放在header里，在请求到达服务器后，服务器会检验和解密token，如果token被篡改或者失效将会拒绝请求，如果有效则服务器可以获得用户的相关信息并执行请求内容，最后将结果返回。</p><img src="jwt4.png" style="zoom:50%;"><h3 id="SpringCloud下如何使用JWT"><a href="#SpringCloud下如何使用JWT" class="headerlink" title="SpringCloud下如何使用JWT?"></a>SpringCloud下如何使用JWT?</h3><p>在微服务架构下,通常有单独一个服务Auth去管理相关认证，为了安全不会直接让用户访问某个服务，会开放一个入口服务作为网关gateway，所有请求首先访问gateway，由gateway将请求路由到各个服务，通常的做法在网关里进行请求拦截校验，来保证项目的安全性，下图是JWT在微服务中流程图（图中采用非对称加密算法，利用私钥在auth加密，公钥在网关gateway中解密，由此来减轻auth压力，此模型设计并不一定通用，架构设计主要根据实际场景和领域模型划分，可灵活设计并运用JWT）。</p><blockquote><p>针对非对称加密严格地说：公钥加密，私钥解密；私钥加签，公钥验签。</p></blockquote><img src="jwt5.png" style="zoom:80%;"><h2 id="关于JWT有效期与安全性"><a href="#关于JWT有效期与安全性" class="headerlink" title="关于JWT有效期与安全性"></a>关于JWT有效期与安全性</h2><p><strong>JWT如果使用不当，服务器如同裸奔~~~，在使用JWT是一定要注意。</strong></p><p>假如黑客监控电脑，抓包获取到JWT，伪造HTTP请求，对服务器是非常不安全的，常见的问题如下：</p><ul><li><strong>黑客修改HTTP中body的信息进行操作 - 篡改</strong>；<ul><li>修改body之后签名信息就不正确，然后就无法验证签名，说明数据被修改，数字签名的意义所在；</li></ul></li><li><strong>黑客伪造用户JWT进行访问和操作 - 伪造；</strong><ul><li>无法使用服务器的签名，所以在保证密钥不被泄露的情况下，不会被渗透；如果签名算法和秘钥泄露，那就是裸奔了；</li></ul></li><li><strong>黑客窃取JWT，模仿真实用户进行操作 - 冒充；</strong><ul><li>解决办法：<ul><li>对敏感api接口，采用https，https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。</li><li>或者在代码层面进行优化做安全检测：比如根据ip地址，设备码，一次性token机制，token时效期等措施来解决项目安全性问题等等</li></ul></li></ul></li></ul><h2 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此处只是一个Demo，在实际的开发中，还可以进行更个性化的封装，尤其是针对payload荷载部分，一般在开发中需要保存在JWT中的用户信息是一个POJO对象，而原生JWTBuilder中针对荷载部分的设置是使用 <code>claim()</code> 方法，用起来不是很方便，可以进行一个防腐层封装。</p><blockquote><p><strong>防腐层封装的个人思考</strong></p><p>JWT工具类的作用范围定位是全局，甚至是可以将其封装为一个基础的二方包，所以防腐层必须具有通用性，那么就不能使用POJO类型，因为无法确定需要支持的POJO的具体类型，可以考虑使用 Properties类型 、String类型、JSON串等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.lang.Collections;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;Maple&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     * 其中可选的参数是一些辅助性参数,在使用方可以用于一些校验.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> issuer    签发者|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject   JWT所面向的用户主体|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> audience  接收JWT的一方|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis 过期时间|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claimMap  载荷集合,就是需要加密的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String issuer, String subject, String audience, String key, <span class="type">long</span> ttlMillis, HashMap&lt;String, Object&gt; claimMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装自定义秘钥</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generateKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JWT自带的构造器构造一个jwt</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 封装header属性</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;AES&quot;</span>) <span class="comment">// 加密算法类型</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>) <span class="comment">// token类型</span></span><br><span class="line">                <span class="comment">// 封装payload属</span></span><br><span class="line">                .setId(UUID.randomUUID().toString()) <span class="comment">// JWT id,唯一标识</span></span><br><span class="line">                <span class="comment">// .setIssuer(issuer) // 签发者</span></span><br><span class="line">                <span class="comment">// .setSubject(subject) // 面向的用户主体</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// JWT创建时间</span></span><br><span class="line">                .setExpiration(now) <span class="comment">// JWT过期时间</span></span><br><span class="line">                .setAudience(audience) <span class="comment">// 接收JWT的一方</span></span><br><span class="line">                <span class="comment">// 构造signature部分</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装payload里的信息 使用claim方法</span></span><br><span class="line">        <span class="keyword">if</span> (!Collections.isEmpty(claimMap)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : claimMap.entrySet()) &#123;</span><br><span class="line">                builder.claim(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置JWT的过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (ttlMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">            builder.setExpiration(exp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt 待解析的JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Clamins, 即payload部分.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWTClaims</span><span class="params">(String key, String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parseJWT(key, jwt);</span><br><span class="line">        <span class="keyword">return</span> claimsJws.getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt 待解析的JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Jws&lt;Claims&gt;,包含Header,Clamins,Signature三个部分.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title function_">parseJWT</span><span class="params">(String key, String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generateKey(key);</span><br><span class="line">        <span class="comment">// 通过这个签名key对token进行解析</span></span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt);</span><br><span class="line">        <span class="keyword">return</span> claimsJws;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义字符串生成加密的秘钥|用于后续HS256加密加签.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title function_">generateKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringKey</span> <span class="operator">=</span> KEY_PREFIX + key;</span><br><span class="line">        <span class="comment">// base64 两种写法</span></span><br><span class="line">        <span class="type">byte</span>[] keySecretBytes = Base64.decodeBase64(stringKey);</span><br><span class="line">        <span class="comment">// byte[] keySecretBytes = DatatypeConverter.parseBase64Binary(stringKey);</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keySecretBytes, <span class="number">0</span>, keySecretBytes.length, SignatureAlgorithm.HS256.toString());</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Maple&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> createJWT(<span class="string">&quot;Maple&quot;</span>, <span class="string">&quot;Test&quot;</span>, <span class="string">&quot;Wuzi&quot;</span>, <span class="string">&quot;fjeoahgoeja&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>, map);</span><br><span class="line">  System.out.println(<span class="string">&quot;jwt = &quot;</span> + jwt);</span><br><span class="line">  Jws&lt;Claims&gt; claimsJws = parseJWT(<span class="string">&quot;fjeoahgoeja&quot;</span>, jwt);</span><br><span class="line">  System.out.println(claimsJws.getHeader().getAlgorithm());</span><br><span class="line">  System.out.println(claimsJws.getBody().getExpiration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwt = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ.Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br><span class="line">HS256</span><br><span class="line">Fri May 05 15:32:54 CST 2023</span><br></pre></td></tr></table></figure><p><font color="#dd0000"><strong>JWT的生成特点：可以重复请求，每次请求都会生成一个新的JWT，旧JWT依旧有效。</strong></font></p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.jianshu.com/p/50ade6f2e4fd">一篇文章带你分清楚JWT,JWS与JWE</a></p><p><a href="https://blog.csdn.net/han1725692339/article/details/126014021">JWT技术简介和使用</a></p><p><a href="https://blog.csdn.net/qq_40162735/article/details/105752127">JWT在微服务系统中的如何应用，如何保证安全性？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> 令牌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie &amp; Session</title>
      <link href="/2023/05/05/Cookie-Session/"/>
      <url>/2023/05/05/Cookie-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h1><p>Cookie和Session都是用来在浏览器中跟踪用户身份的会话方式，因为B to S的请求访问都是HTTP请求，而HTTP请求是无状态的，服务器端无法辨识请求是来自哪个客户端。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是一段保存在客户端的<strong>字符串</strong>，能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪用户的状态，一般一个 cookie存储的数据不超过3K。</p><h3 id="Cookie的工作原理："><a href="#Cookie的工作原理：" class="headerlink" title="Cookie的工作原理："></a>Cookie的工作原理：</h3><ol><li>浏览器第一次发送请求到浏览器端；</li><li>服务器端创建一个字符串Cookie，该Cookie中包含用户的信息，然后将该Cookie返回给浏览器端；</li><li>浏览器端再次访问服务器端时会在请求头中携带从服务器端获取的Cookie字符串；</li><li>服务器端通过Cookie中携带的数据便可以区分不同的用户；</li></ol><p>访问百度网站中浏览器中的Cookie示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cookie</span>:<span class="variable constant_">BIDUPSID</span>=7CA7EB951E290B33CA40110D9ED9C0D1; <span class="variable constant_">PSTM</span>=<span class="number">1587792871</span>; <span class="variable constant_">BD_UPN</span>=<span class="number">123253</span>;__yjs_duid=1_9d2ad8f9e190a6d780bbc7d44cd4d11c1620624931104; <span class="variable constant_">BAIDUID</span>=<span class="title class_">BE455C</span>05128<span class="attr">F1594C731E5B0B822F103</span>:<span class="variable constant_">SL</span>=<span class="number">0</span>:<span class="variable constant_">NR</span>=<span class="number">10</span>:<span class="variable constant_">FG</span>=<span class="number">1</span>;...</span><br></pre></td></tr></table></figure><p>PS：字符串很长，后面的省略了。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session是存储在服务器（应用服务器）上的<strong>对象</strong>，该对象由服务器创建并维护，Session存储的数据大小没有限制，服务器会为客户端与服务器的每一次会话过程都创建并维护一个Session对象。</p><h3 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h3><ol><li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session对象，同时会创建一个特殊的Cookie（是随机生成的一个标识Session对象的一个SessionId字符串），然后将该Cookie发送至浏览器端；</li><li>浏览器端发送第N（N&gt;1）次请求到服务器端，浏览器端访问服务器端的时候会在请求头中携带Cookie对象；</li><li>服务器端会根据Cookie的值去查询Session对象，从而区分不同的用户；</li></ol><p>简单的说，当你登陆一个网站的时候，如果web服务器端使用的是Session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话Sessionid（以Cookie的方式，Sessionid是服务器和客户端连接时候随机分配的），服务器根据当前Sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以客户端是无法伪造的。</p><p>如果浏览器使用的是Cookie，那么用户的所有数据都保存在浏览器端，比如：登陆以后，服务器设置了Cookie用户名，那么当再次请求服务器的时候，浏览器会将用户名一起发送给服务器，服务器会解析Cookie变量，所以只要不关闭浏览器，那么Cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的Cookie变量，然后伪造一个数据包发送过去，那么服务器会认为你是合法的。所以，使用Cookie被攻击的可能性比较大。</p><p>如果Cookie设置了有效期，那么Cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有Cookie，如果有的话，读取Cookie并发送给服务器。所以，如果你在个人PC上面保存了某个论坛Cookie，有效期是一年，如果有人入侵你的PC，将Cookie拷走，放在他的机器下面，那么他登陆该网站的时候就是用你的身份登陆的。当然，伪造的时候需要注意，直接Copy Cookie文件到 Cookie目录，浏览器是不认的，它有一个<code>index.dat</code> 文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 Cookie文件，并且要从保证时间上骗过浏览器。</p><p>两个都可以用来存用户数据，Session过期与否，取决于服务器的设定。Cookie过期与否，可以在Cookie生成的时候设置进去。</p><h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><h3 id="1、目标对象不同"><a href="#1、目标对象不同" class="headerlink" title="1、目标对象不同"></a>1、目标对象不同</h3><p><strong>Cookie</strong>：是针对每个网站的信息，每个网站只能对应一个，其他网站无法访问，这个文件保存在客户端，每次访问相应网站，浏览器都会查找该网站的 Cookies，如果有，则会将该文件发送出去。Cookies文件的内容大致上包括了诸如：用户名、密码、设置等信息。</p><p><strong>Session</strong>：是针对每个用户的，只有客户端才能访问，程序为该客户添加一个 Session。Session中主要保存用户的登录信息、操作信息等等。此 Session将在用户访问结束后自动消失。</p><h3 id="2、存储数据大小不同"><a href="#2、存储数据大小不同" class="headerlink" title="2、存储数据大小不同"></a>2、存储数据大小不同</h3><p><strong>Cookie</strong>：一个 Cookie存储的数据不超过3K。</p><p><strong>Session</strong>：Session存储在服务器上可以任意存储数据，当 Session存储数据太多时，服务器可选择进行清理。</p><h3 id="3、生命周期不同"><a href="#3、生命周期不同" class="headerlink" title="3、生命周期不同"></a>3、生命周期不同</h3><p><strong>Cookie</strong>：Cookie的生命周期当浏览器关闭的时候就消亡了，Cookie的生命周期是累计的，从创建时就开始计时，默认30min后Cookie生命周期结束，当然了，用户可以自定义有效时间。</p><p><strong>Session</strong>：Session的生命周期是间隔的，JSESSIONID的Cookie默认过期时间为-1，只需关闭浏览器当前窗口，该Session就会失效，因此Session不能长期有效。</p><h3 id="4、存储位置不同"><a href="#4、存储位置不同" class="headerlink" title="4、存储位置不同"></a>4、存储位置不同</h3><p><strong>Cookie</strong>：Cookie数据保存在客户端，不占用服务器资源。</p><p><strong>Session</strong>：Session数据保存在服务器端，如果数量过多很消耗大量内存空间。</p><h3 id="5、数据类型不同"><a href="#5、数据类型不同" class="headerlink" title="5、数据类型不同"></a>5、数据类型不同</h3><p>两者都是key-value结构，但针对value的类型是有差异的。</p><p><strong>Cookie</strong>：key是固定值：”Cookie”，value只能是ASCII字符串类型。</p><p><strong>Session</strong>：key是SessionId（名为JSESSIONID的一个Cookie），value是object类型。</p><h3 id="6、安全性不同"><a href="#6、安全性不同" class="headerlink" title="6、安全性不同"></a>6、安全性不同</h3><p>Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用Session。</p><h3 id="7、跨域支持"><a href="#7、跨域支持" class="headerlink" title="7、跨域支持"></a>7、跨域支持</h3><p>Cookie支持跨域访问；Session不支持跨域访问。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://worktile.com/kb/ask/28045.html">cookie与session区别</a></p><p><a href="https://blog.csdn.net/m0_65421722/article/details/127813102">Cookie和session的区别</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 1」-- 初识Sentinel &amp; Sentinel-Dashboard</title>
      <link href="/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/"/>
      <url>/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Sentinel-amp-Sentinle-Dashboard"><a href="#初识Sentinel-amp-Sentinle-Dashboard" class="headerlink" title="初识Sentinel &amp; Sentinle-Dashboard"></a>初识Sentinel &amp; Sentinle-Dashboard</h1><h2 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h2><h3 id="认识Sentinel"><a href="#认识Sentinel" class="headerlink" title="认识Sentinel"></a>认识Sentinel</h3><blockquote><p>官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p></blockquote><p><strong>Sentinel 具有以下特征:</strong></p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。只要是通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。常见的，可以使用方法签名，URL，甚至服务名称作为资源名来标识资源。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel可提供包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h2 id="Sentinel-功能和设计理念"><a href="#Sentinel-功能和设计理念" class="headerlink" title="Sentinel 功能和设计理念"></a>Sentinel 功能和设计理念</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><img src="sentinel1.png" style="zoom:40%;"><p>流量控制有以下几个角度:</p><ul><li><strong>资源的调用关系</strong>，例如：资源的调用链路，资源和资源之间的关系；</li><li><strong>运行指标</strong>，例如： QPS、线程池、系统负载等；</li><li><strong>控制的效果</strong>，例如：直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><h4 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h4><p>除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 <a href="https://github.com/Netflix/Hystrix/wiki#what-problem-does-hystrix-solve">Hystrix</a> 里面描述的问题是一样的。</p><img src="sentinel2.png" alt="sentinel2" style="zoom:40%;"><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，慢响应比例升高，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生服务雪崩。</p><blockquote><p><strong>服务雪崩</strong></p><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是服务雪崩。</p><p><strong>服务雪崩解决方案</strong></p><ul><li><strong>超时处理</strong>：设定资源请求的超时时间，请求时间超过阈值没有响应就返回错误信息，不会无休止等待。<ul><li>此种方式并不能从根本上解决问题，如果在超时之前有大量请求进来还是会造成请求堆积，仍然有节点崩溃的风险。而且超时时间的阈值不好确定，只能根据监控的RT统计数据给出一个相对合适的阈值。</li><li>个人理解：此方案只能适用于一些简单并且低流量的系统出现弱网或者网络抖动的场景；</li></ul></li><li><strong>线程隔离（也称为 舱壁模式）</strong>：常见的有两种实现为 <strong>线程池隔离</strong> 和 <strong>信号量隔离</strong>。<ul><li><strong>线程池隔离（Hystrix）</strong>：每个业务资源单独创建并分配一个线程池，将对业务资源的访问限制在线程池内，即使出现异常，最终也只是导致该线程池阻塞，不会影响其他业务资源。<ul><li>优点<ul><li>实现每个业务的完全隔离；</li><li>支持主动超时，即线程池中某个线程执行时间过长，可以主动关闭该线程；</li><li>支持异步调用，即利用线程池的异步特性实现异步调用；</li></ul></li><li>缺点：线程上下文的切换会消耗服务器的资源，极端情况下，服务器的CPU利用率飙升，但是处理能力却反而下降，因为服务器在忙着进行线程的上下文切换，而不是在执行业务。</li><li>场景：适合低扇出场景，即当前服务依赖的其他服务数量少，这样需要创建的线程池数量就少；</li></ul></li><li><strong>信号量隔离（Sentinel）</strong>：内部维护一个计数器，对每个调用的依赖服务的线程数进行统计，限制对依赖方的并发调用线程数；<ul><li>优点：轻量级，无额外开销；</li><li>缺点：<ul><li>不支持主动超时，信号量仅仅是一道控制开关的闸门，请求放行之后就无法控制了，请求的超时时间只能依赖RPC框架；</li><li>不支持异步调用，没有独立线程，无法实现异步调用；</li></ul></li><li>场景：适合高频调用、高扇出场景；</li></ul></li></ul></li><li><strong>熔断降级</strong>：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。<ul><li>内部会维护一个断路器，对单位时间内的业务执行异常比例、错误数量、慢调用比例等进行统计，并结合状态机模式实现断路器状态之间的切换，从而实现对目标场景的熔断降级。</li></ul></li><li><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。<ul><li>是一种<strong>故障预防</strong>方案。</li></ul></li></ul></blockquote><h4 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h4><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>（也称为 舱壁模式）的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（Java的线程映射LWP，所以Java的线程切换意味着用户态到内核态的切换和操作系统的线程调度，是一种很重的操作，会影响服务器的性能），还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li><strong>通过并发线程数进行限制</strong></li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，例如：响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li><strong>通过响应时间对资源进行降级</strong></li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h3 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h3><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2 id="Sentinel-是如何工作的"><a href="#Sentinel-是如何工作的" class="headerlink" title="Sentinel 是如何工作的"></a>Sentinel 是如何工作的</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:</p><ul><li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li><li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如：该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li><li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li><li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li><li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li><li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li><li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li></ul><p>总体的框架如下:</p><img src="sentinel3.png" style="zoom:80%;"><p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p><p>下面介绍一下各个 slot 的功能。</p><h3 id="NodeSelectorSlot"><a href="#NodeSelectorSlot" class="headerlink" title="NodeSelectorSlot"></a>NodeSelectorSlot</h3><p>这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ContextUtil.enter(<span class="string">&quot;entrance1&quot;</span>, <span class="string">&quot;appA&quot;</span>);</span><br><span class="line"><span class="type">Entry</span> <span class="variable">nodeA</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;nodeA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeA != <span class="literal">null</span>) &#123;</span><br><span class="line">   nodeA.exit();</span><br><span class="line">&#125;</span><br><span class="line">ContextUtil.exit();</span><br></pre></td></tr></table></figure><p>上述代码通过 <code>ContextUtil.enter()</code> 创建了一个名为 <code>entrance1</code> 的上下文，同时指定调用发起者为 <code>appA</code>；接着通过 <code>SphU.entry()</code>请求一个 token，如果该方法顺利执行没有抛 <code>BlockException</code>，表明 token 请求成功。</p><p>以上代码将在内存中生成以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> machine-root</span><br><span class="line">           /     </span><br><span class="line">          /</span><br><span class="line">   EntranceNode1</span><br><span class="line">        /</span><br><span class="line">       /   </span><br><span class="line">DefaultNode(nodeA)</span><br></pre></td></tr></table></figure><p>注意：每个 <code>DefaultNode</code> 由资源 ID 和输入名称来标识。换句话说，一个资源 ID 可以有多个不同入口的 DefaultNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ContextUtil.enter(<span class="string">&quot;entrance1&quot;</span>, <span class="string">&quot;appA&quot;</span>);</span><br><span class="line"><span class="type">Entry</span> <span class="variable">nodeA</span> <span class="operator">=</span> SphU.entry(<span class="string">&quot;nodeA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeA != <span class="literal">null</span>) &#123;</span><br><span class="line">  nodeA.exit();</span><br><span class="line">&#125;</span><br><span class="line">ContextUtil.exit();</span><br><span class="line"></span><br><span class="line">ContextUtil.enter(<span class="string">&quot;entrance2&quot;</span>, <span class="string">&quot;appA&quot;</span>);</span><br><span class="line">nodeA = SphU.entry(<span class="string">&quot;nodeA&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (nodeA != <span class="literal">null</span>) &#123;</span><br><span class="line">  nodeA.exit();</span><br><span class="line">&#125;</span><br><span class="line">ContextUtil.exit();</span><br></pre></td></tr></table></figure><p>以上代码将在内存中生成以下结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            machine-root</span><br><span class="line">            /         \</span><br><span class="line">           /           \</span><br><span class="line">   EntranceNode1   EntranceNode2</span><br><span class="line">         /               \</span><br><span class="line">        /                 \</span><br><span class="line">DefaultNode(nodeA)   DefaultNode(nodeA)</span><br></pre></td></tr></table></figure><p>上面的结构可以通过调用 <code>curl http://localhost:8719/tree?type=root</code> 来显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EntranceNode: machine-root(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">-EntranceNode1: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">-EntranceNode2: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line">--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)</span><br><span class="line"></span><br><span class="line">t:threadNum  pq:passQps  bq:blockedQps  tq:totalQps  rt:averageRt  prq: passRequestQps 1mp:1m-passed 1mb:1m-blocked 1mt:1m-total</span><br></pre></td></tr></table></figure><h3 id="ClusterBuilderSlot"><a href="#ClusterBuilderSlot" class="headerlink" title="ClusterBuilderSlot"></a>ClusterBuilderSlot</h3><p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。可通过如下命令查看某个资源不同调用者的访问情况：<code>curl http://localhost:8719/origin?id=caller</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id: nodeA</span><br><span class="line">idx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total </span><br><span class="line">1   caller1 0         0         0          0        0     0         0          0        </span><br><span class="line">2   caller2 0         0         0          0        0     0         0          0        </span><br></pre></td></tr></table></figure><h3 id="StatisticSlot"><a href="#StatisticSlot" class="headerlink" title="StatisticSlot"></a>StatisticSlot</h3><p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p><ul><li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li><li><code>origin</code>：根据来自不同调用者的统计信息</li><li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li><li>入口的统计</li></ul><p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p><img src="51955215-0af7c500-247e-11e9-8895-9fc0e4c10c8c.png" alt="sliding-window-leap-array" style="zoom: 50%;"><h3 id="FlowSlot"><a href="#FlowSlot" class="headerlink" title="FlowSlot"></a>FlowSlot</h3><p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p><ul><li>指定应用生效的规则，即针对调用方限流的；</li><li>调用方为 other 的规则；</li><li>调用方为 default 的规则。</li></ul><h3 id="DegradeSlot"><a href="#DegradeSlot" class="headerlink" title="DegradeSlot"></a>DegradeSlot</h3><p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p><h3 id="SystemSlot"><a href="#SystemSlot" class="headerlink" title="SystemSlot"></a>SystemSlot</h3><p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p><p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p><blockquote><p><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90">Sentinel 核心类解析</a></p></blockquote><h2 id="服务保护框架对比"><a href="#服务保护框架对比" class="headerlink" title="服务保护框架对比"></a>服务保护框架对比</h2><p>常见的服务保护框架有：Sentinel 和 Hystrix（已经停止更新维护，从GitHub上看最后一次维护代码都是5、6年前了）</p><table><thead><tr><th>核心对比点</th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td><font color="#dd0000"><strong>隔离策略</strong></font></td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td><font color="#dd0000"><strong>熔断降级策略</strong></font></td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td><font color="#dd0000"><strong>限流</strong></font></td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td><font color="#dd0000"><strong>流量整形</strong></font></td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td><font color="#dd0000"><strong>控制台</strong></font></td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><blockquote><p>流量整形：将波动的请求流量整形为均匀的流量，避免尖峰流量对服务器的冲击。</p></blockquote><h2 id="Sentinel-Dashboard"><a href="#Sentinel-Dashboard" class="headerlink" title="Sentinel-Dashboard"></a>Sentinel-Dashboard</h2><p>Sentinel 控制台启动方式有两种：</p><ul><li>Sentinel官网提供了现成的sentinel-dashboard.jar包，down下来，通过<code>java -jar sentinel-dashboard.jar</code> 命令即可启动，默认端口为<code>8080；</code></li><li>下载Sentinel的源码，其中有Sentinel-Dashboard模块，使用Maven的<code>package</code> 命令打包，同样使用<code>java -jar xxx</code> 就可启动；</li></ul><p>启动之后，访问<code>localhost:8080</code>，进入Sentinel Dashboard界面，默认鉴权，账号和密码都为： sentinel</p><img src="dashboard1.png" style="zoom:40%;"><p>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar -Dserver.port=8090</span><br></pre></td></tr></table></figure><p>登录之后的主界面如下：</p><p><img src="dashboard2.png"></p><p>注：</p><ul><li>Sentinel 控制台需要有目标资源被调用，才会展示资源的相关配置模块，如果没有调用请求，控制台没有显示的。如上图中的<code>orderservice</code>就是因为已经有调用过该应用资源才会展示。</li><li>其中的流控规则-NACOS是利用Nacos作为注册中心对Sentinel的流控规则进行持久化的模块，需要对Sentinel源码进行修改。</li></ul><h2 id="控制台功能"><a href="#控制台功能" class="headerlink" title="控制台功能"></a>控制台功能</h2><p>根据上图可以清楚的看出Sentinel控制台提供的能力，本文结合个人实际开发中常用的一些功能模块进行介绍。</p><ul><li>实时监控</li><li>簇点链路</li><li>流控规则（嵌入后续对应模块中）</li><li>降级规则（嵌入后续对应模块中）</li><li>热点规则（嵌入后续对应模块中）</li><li>授权规则（嵌入后续对应模块中）</li></ul><h3 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h3><p>实时监控模块可以进行秒级的实时统计并展示。</p><p><img src="dashboard3.png"></p><h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>簇点链路就是项目内的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><p><img src="dashboard4.png"></p><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防盗链</title>
      <link href="/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/"/>
      <url>/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h1><h2 id="防盗链的定义"><a href="#防盗链的定义" class="headerlink" title="防盗链的定义"></a>防盗链的定义</h2><p><strong>防盗链</strong>其实就是在网络服务器端进行个性化编程，通过URL过滤技术实现对目标资源控制访问。</p><p><strong>比如：</strong></p><p><code>file.maple.com/test.jpg</code>这个图片地址，如果没有装防盗链，那么任意用户都能通过该URL轻而易举的在他的网站上引用这个图片。如果对<code>file.maple.com</code> 这个地址进行服务器端编程，如给URL拼接参数，得到<code>file.maple.com/test.jpg?authcode=xxx&amp;ip=127.0.0.1</code>，自动拼接了ip参数，然后在对URL路由时针对IP参数进行个性化判断，就能实现只有<code>127.0.0.1</code>来访问这个链接，而其它的IP地址则无法访问该链接。</p><h2 id="防盗链的产生"><a href="#防盗链的产生" class="headerlink" title="防盗链的产生"></a>防盗链的产生</h2><p>一般我们在浏览网页时，一个完整的页面并不是客户端通过一次HTTP请求就将全部资源从服务器上拉取下来的，而是会分成很多次HTTP请求。如果客户端所浏览的页面带有图片或其它功能性信息，那么客户端的第一个HTTP请求就是想资源服务器端请求这个页面的文本信息，然后通过客户端的浏览器对服务器返回的数据进行解析，如果发现其中包含图片地址URL，那么客户端的浏览器会自动针对该图片URL再一次发送HTTP请求去获取目标图片并将其放置到目标位置，就这样一个完整的网络页面内部经过多次HTTP请求才能完整的展现出来。</p><p>基于此机制，就会产生盗链的问题。</p><blockquote><p><strong>个人理解</strong></p><p>盗链：全称应该是 盗取网络链接地址。</p></blockquote><p>如果一个网站中没有其页面中的图片信息，那么它完全可以链接访问到其他网站的图片信息。这样，没有任何资源的网站利用了其他网站的资源来展示给浏览者，提高了自己站点的访问量，而大部分浏览者又不会很容易地发现内部资源的调用过程，这样显然对于那些被利用了资源的网站是不公平的。一些不良网站为了不增加成本而扩充自己站点内容，经常盗用其他网站的链接。</p><h2 id="防盗链的实现"><a href="#防盗链的实现" class="headerlink" title="防盗链的实现"></a>防盗链的实现</h2><p>要实现防盗链，首先要理解盗链的实现原理，提到防盗链的实现原理就不得不从HTTP协议说起，在HTTP协议中，有一个表头字段叫 <code>referer</code>，其采用URL的格式来表示从哪儿链接到当前的网页或文件。换句话说，通过referer，网站可以检测到目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。有了<code>referer</code>跟踪来源就好办了，这时就可以通过技术手段来进行处理，一旦检测到来源不是期望的URL地址，那么就进行拦截或者返回降级页面和资源。 </p><p><strong>HTTP Headerss示例</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:authority: g.csdnimg.cn</span><br><span class="line">:method: GET</span><br><span class="line">:path: /static/logo/favicon32.ico</span><br><span class="line">:scheme: https</span><br><span class="line">accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">if-modified-since: Mon, 24 Apr 2023 09:23:28 GMT</span><br><span class="line">if-none-match: &quot;64464a90-10be&quot;</span><br><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?1</span><br><span class="line">sec-ch-ua-platform: &quot;Android&quot;</span><br><span class="line">sec-fetch-dest: image</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36</span><br></pre></td></tr></table></figure><p>其中refer为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br></pre></td></tr></table></figure><p>如果想对自己的网站进行防盗链保护，需要针对不同的情况进行区别对待。如果网站服务器用的是apache，那么使用apache自带Url Rewrite插件就可以很轻松实现各种防盗链，其原理是检查HTTP请求头中的refer属性值，如果refer的信息来自非目标站点则重定向到指定图片或网页上。还有很多其他的防盗链实现机制，总体上都换汤不换药，都是基于<code>refer</code>属性值进行个性化过滤。</p><hr><p><strong>参考文档：</strong></p><p><a href="http://www.zzbaike.com/wiki/%E9%98%B2%E7%9B%97%E9%93%BE">防盗链</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 协议</title>
      <link href="/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2-0协议"><a href="#OAuth2-0协议" class="headerlink" title="OAuth2.0协议"></a><strong>OAuth2.0协议</strong></h1><h2 id="OAuth2-0-为何物"><a href="#OAuth2-0-为何物" class="headerlink" title="OAuth2.0 为何物"></a><strong>OAuth2.0 为何物</strong></h2><p>OAuth 简单理解就是一种授权机制，它是在客户端和资源所有者之间的授权层，用来分离两种不同的角色。在资源所有者同意并向客户端颁发令牌后，客户端携带令牌就可以访问资源所有者的资源。</p><blockquote><p>OAuth2.0 是OAuth 协议的一个版本，有2.0版本那就有1.0版本，有意思的是OAuth2.0 却不向下兼容OAuth1.0 ，相当于废弃了1.0版本。</p></blockquote><p>举个小栗子解释一下什么是 OAuth 授权？</p><p>订了个外卖，外卖小哥30秒火速到达了我家楼下，奈何有门禁进不来，可以输入密码进入，但出于安全考虑我并不想告诉他密码。此时外卖小哥看到门禁有一个高级按钮“一键获取授权”，只要我这边同意，他会获取到一个有效期 2小时的令牌（token）正常出入。</p><p><strong><font color="cornflowerblue">令牌（token）和 密码 的作用虽然相似都可以进入系统，但还有点不同。token 拥有权限范围，有时效性的，到期自动失效，而且修改无效。</font></strong></p><p><strong>OAuth2.0中有四个重要角色：</strong></p><table><thead><tr><th align="center">角色</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong><font color="red">客户端</font></strong></td><td align="center">本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，常见的就是用户常用的各种客户端，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</td></tr><tr><td align="center"><strong><font color="red">资源拥有者</font></strong></td><td align="center">通常为用户，也可以是应用程序，即该资源的拥有者。</td></tr><tr><td align="center"><strong><font color="red">授权服务器（也称认证服务器）</font></strong></td><td align="center">用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌 （access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。</td></tr><tr><td align="center"><strong><font color="red">资源服务器</font></strong></td><td align="center">存储资源拥有者所拥有的资源的服务器，比如：微信侧存储的用户信息。</td></tr></tbody></table><p><strong>拿微信授权其他平台登录为例，该角色在流程中对应关系如下：</strong></p><img src="auth1.png" style="zoom: 30%;"><h2 id="OAuth2-0-授权方式"><a href="#OAuth2-0-授权方式" class="headerlink" title="OAuth2.0 授权方式"></a><strong>OAuth2.0 授权方式</strong></h2><p>OAuth2.0 的授权简单理解其实就是获取令牌（token）的过程，OAuth 协议定义了四种获得令牌的授权方式（authorization grant ）如下：</p><ul><li><strong>授权码</strong>（authorization-code）</li><li>**隐藏式 **（implicit）</li><li><strong>密码式</strong> （password）</li><li><strong>客户端凭证</strong>（client credentials）</li></ul><p>但值得注意的是，不管我们使用哪一种授权方式，在三方应用申请令牌之前，都必须在系统中去申请身份唯一标识：客户端 ID（client ID）和 客户端密钥（client secret）。这样做可以保证 token 不被恶意使用。</p><p>下面我们会分析每种授权方式的原理，在进入正题前，先了解 OAuth2.0 授权过程中几个重要的参数：</p><ul><li>response_type：code 表示要求返回授权码，token 表示直接返回令牌；</li><li>client_id：客户端身份标识；</li><li>client_secret：客户端密钥；</li><li>redirect_uri：重定向地址（用户同意授权之后，三方应用将返回的信息带回时调用的重定向地址，passport-third中三方登录接口的cap地址）；</li><li>scope：表示授权的范围，read只读权限，all读写权限；</li><li>grant_type：表示授权的方式，AUTHORIZATION_CODE（授权码）、password（密码）、client_credentials（凭证式）、refresh_token 更新令牌；</li><li>state：应用程序传递的一个随机数，用来防止CSRF攻击；</li></ul><blockquote><p>CSRF攻击 | 跨站请求伪造</p><p><a href="https://zhuanlan.zhihu.com/p/22521378">CSRF是什么？</a></p></blockquote><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a><strong>授权码</strong></h3><p>OAuth2.0四种授权中授权码方式是最为复杂，但也是安全系数最高的，比较常用的一种方式。这种模式是<strong>四种模式中最安全的一种模式</strong>。一般用于Web服务器端应用或第三方的原生App调用资源服务的时候。适用于兼具前后端的Web项目，因为有些项目只有后端或只有前端，并不适用授权码模式。</p><p>下图我们以用WX登录掘金为例，详细看一下授权码方式的整体流程。</p><img src="auth2.png" style="zoom:80%;"><p>用户选择WX登录掘金，掘金会向WX发起授权请求，接下来 WX询问用户是否同意授权（常见的弹窗授权）。response_type 为 code 要求返回授权码，scope 参数表示本次授权范围为只读权限，redirect_uri 重定向地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=code&amp;  client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  scope=read</span></span><br></pre></td></tr></table></figure><p>用户同意授权后，WX 根据 redirect_uri重定向并带上授权码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//juejin.im/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>当掘金拿到授权码（code）时，带授权码和密匙等参数向WX申请令牌。grant_type表示本次授权为授权码方式 authorization_code ，获取令牌要带上客户端密匙 client_secret，和上一步得到的授权码 code。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; </span></span><br><span class="line">grant_type=authorization_code&amp; code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp; redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback</span></span><br></pre></td></tr></table></figure><p>最后 WX 收到请求后向 redirect_uri 地址发送 JSON 数据，其中的access_token 就是令牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;ACCESS_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">2592000</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;REFRESH_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="string">&quot;read&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  ...... </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Q：OAuth 2.0为什么不直接返回access_token?要设定为返回auth_code之后再去请求accessToken？</strong></p><p>主要出于安全方考虑，防止中间人攻击。假设第三方应用、授权服务不直接通信，中间隔了一层代理。且第三方应用采用HTTP协议，这样恶意代理就能窃取access token。因此，采用了通过code来交换access token的方式，来增加安全性。并且不能将access_token直接给到用户侧，相对于用户侧网络环境的复杂性，第三方应用自身服务端的网络环境相对更安全。</p><p>特别注意：对于授权码和access_token的篡改，在OAuth 1.0中是反复的对Code和Token进行签名，来保证Token不会被篡改，但是OAuth 2.0中却没有，因为OAuth 2.0是基于Https的，所以如果没有Https的支持OAuth 2.0可能还不如OAuth 1.0。在 OAuth 2.0 中，使用 HTTPS 可以说是必须的，而且 client 有义务验证证书的真假，防止中间人攻击，而 authorization server 和 resource server 都有义务申请可信任的第三方颁发的真实的 SSL 证书。</p></blockquote><h3 id="隐藏式（简化模式）"><a href="#隐藏式（简化模式）" class="headerlink" title="隐藏式（简化模式）"></a><strong>隐藏式（简化模式）</strong></h3><p>授权码模式：</p><img src="auth3.png" style="zoom:50%;"><p>简化版的授权码模式，跳过临时授权码的环节，只要用户一点击授权，就能直接返回access_token，而不是通过授权码code再次去获取。</p><img src="auth4.png" style="zoom:50%;"><blockquote><p>参数描述同授权码模式 ，注意response_type=token，说明是简化模式。</p></blockquote><p>上边提到有一些Web应用是没有后端的， 属于纯前端应用，无法用上边的授权码模式。令牌的申请与存储都需要在前端完成，跳过了授权码这一步。</p><p>前端应用直接获取 token，response_type 设置为 token，要求直接返回令牌，跳过授权码，WX授权通过后重定向到指定 redirect_uri 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?response_type=token&amp;  </span></span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  scope=read</span></span><br></pre></td></tr></table></figure><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a><strong>密码式</strong></h3><img src="auth5.png" style="zoom: 25%;"><p>密码模式比较好理解，用户在掘金直接输入自己的WX用户名和密码，掘金拿着信息直接去WX申请令牌，请求响应的 JSON结果中返回 token。grant_type 为 password 表示密码式授权。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?grant_type=password&amp;  </span></span><br><span class="line">username=<span class="variable constant_">USERNAME</span>&amp;password=<span class="variable constant_">PASSWORD</span>&amp;client_id=<span class="variable constant_">CLIENT_ID</span></span><br></pre></td></tr></table></figure><p>这种授权方式简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下，或者第一方原生APP或第一方单页面应用。</p><h3 id="客户端凭证式"><a href="#客户端凭证式" class="headerlink" title="客户端凭证式"></a><strong>客户端凭证式</strong></h3><img src="auth6.png" style="zoom:25%;"><p>凭证式和密码式很相似，主要适用于那些没有前端的命令行应用，可以用最简单的方式获取令牌，在请求响应的 JSON 结果中返回 token。</p><p>grant_type 为 client_credentials 表示凭证式授权，client_id 和 client_secret 用来识别身份。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?grant_type=client_credentials&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET</span></span><br></pre></td></tr></table></figure><h2 id="令牌的使用与更新"><a href="#令牌的使用与更新" class="headerlink" title="令牌的使用与更新"></a><strong>令牌的使用与更新</strong></h2><h3 id="1、令牌怎么用？"><a href="#1、令牌怎么用？" class="headerlink" title="1、令牌怎么用？"></a><strong>1、令牌怎么用？</strong></h3><p>拿到令牌可以调用 WX API 请求数据了，那令牌该怎么用呢？</p><p>每个到达WX的请求都必须带上 token，将 token 放在 http 请求头部的一个Authorization字段里。</p><p>如果使用postman 模拟请求，要在Authorization -&gt; Bearer Token 放入 token，注意：低版本postman 没有这个选项。</p><p><img src="auth7.png"></p><h3 id="2、令牌过期怎么办？"><a href="#2、令牌过期怎么办？" class="headerlink" title="2、令牌过期怎么办？"></a><strong>2、令牌过期怎么办？</strong></h3><p>token是有时效性的，一旦过期就需要重新获取，但是重走一遍授权流程，不仅麻烦而且用户体验也不好，那如何让更新令牌变得优雅一点呢？</p><p>一般在颁发令牌时会一次发两个令牌，一个令牌用来请求API，另一个负责更新令牌 refresh_token。grant_type 为 refresh_token 请求为更新令牌，参数 refresh_token 是用于更新令牌的令牌。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token?grant_type=refresh_token&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp; refresh_token=REFRESH_TOKEN</span></span><br></pre></td></tr></table></figure><h3 id="3、令牌的维护"><a href="#3、令牌的维护" class="headerlink" title="3、令牌的维护"></a>3、令牌的维护</h3><p>因为各大三方开放平台，比如：支付宝、微信等等，access_token的特点是重复请求获取会刷新，每次请求获取access_token得到的都是不同的值，所以一般实际开发中，针对access_token会集中进行维护和管理，避免在多个应用中使用时会出现重新请求获取access_token导致旧access_token过期，从而三方业务请求失败，这种场景就是常说的：共享token问题。在实际开发中应尽量避免，因为一旦发生排查起来会很困难。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/327856449">OAuth2.0 的四种授权方式，值得一看</a></p><p><a href="https://blog.csdn.net/weixin_45525272/article/details/125920928">OAuth2.0 四种授权模式（图解）</a></p><p><a href="https://www.cnblogs.com/yakniu/p/16387713.html">OAuth 2.0 授权认证详解</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位枚举</title>
      <link href="/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="位枚举"><a href="#位枚举" class="headerlink" title="位枚举"></a>位枚举</h1><p>也称为 二进制枚举。</p><h2 id="什么是位枚举"><a href="#什么是位枚举" class="headerlink" title="什么是位枚举"></a>什么是位枚举</h2><p>位枚举也是一个枚举类，只不过其是利用二级制位运算来实现与枚举项的比较、包含、不包含等运算，其主要思想就是利用高性能的位运算操作来替换传统的大小比较，集合是否包含等方法，以此来进一步提高业务代码的性能。</p><p><strong>常见的使用场景：</strong></p><ul><li>标签字段</li><li>类型字段</li><li>等…</li></ul><p>位枚举并不复杂。下面以标签字段的应用场景分别使用传统的枚举操作和位枚举进行对比说明，加深对位枚举的理解和应用。</p><h2 id="传统枚举"><a href="#传统枚举" class="headerlink" title="传统枚举"></a>传统枚举</h2><p>枚举类定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标签枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderTagEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL_ORDER(<span class="number">1</span>, <span class="string">&quot;普通订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    SECKILL_ORDER(<span class="number">2</span>, <span class="string">&quot;秒杀订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    THIRD_SERVICE_ORDER(<span class="number">3</span>, <span class="string">&quot;三方服务订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    OrderTagEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderTagEnum <span class="title function_">getEnumByCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> tagEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库中的标签字段定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags<span class="type">varchar</span>(<span class="number">64</span>)<span class="keyword">null</span> comment <span class="string">&#x27;标签,List的json串&#x27;</span>,</span><br></pre></td></tr></table></figure><p>如此，当我们以传统形式的枚举去表示标签时，那么对应的数据库表中对应的字段存储的值形式会是下图这样的格式（在代码防腐层，保存前我们会将以<code>List&lt;Integer&gt;</code>集合形式存储的tags标签值转换为Json字符串），常用的序列化组件有：Jackson、Gson、Fastjson等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">tagsJson</span> <span class="operator">=</span> gson.toJson(Lists.newArrayList(OrderTagEnum.SECKILL_ORDER.getCode(), OrderTagEnum.THIRD_SERVICE_ORDER.getCode()));</span><br></pre></td></tr></table></figure><p>存储的结果如下图：</p><p><img src="enum1.png"></p><p>与保存时对应，当进行数据库查询时，我们去查询库表，同样在代码防腐层会进行发序列化处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">List&lt;Integer&gt; tagList = gson.fromJson(order.getTags(), <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;List&lt;Integer&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="传统枚举场景分析"><a href="#传统枚举场景分析" class="headerlink" title="传统枚举场景分析"></a>传统枚举场景分析</h3><h4 id="性能侧"><a href="#性能侧" class="headerlink" title="性能侧"></a>性能侧</h4><p>在以上使用传统枚举的过程中，保存数据库之前将标签字段序列化为Json串，查询数据库时再将Json串反序列化为List集合，在代码防腐层对标签字段的这两次序列化和反序列化操作，相比于标签字段直接存储，严格意义上来说是会存在一定的性能损耗，但是随着序列化组件性能的不断优化和服务器性能的提升，这两次序列化和反序列化操作对代码性能的影响可忽略不计，当然，这也不是位枚举的核心意义之所在。</p><h4 id="数据库侧"><a href="#数据库侧" class="headerlink" title="数据库侧"></a>数据库侧</h4><p><strong>增 | 改</strong> 都是针对数据库原数据新增和更新操作，剩下就是上述性能侧同样的问题。</p><p><font color="#dd0000"><strong>查 | 删</strong> </font>就会涉及到数据库原数据字段的业务操作，比如：查询、统计或者删除指定标签的记录，判断记录是否包含指定标签等场景。针对这些逻辑使用传统的枚举实现的步骤为：</p><ol><li><font color="\#00dd00">分页批量查询所有记录或者利用字符串模糊查询目标记录；</font></li><li>将tags字段反序列化为<code>List&lt;Integer&gt;</code>；</li><li><font color="\#00dd00">利用List集合的API方法，指定标签值；</font></li><li>进行后续逻辑处理；</li></ol><p>其中，<code>步骤1</code>和<code>步骤3</code>是整个业务链路中性能影响最明显的环节，同时，此环节也是<strong>位枚举的核心意义之所在</strong>。</p><h2 id="位枚举-1"><a href="#位枚举-1" class="headerlink" title="位枚举"></a>位枚举</h2><p>位枚举是指利用<strong>位运算实现的枚举类，枚举的code值必须是2的幂数，一般使用2^0，2^1，2^2，…依次递增</strong>。这样的话我们就可以利用位运算去快速的处理和枚举相关的业务。说到位运算大家第一反应应该都是<strong>速度嘎嘎快</strong>。</p><h3 id="位枚举的核心思想"><a href="#位枚举的核心思想" class="headerlink" title="位枚举的核心思想"></a>位枚举的核心思想</h3><ul><li><font color="#dd0000">枚举项的code值请以2的幂数递增，如: 1,2,4,8,16,32,64,128… </font></li><li><font color="#dd0000">任意两个整数m和n，如果m和n都是2的幂数，那么m和n进行按位<strong>或运算</strong>的结果就等于m和n的<strong>字面值相加</strong> </font> ，什么意思呢？<ul><li>即：m|n = m+n，如m=2，n=4，那么m|n = 6。此处等价于<strong>加法运算</strong>。</li></ul></li><li><font color="#dd0000">任意两个整数m和n，如果m和n都是2的幂数，p是m和n按位或的结果，那么就有p&amp;n=n，p&amp;m=m，类似于减法运算。 </font></li></ul><p><strong>位枚举定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标签位枚举.</span></span><br><span class="line"><span class="comment"> * ps: 枚举项的code值请以2的幂数递增，如: 1,2,4,8,16,32,64,128....</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderTagEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL_ORDER(<span class="number">1</span>, <span class="string">&quot;普通订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    SECKILL_ORDER(<span class="number">2</span>, <span class="string">&quot;秒杀订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    THIRD_SERVICE_ORDER(<span class="number">4</span>, <span class="string">&quot;三方服务订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    OrderTagEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过枚举项值获取对应的枚举项</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderTagEnum <span class="title function_">getEnumByCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(code)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> tagEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断入参tag是否包含tagEnum枚举项.</span></span><br><span class="line"><span class="comment">     * 一个整数 &amp; 枚举项code = 枚举项code,表示该整数包含枚举项.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag     多个标签的code累加和.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagEnum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isHasTag</span><span class="params">(Integer tag, OrderTagEnum tagEnum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tag) || Objects.isNull(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (tagEnum.getCode() &amp; tag) == tagEnum.getCode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取tag包含的所有标签枚举集合.</span></span><br><span class="line"><span class="comment">     * 传入给定整数和任意枚举项进行按位与运算,结果等于枚举项本身，说明给定整数包含此枚举项.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag 多个标签的code累加和.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderTagEnum&gt; <span class="title function_">getTagEnumList</span><span class="params">(Integer tag)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;OrderTagEnum&gt; tagList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((tagEnum.getCode() &amp; tag) == tagEnum.getCode()) &#123;</span><br><span class="line">                tagList.add(tagEnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tagList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举项集合按位或运算 得到所有爱好的整数结果.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagEnumList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">calculate</span><span class="params">(List&lt;OrderTagEnum&gt; tagEnumList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tagEnumList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : tagEnumList) &#123;</span><br><span class="line">            result |= tagEnum.getCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的数据库标签字段也修改为Long类型，而不再是Json字符串：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags<span class="type">bigint</span><span class="keyword">null</span> comment <span class="string">&#x27;标签&#x27;</span>,</span><br></pre></td></tr></table></figure><p>数据库标签字段存储变成了：</p><p><img src="enum2.png"></p><h3 id="位枚举场景分析"><a href="#位枚举场景分析" class="headerlink" title="位枚举场景分析"></a>位枚举场景分析</h3><p><strong>增 | 改</strong> 都是针对数据库原数据增加或者更新操作，代码防腐层不再需要序列化和反序列化操作。</p><p><font color="#dd0000"><strong>查 | 删</strong> </font> 同样是查询、统计或者删除指定标签的记录，判断记录是否包含指定标签等场景。步骤就变成了业务代码的位运算和SQL脚本的位运算。</p><p>如：查询三方服务标签和秒杀标签的记录。</p><p> 秒杀标签code | 三方服务标签code : 2 | 4 = 6，调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long tagValue = OrderTagEnum.calculate(Arrays.asList(OrderTagEnum.NORMAL_ORDER,OrderTagEnum.THIRD_SERVICE_ORDER));</span><br></pre></td></tr></table></figure><p>到SQL层面，入参#{tagValue}就为6，SQL层使用位与运算，就可以查询到所有包含三方服务标签和秒杀标签的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cloud_order.tb_order</span><br><span class="line"><span class="keyword">where</span> #&#123;tagValue&#125; <span class="operator">=</span>  tags <span class="operator">&amp;</span> #&#123;tagValue&#125;;</span><br></pre></td></tr></table></figure><p>tagValue为6时的结果：</p><p><img src="enum3.png"></p><p>查询到结果之后，在代码层调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderTagEnum&gt; tagList = OrderTagEnum.getTagEnumList(tagValue);</span><br></pre></td></tr></table></figure><p>得到目标值tagValue包含的所有标签枚举项列表。</p><blockquote><p>一般情况下，位枚举相关业务涉及到数据库的操作时，通常也需要结合SQL的位运算来支撑位枚举。</p></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1746867064605404073&wfr=spider&for=pc">位枚举应用</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
