<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「Sentinel - 1」-- 初识Sentinel</title>
      <link href="/maple/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/"/>
      <url>/maple/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h1><h2 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h2><h3 id="认识Sentinel"><a href="#认识Sentinel" class="headerlink" title="认识Sentinel"></a>认识Sentinel</h3><blockquote><p>官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p></blockquote><p><strong>Sentinel 具有以下特征:</strong></p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。**只要是通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。常见的，可以使用方法签名，URL，甚至服务名称作为资源名来标识资源。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel可提供包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h2 id="Sentinel-功能和设计理念"><a href="#Sentinel-功能和设计理念" class="headerlink" title="Sentinel 功能和设计理念"></a>Sentinel 功能和设计理念</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><img src="sentinel1.png" style="zoom:40%;"><p>流量控制有以下几个角度:</p><ul><li><strong>资源的调用关系</strong>，例如：资源的调用链路，资源和资源之间的关系；</li><li><strong>运行指标</strong>，例如： QPS、线程池、系统负载等；</li><li><strong>控制的效果</strong>，例如：直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><h4 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h4><p>除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 <a href="https://github.com/Netflix/Hystrix/wiki#what-problem-does-hystrix-solve">Hystrix</a> 里面描述的问题是一样的。</p><img src="sentinel2.png" alt="sentinel2" style="zoom:40%;"><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，慢响应比例升高，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生服务雪崩。</p><blockquote><p><strong>服务雪崩</strong></p><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是服务雪崩。</p><p><strong>服务雪崩解决方案</strong></p><ul><li><strong>超时处理</strong>：设定资源请求的超时时间，请求时间超过阈值没有响应就返回错误信息，不会无休止等待。<ul><li>此种方式并不能从根本上解决问题，如果在超时之前有大量请求进来还是会造成请求堆积，仍然有节点崩溃的风险。而且超时时间的阈值不好确定，只能根据监控的RT统计数据给出一个相对合适的阈值。</li><li>个人理解：此方案只能适用于一些简单并且低流量的系统出现弱网或者网络抖动的场景；</li></ul></li><li><strong>线程池隔离（也称为 舱壁模式）</strong>：为每个业务资源单独创建并分配一个线程数，避免耗尽整个系统的资源，因此也叫线程隔离。<ul><li>优点：实现每个业务的完全隔离；</li><li>缺点：线程过多，线程上下文的切换会消耗服务器的资源，极端情况下，服务器的CPU利用率飙升，但是处理能力却反而下降，因为服务器在忙着进行线程的上下文切换。</li></ul></li><li><strong>熔断降级</strong>：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。<ul><li>内部会维护一个断路器，对单位时间内的业务执行异常比例、错误数量、慢调用比例等进行统计，并结合状态机模式实现断路器状态之间的切换，从而实现对目标场景的熔断降级。</li></ul></li><li><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。<ul><li>是一种<strong>故障预防</strong>方案。</li></ul></li></ul></blockquote><h4 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h4><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>（也称为 舱壁模式）的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（Java的线程映射LWP，所以Java的线程切换意味着用户态到内核态的切换和操作系统的线程调度，是一种很重的操作，会影响服务器的性能），还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li><strong>通过并发线程数进行限制</strong></li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，例如：响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li><strong>通过响应时间对资源进行降级</strong></li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h3 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h3><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2 id="Sentinel-是如何工作的"><a href="#Sentinel-是如何工作的" class="headerlink" title="Sentinel 是如何工作的"></a>Sentinel 是如何工作的</h2><p>Sentinel 的主要工作机制如下：</p><ul><li>对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。</li><li>根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便开发者自定义及改变规则。</li><li>Sentinel 提供实时的监控系统，方便开发者快速了解目前系统的状态。</li></ul><h2 id="服务保护框架对比"><a href="#服务保护框架对比" class="headerlink" title="服务保护框架对比"></a>服务保护框架对比</h2><p>常见的服务保护框架有：Sentinel 和 Hystrix（已经停止更新维护，从GitHub上看最后一次维护代码都是5、6年前了）</p><table><thead><tr><th>核心对比点</th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td><font color="#dd0000"><strong>隔离策略</strong></font></td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td><font color="#dd0000"><strong>熔断降级策略</strong></font></td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td><font color="#dd0000"><strong>限流</strong></font></td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td><font color="#dd0000"><strong>流量整形</strong></font></td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td><font color="#dd0000"><strong>控制台</strong></font></td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><blockquote><p>流量整形：将波动的请求流量整形为均匀的流量，避免尖峰流量对服务器的冲击。</p></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防盗链</title>
      <link href="/maple/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/"/>
      <url>/maple/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h1><h2 id="防盗链的定义"><a href="#防盗链的定义" class="headerlink" title="防盗链的定义"></a>防盗链的定义</h2><p><strong>防盗链</strong>其实就是在网络服务器端进行个性化编程，通过URL过滤技术实现对目标资源控制访问。</p><p><strong>比如：</strong></p><p><code>file.maple.com/test.jpg</code>这个图片地址，如果没有装防盗链，那么任意用户都能通过该URL轻而易举的在他的网站上引用这个图片。如果对<code>file.maple.com</code> 这个地址进行服务器端编程，如给URL拼接参数，得到<code>file.maple.com/test.jpg?authcode=xxx&amp;ip=127.0.0.1</code>，自动拼接了ip参数，然后在对URL路由时针对IP参数进行个性化判断，就能实现只有<code>127.0.0.1</code>来访问这个链接，而其它的IP地址则无法访问该链接。</p><h2 id="防盗链的产生"><a href="#防盗链的产生" class="headerlink" title="防盗链的产生"></a>防盗链的产生</h2><p>一般我们在浏览网页时，一个完整的页面并不是客户端通过一次HTTP请求就将全部资源从服务器上拉取下来的，而是会分成很多次HTTP请求。如果客户端所浏览的页面带有图片或其它功能性信息，那么客户端的第一个HTTP请求就是想资源服务器端请求这个页面的文本信息，然后通过客户端的浏览器对服务器返回的数据进行解析，如果发现其中包含图片地址URL，那么客户端的浏览器会自动针对该图片URL再一次发送HTTP请求去获取目标图片并将其放置到目标位置，就这样一个完整的网络页面内部经过多次HTTP请求才能完整的展现出来。</p><p>基于此机制，就会产生盗链的问题。</p><blockquote><p><strong>个人理解</strong></p><p>盗链：全称应该是 盗取网络链接地址。</p></blockquote><p>如果一个网站中没有其页面中的图片信息，那么它完全可以链接访问到其他网站的图片信息。这样，没有任何资源的网站利用了其他网站的资源来展示给浏览者，提高了自己站点的访问量，而大部分浏览者又不会很容易地发现内部资源的调用过程，这样显然对于那些被利用了资源的网站是不公平的。一些不良网站为了不增加成本而扩充自己站点内容，经常盗用其他网站的链接。</p><h2 id="防盗链的实现"><a href="#防盗链的实现" class="headerlink" title="防盗链的实现"></a>防盗链的实现</h2><p>要实现防盗链，首先要理解盗链的实现原理，提到防盗链的实现原理就不得不从HTTP协议说起，在HTTP协议中，有一个表头字段叫 <code>referer</code>，其采用URL的格式来表示从哪儿链接到当前的网页或文件。换句话说，通过referer，网站可以检测到目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。有了<code>referer</code>跟踪来源就好办了，这时就可以通过技术手段来进行处理，一旦检测到来源不是期望的URL地址，那么就进行拦截或者返回降级页面和资源。 </p><p><strong>HTTP Headers</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:authority: g.csdnimg.cn</span><br><span class="line">:method: GET</span><br><span class="line">:path: /static/logo/favicon32.ico</span><br><span class="line">:scheme: https</span><br><span class="line">accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">if-modified-since: Mon, 24 Apr 2023 09:23:28 GMT</span><br><span class="line">if-none-match: &quot;64464a90-10be&quot;</span><br><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?1</span><br><span class="line">sec-ch-ua-platform: &quot;Android&quot;</span><br><span class="line">sec-fetch-dest: image</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36</span><br></pre></td></tr></table></figure><p>如果想对自己的网站进行防盗链保护，需要针对不同的情况进行区别对待。如果网站服务器用的是apache，那么使用apache自带Url Rewrite插件就可以很轻松实现各种防盗链，其原理是检查HTTP请求头中的refer属性值，如果refer的信息来自非目标站点则重定向到指定图片或网页上。还有很多其他的防盗链实现机制，总体上都换汤不换药，都是基于<code>refer</code>属性值进行个性化过滤。</p><hr><p><strong>参考文档：</strong></p><p><a href="http://www.zzbaike.com/wiki/%E9%98%B2%E7%9B%97%E9%93%BE">防盗链</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 协议</title>
      <link href="/maple/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/"/>
      <url>/maple/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2-0协议"><a href="#OAuth2-0协议" class="headerlink" title="OAuth2.0协议"></a><strong>OAuth2.0协议</strong></h1><h2 id="OAuth2-0-为何物"><a href="#OAuth2-0-为何物" class="headerlink" title="OAuth2.0 为何物"></a><strong>OAuth2.0 为何物</strong></h2><p>OAuth 简单理解就是一种授权机制，它是在客户端和资源所有者之间的授权层，用来分离两种不同的角色。在资源所有者同意并向客户端颁发令牌后，客户端携带令牌就可以访问资源所有者的资源。</p><blockquote><p>OAuth2.0 是OAuth 协议的一个版本，有2.0版本那就有1.0版本，有意思的是OAuth2.0 却不向下兼容OAuth1.0 ，相当于废弃了1.0版本。</p></blockquote><p>举个小栗子解释一下什么是 OAuth 授权？</p><p>订了个外卖，外卖小哥30秒火速到达了我家楼下，奈何有门禁进不来，可以输入密码进入，但出于安全考虑我并不想告诉他密码。此时外卖小哥看到门禁有一个高级按钮“一键获取授权”，只要我这边同意，他会获取到一个有效期 2小时的令牌（token）正常出入。</p><p>令牌（token）和 密码 的作用虽然相似都可以进入系统，但还有点不同。token 拥有权限范围，有时效性的，到期自动失效，而且修改无效。</p><p><strong>OAuth2.0中有四个重要角色：</strong></p><table><thead><tr><th align="center">角色</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">客户端</td><td align="center">本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，常见的就是用户常用的各种客户端，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</td></tr><tr><td align="center">资源拥有者</td><td align="center">通常为用户，也可以是应用程序，即该资源的拥有者。</td></tr><tr><td align="center">授权服务器（也称认证服务器）</td><td align="center">用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌 （access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。</td></tr><tr><td align="center">资源服务器</td><td align="center">存储资源拥有者所拥有的资源的服务器，比如：微信侧存储的用户信息。</td></tr></tbody></table><p><strong>拿微信授权其他平台登录为例，该角色在流程中对应关系如下：</strong></p><p><img src="auth1.png"></p><h2 id="OAuth2-0-授权方式"><a href="#OAuth2-0-授权方式" class="headerlink" title="OAuth2.0 授权方式"></a><strong>OAuth2.0 授权方式</strong></h2><p>OAuth2.0 的授权简单理解其实就是获取令牌（token）的过程，OAuth 协议定义了四种获得令牌的授权方式（authorization grant ）如下：</p><ul><li><strong>授权码（<strong><strong>authorization-code</strong></strong>）</strong></li><li><strong>隐藏式（<strong><strong>implicit</strong></strong>）</strong></li><li><strong>密码式（<strong><strong>password</strong></strong>）：</strong></li><li><strong>客户端凭证（<strong><strong>client credentials</strong></strong>）</strong></li></ul><p>但值得注意的是，不管我们使用哪一种授权方式，在三方应用申请令牌之前，都必须在系统中去申请身份唯一标识：客户端 ID（client ID）和 客户端密钥（client secret）。这样做可以保证 token 不被恶意使用。</p><p>下面我们会分析每种授权方式的原理，在进入正题前，先了解 OAuth2.0 授权过程中几个重要的参数：</p><ul><li>response_type：code 表示要求返回授权码，token 表示直接返回令牌；</li><li>client_id：客户端身份标识；</li><li>client_secret：客户端密钥；</li><li>redirect_uri：重定向地址（用户同意授权之后，三方应用将返回的信息带回时调用的重定向地址，passport-third中三方登录接口的cap地址）；</li><li>scope：表示授权的范围，read只读权限，all读写权限；</li><li>grant_type：表示授权的方式，AUTHORIZATION_CODE（授权码）、password（密码）、client_credentials（凭证式）、refresh_token 更新令牌；</li><li>state：应用程序传递的一个随机数，用来防止CSRF攻击；</li></ul><blockquote><p>CSRF攻击 | 跨站请求伪造</p><p><a href="https://zhuanlan.zhihu.com/p/22521378">CSRF是什么？</a></p></blockquote><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a><strong>授权码</strong></h3><p>OAuth2.0四种授权中授权码方式是最为复杂，但也是安全系数最高的，比较常用的一种方式。这种模式是<strong>四种模式中最安全的一种模式</strong>。一般用于Web服务器端应用或第三方的原生App调用资源服务的时候。适用于兼具前后端的Web项目，因为有些项目只有后端或只有前端，并不适用授权码模式。</p><p>下图我们以用WX登录掘金为例，详细看一下授权码方式的整体流程。</p><p><img src="auth2.png"></p><p>用户选择WX登录掘金，掘金会向WX发起授权请求，接下来 WX询问用户是否同意授权（常见的弹窗授权）。response_type 为 code 要求返回授权码，scope 参数表示本次授权范围为只读权限，redirect_uri 重定向地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=code&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  </span></span><br><span class="line">scope=read</span><br></pre></td></tr></table></figure><p>用户同意授权后，WX 根据 redirect_uri重定向并带上授权码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//juejin.im/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>当掘金拿到授权码（code）时，带授权码和密匙等参数向WX申请令牌。grant_type表示本次授权为授权码方式 authorization_code ，获取令牌要带上客户端密匙 client_secret，和上一步得到的授权码 code。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token? </span></span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp; </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp; </span><br><span class="line">grant_type=authorization_code&amp; </span><br><span class="line">code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp; </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback</span></span><br></pre></td></tr></table></figure><p>最后 WX 收到请求后向 redirect_uri 地址发送 JSON 数据，其中的access_token 就是令牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;ACCESS_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">2592000</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;REFRESH_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="string">&quot;read&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  ...... </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Q：OAuth 2.0为什么不直接返回access_token?要设定为返回auth_code之后再去请求accessToken？</strong></p><p>主要出于安全方考虑，防止中间人攻击。假设第三方应用、授权服务不直接通信，中间隔了一层代理。且第三方应用采用HTTP协议，这样恶意代理就能窃取access token。因此，采用了通过code来交换access token的方式，来增加安全性。并且不能将access_token直接给到用户侧，相对于用户侧网络环境的复杂性，第三方应用自身服务端的网络环境相对更安全。</p><p>特别注意：对于授权码和access_token的篡改，在OAuth 1.0中是反复的对Code和Token进行签名，来保证Token不会被篡改，但是OAuth 2.0中却没有，因为OAuth 2.0是基于Https的，所以如果没有Https的支持OAuth 2.0可能还不如OAuth 1.0。在 OAuth 2.0 中，使用 HTTPS 可以说是必须的，而且 client 有义务验证证书的真假，防止中间人攻击，而 authorization server 和 resource server 都有义务申请可信任的第三方颁发的真实的 SSL 证书。</p></blockquote><h3 id="隐藏式（简化模式）"><a href="#隐藏式（简化模式）" class="headerlink" title="隐藏式（简化模式）"></a><strong>隐藏式（简化模式）</strong></h3><p>授权码模式：</p><p><img src="auth3.png"></p><p>简化版的授权码模式，跳过临时授权码的环节，只要用户一点击授权，就能直接返回access_token，而不是通过授权码code再次去获取。</p><p><img src="auth4.png"></p><blockquote><p>参数描述同授权码模式 ，注意response_type=token，说明是简化模式。</p></blockquote><p>上边提到有一些Web应用是没有后端的， 属于纯前端应用，无法用上边的授权码模式。令牌的申请与存储都需要在前端完成，跳过了授权码这一步。</p><p>前端应用直接获取 token，response_type 设置为 token，要求直接返回令牌，跳过授权码，WX授权通过后重定向到指定 redirect_uri 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=token&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  scope=read</span></span><br></pre></td></tr></table></figure><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a><strong>密码式</strong></h3><p><img src="auth5.png"></p><p>密码模式比较好理解，用户在掘金直接输入自己的WX用户名和密码，掘金拿着信息直接去WX申请令牌，请求响应的 JSON结果中返回 token。grant_type 为 password 表示密码式授权。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?  </span></span><br><span class="line">grant_type=password&amp;  </span><br><span class="line">username=<span class="variable constant_">USERNAME</span>&amp;  </span><br><span class="line">password=<span class="variable constant_">PASSWORD</span>&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span></span><br></pre></td></tr></table></figure><p>这种授权方式简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下，或者第一方原生APP或第一方单页面应用。</p><h3 id="客户端凭证式"><a href="#客户端凭证式" class="headerlink" title="客户端凭证式"></a><strong>客户端凭证式</strong></h3><p><img src="auth6.png"></p><p>凭证式和密码式很相似，主要适用于那些没有前端的命令行应用，可以用最简单的方式获取令牌，在请求响应的 JSON 结果中返回 token。</p><p>grant_type 为 client_credentials 表示凭证式授权，client_id 和 client_secret 用来识别身份。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?  </span></span><br><span class="line">grant_type=client_credentials&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span></span><br></pre></td></tr></table></figure><h2 id="令牌的使用与更新"><a href="#令牌的使用与更新" class="headerlink" title="令牌的使用与更新"></a><strong>令牌的使用与更新</strong></h2><h3 id="1、令牌怎么用？"><a href="#1、令牌怎么用？" class="headerlink" title="1、令牌怎么用？"></a><strong>1、令牌怎么用？</strong></h3><p>拿到令牌可以调用 WX API 请求数据了，那令牌该怎么用呢？</p><p>每个到达WX的请求都必须带上 token，将 token 放在 http 请求头部的一个Authorization字段里。</p><p>如果使用postman 模拟请求，要在Authorization -&gt; Bearer Token 放入 token，注意：低版本postman 没有这个选项。</p><p><img src="auth7.png"></p><h3 id="2、令牌过期怎么办？"><a href="#2、令牌过期怎么办？" class="headerlink" title="2、令牌过期怎么办？"></a><strong>2、令牌过期怎么办？</strong></h3><p>token是有时效性的，一旦过期就需要重新获取，但是重走一遍授权流程，不仅麻烦而且用户体验也不好，那如何让更新令牌变得优雅一点呢？</p><p>一般在颁发令牌时会一次发两个令牌，一个令牌用来请求API，另一个负责更新令牌 refresh_token。grant_type 为 refresh_token 请求为更新令牌，参数 refresh_token 是用于更新令牌的令牌。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token?  </span></span><br><span class="line">grant_type=refresh_token&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;  </span><br><span class="line">refresh_token=<span class="variable constant_">REFRESH_TOKEN</span></span><br></pre></td></tr></table></figure><h3 id="3、令牌的维护"><a href="#3、令牌的维护" class="headerlink" title="3、令牌的维护"></a>3、令牌的维护</h3><p>因为各大三方开放平台，比如：支付宝、微信等等，access_token的特点是重复请求获取会刷新，每次请求获取access_token得到的都是不同的值，所以一般实际开发中，针对access_token会集中进行维护和管理，避免在多个应用中使用时会出现重新请求获取access_token导致旧access_token过期，从而三方业务请求失败，这种场景就是常说的：共享token问题。在实际开发中应尽量避免，因为一旦发生排查起来会很困难。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/327856449">OAuth2.0 的四种授权方式，值得一看</a></p><p><a href="https://blog.csdn.net/weixin_45525272/article/details/125920928">OAuth2.0 四种授权模式（图解）</a></p><p><a href="https://www.cnblogs.com/yakniu/p/16387713.html">OAuth 2.0 授权认证详解</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制枚举</title>
      <link href="/maple/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"/>
      <url>/maple/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
