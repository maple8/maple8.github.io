<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java钩子方法</title>
      <link href="/maple/2023/05/09/Java%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/"/>
      <url>/maple/2023/05/09/Java%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM钩子"><a href="#JVM钩子" class="headerlink" title="JVM钩子"></a>JVM钩子</h1><p>JVM进程在接收到<code>kill -15</code>信号通知的时候，是可以做一些清理动作的，比如：删除临时文件等。当然了，开发者也可以基于该信号自定义做一些额外的操作，比如：让tomcat容器停止，让dubbo服务下线，清理数据等。这种自定义JVM清理动作的方式，是通过JDK中提供的<code>ShutdownHook</code>实现的。JDK提供了<code>Java.Runtime.addShutdownHook(Thread hook)</code> 方法，可以注册一个在JVM关闭时需要执行的钩子方法。</p><blockquote><p>kill命令原理请见博文：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650127782&idx=1&sn=87cc02ab1484b14e0313998da527bedf&chksm=f36ba087c41c29916a572f24f2a9b21cdc7080a75261c7f662d86de558840d13cd0bc93ed1fc&scene=178&cur_album_id=1337197892284809216#rd">kill -9的原理</a></p></blockquote><h2 id="JVM钩子的作用"><a href="#JVM钩子的作用" class="headerlink" title="JVM钩子的作用"></a>JVM钩子的作用</h2><p><strong>JVM钩子方法的执行时机是在所有非守护线程都执行完成之后，在JVM进程退出之前</strong>，利用钩子线程去执行一些清理工作，如：释放资源，文件清理等等。</p><p>我们都知道，在Linux中，Java应用是作为一个独立进程运行的，Java程序的终止就是基于JVM进程的关闭实现的，JVM进程关闭方式分为3种：</p><ul><li><strong>正常关闭</strong>：当最后一个非守护线程运行结束 或者 调用了 <code>System.exit( )</code> 或者 通过其他特定平台的方法关闭 或者 执行 <code>kill [-15]</code>（接收到SIGINT（2）、SIGTERM（15）信号等）；</li><li><strong>异常关闭</strong>：程序运行中遇到<code>RuntimeException</code>异常，或者操作系统程序出现异常导致JVM退出等；</li><li><strong>强制关闭</strong>：通过调用<code>Runtime.halt( )</code>方法 或者 在操作系统中强制 <code>kill -9</code>（接收到SIGKILL（9）信号)</li></ul><blockquote><p><strong>Linux常见的信号有：</strong></p><ul><li><strong>kill -2 PID</strong> —— 正常中断进程（作用等同于：Ctrl + C ）。程序在结束之前，能够保存相关数据，然后再退出。</li><li><strong>kill -9 PID</strong> —— 强制杀死一个进程。</li><li><strong>kill [-15] PID</strong> —— 正常方式关闭（终止）进程。关闭进程时应先考虑使用 <code>kill -15</code> ，以便于其能够预先清理临时文件和释放资源。</li></ul><p><strong>PS：<code>kill -9</code> 作为最后手段，应对那些失控的进程。</strong></p></blockquote><h2 id="JVM钩子的使用场景"><a href="#JVM钩子的使用场景" class="headerlink" title="JVM钩子的使用场景"></a>JVM钩子的使用场景</h2><h3 id="JVM正常关闭-–-钩子生效"><a href="#JVM正常关闭-–-钩子生效" class="headerlink" title="JVM正常关闭 – 钩子生效"></a>JVM正常关闭 – 钩子生效</h3><p>如果有注册钩子，那么当JVM进程中的所有非守护线程执行完任务之后，JVM退出之前会执行钩子里面的任务。</p><p><strong>Demo1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!! </span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p>从上述代码可以看出，我们一般定义的钩子任务都是被封装成一个线程任务，也就是说每个钩子都分别是在一个不同的线程中并发执行的。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h4><p>IDEA中debug上述Demo，发现在JVM进程中当所有的非守护线程结束时，JVM底层的C源码会调用JNI创建一个名为：**DestroyJavaVM线程 **用于执行注册的钩子任务。</p><img src="hook1.png" style="zoom:80%;"><p><strong>DestroyJavaVM线程定义</strong></p><p>从 <code>java.c</code> 源码文件中找到<strong>DestroyJavaVM线程</strong>的定义。如下图：</p><img src="hook2.png" style="zoom:80%;"><blockquote><p>* Wait for all non-daemon threads to end, then destroy the VM.</p><p>* This will actually create a trivial new Java waiter thread named “DestroyJavaVM”, but this will be seen as a different thread from the one that executed main, even though they are the same C thread.  This allows mainThread.join( )  and mainThread.isAlive() to work as expected.</p><p>译文：等待所有非守护线程结束，然后销毁VM。这实际上会创建一个名为“DestroyJavaVM”的Java等待线程，但这将被视为一个不同于执行main的线程，尽管它们是同一个C线程。这允许mainThread.join( )和mainThread.isAlive( )按预期工作。</p></blockquote><p>从上述debug的截图来看，这个<strong>DestroyJavaVM线程</strong>主要就是调用了<code>Shutdown.shutdown()</code>方法来执行注册的钩子。钩子任务的整个执行链路如下图所示：</p><img src="hook3.png" style="zoom:80%;"><p><strong>Shutdown.shutdwon( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by the JNI DestroyJavaVM procedure when the last non-daemon thread has finished. </span></span><br><span class="line"><span class="comment"> * Unlike the exit method, this method does not actually halt the VM.</span></span><br><span class="line"><span class="comment"> * 译文：当最后一个非守护线程执行完成时，由JNI DestroyJavaVM过程调用。与exit方法不同的是，此方法实际上不会停止虚拟机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:       <span class="comment">/* Initiate shutdown */</span></span><br><span class="line">            state = HOOKS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> HOOKS:         <span class="comment">/* Stall and then return */</span></span><br><span class="line">        <span class="keyword">case</span> FINALIZERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (Shutdown.class) &#123;</span><br><span class="line">        sequence();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.sequence( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The actual shutdown sequence is defined here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If it weren&#x27;t for runFinalizersOnExit, this would be simple -- we&#x27;d just</span></span><br><span class="line"><span class="comment"> * run the hooks and then halt.  Instead we need to keep track of whether</span></span><br><span class="line"><span class="comment"> * we&#x27;re running hooks or finalizers.  In the latter case a finalizer could</span></span><br><span class="line"><span class="comment"> * invoke exit(1) to cause immediate termination, while in the former case</span></span><br><span class="line"><span class="comment"> * any further invocations of exit(n), for any n, simply stall.  Note that</span></span><br><span class="line"><span class="comment"> * if on-exit finalizers are enabled they&#x27;re run iff the shutdown is</span></span><br><span class="line"><span class="comment"> * initiated by an exit(0); they&#x27;re never run on exit(n) for n != 0 or in</span></span><br><span class="line"><span class="comment"> * response to SIGINT, SIGTERM, etc.</span></span><br><span class="line"><span class="comment"> * 译文: 实际的关闭顺序在这里定义。</span></span><br><span class="line"><span class="comment"> * 如果没有runFinalizersOnExit，这将是简单的——我们只需运行钩子，然后停止。相反，我们需要跟踪运行的是钩子还是终结器。</span></span><br><span class="line"><span class="comment"> * 在后一种情况下，终结器可以调用exit(1)来导致立即终止，而在前一种情况下，任何对exit(n)的进一步调用，对于任何n，</span></span><br><span class="line"><span class="comment"> * 都只是暂停。注意，如果启用了on-exit终结器，那么如果关闭由一个exit(0)启动，它们就会运行;它们永远不会在退出(n)时运行，</span></span><br><span class="line"><span class="comment"> * 因为n != 0或响应SIGINT、SIGTERM等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sequence</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">/* Guard against the possibility of a daemon thread invoking exit</span></span><br><span class="line"><span class="comment">         * after DestroyJavaVM initiates the shutdown sequence</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (state != HOOKS) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runHooks(); <span class="comment">// 核心 -- 执行钩子</span></span><br><span class="line">    <span class="type">boolean</span> rfoe;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        state = FINALIZERS;</span><br><span class="line">        rfoe = runFinalizersOnExit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rfoe) runAllFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.runHooks( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> slot, <span class="type">boolean</span> registerShutdownInProgress, Runnable hook)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hooks[slot] != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Shutdown hook at slot &quot;</span> + slot + <span class="string">&quot; already registered&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!registerShutdownInProgress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; RUNNING)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hooks[slot] = hook;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run all registered shutdown hooks*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_SYSTEM_HOOKS; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable hook;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// acquire the lock to make sure the hook registered during shutdown is visible here.</span></span><br><span class="line">                currentRunningHook = i;</span><br><span class="line">                hook = hooks[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hook != <span class="literal">null</span>) hook.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ThreadDeath) &#123;</span><br><span class="line">                <span class="type">ThreadDeath</span> <span class="variable">td</span> <span class="operator">=</span> (ThreadDeath) t;</span><br><span class="line">                <span class="keyword">throw</span> td;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.run( )源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationShutdownHooks</span> &#123;</span><br><span class="line">    <span class="comment">/* The set of registered hooks */</span></span><br><span class="line">    <span class="comment">// IdentifyHashMap的解释: https://blog.csdn.net/f641385712/article/details/81880711</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Shutdown.add(<span class="number">1</span> <span class="comment">/* shutdown hook invocation order */</span>,</span><br><span class="line">                <span class="literal">false</span> <span class="comment">/* not registered if shutdown in progress */</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        runHooks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            hooks = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// application shutdown hooks cannot be added if</span></span><br><span class="line">            <span class="comment">// shutdown is in progress.</span></span><br><span class="line">            hooks = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.runHooks() – 执行钩子任务的核心方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Iterates over all application hooks creating a new thread for each</span></span><br><span class="line"><span class="comment"> * to run in. Hooks are run concurrently and this method waits for</span></span><br><span class="line"><span class="comment"> * them to finish.</span></span><br><span class="line"><span class="comment"> * 译文: 遍历所有应用程序钩子，为每个要运行的钩子创建一个新线程。钩子任务是并发执行的，这个方法等待它们完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runHooks</span><span class="params">()</span> &#123;</span><br><span class="line">    Collection&lt;Thread&gt; threads;</span><br><span class="line">    <span class="keyword">synchronized</span>(ApplicationShutdownHooks.class) &#123;</span><br><span class="line">        threads = hooks.keySet();</span><br><span class="line">        hooks = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        hook.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Thread hook : threads) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这行代码是钩子任务的灵魂，阻塞当前线程直到所有的钩子任务线程执行完毕。</span></span><br><span class="line">                <span class="comment">// 同时需要注意正是因为该行代码的存在导致在钩子任务中请勿执行耗时长的任务，否则会导致JVM进程长时间无法退出。</span></span><br><span class="line">                hook.join();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者在注入钩子时使用的<code>addShutdownHook()</code>方法，就是进行注册钩子。</p><p><strong>Runtime.addShutdownHook( )方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShutdownHook</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;shutdownHooks&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ApplicationShutdownHooks.add(hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ApplicationShutdownHooks.add()方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Thread hook)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(hooks == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook already running&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Hook previously registered&quot;</span>);</span><br><span class="line">    hooks.put(hook, hook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，JVM进程正常结束时，注册钩子任务的执行流程源码分析就结束了，从开发者代码注入钩子到执行钩子的触发时机，每一步的对应源码分析都很仔细，后续再熟悉熟悉整个流程。</p><p><strong>Demo2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p><strong>System.exit ( )方法源码分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    Runtime.getRuntime().exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runtime.exit( )方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        security.checkExit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Shutdown.exit(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.exit( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Invoked by Runtime.exit, which does all the security checks.</span></span><br><span class="line"><span class="comment"> * Also invoked by handlers for system-provided termination events,</span></span><br><span class="line"><span class="comment"> * which should pass a nonzero status code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">runMoreFinalizers</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span>) runFinalizersOnExit = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:       <span class="comment">/* Initiate shutdown */</span></span><br><span class="line">                state = HOOKS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> HOOKS:         <span class="comment">/* Stall and halt */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINALIZERS: <span class="comment">// 如果是终结器</span></span><br><span class="line">                <span class="keyword">if</span> (status != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Halt immediately on nonzero status */</span></span><br><span class="line">                    halt(status); <span class="comment">// 关闭JVM</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/* Compatibility with old behavior:</span></span><br><span class="line"><span class="comment">                     * Run more finalizers and then halt</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    runMoreFinalizers = runFinalizersOnExit;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runMoreFinalizers) &#123;</span><br><span class="line">        runAllFinalizers();</span><br><span class="line">        halt(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (Shutdown.class) &#123;</span><br><span class="line">        <span class="comment">/* Synchronize on the class object, causing any other thread</span></span><br><span class="line"><span class="comment">         * that attempts to initiate shutdown to stall indefinitely</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        sequence(); <span class="comment">// 顺序关系方法，又回到上述正常关闭时执行钩子方法的逻辑了</span></span><br><span class="line">        halt(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述源码可以看出，调用`System.exit(0)方法结束JVM进程时，还是会执行钩子任务的。</p><h3 id="JVM异常关闭-–-钩子生效"><a href="#JVM异常关闭-–-钩子生效" class="headerlink" title="JVM异常关闭 – 钩子生效"></a>JVM异常关闭 – 钩子生效</h3><p><strong>JVM进程在发生异常情况导致退出时，</strong>钩子还是会生效。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">at com.maple.system.Demo_System_Exit.main(Demo_System_Exit.java:17)</span><br><span class="line">Hook Method...</span><br></pre></td></tr></table></figure><p>从debug可以看出，钩子的执行和JVM进程正常结束时是一样的：</p><img src="hook4.png" style="zoom:80%;"><h3 id="JVM强制关闭-–-钩子不生效"><a href="#JVM强制关闭-–-钩子不生效" class="headerlink" title="JVM强制关闭 – 钩子不生效"></a>JVM强制关闭 – 钩子不生效</h3><p><strong>JVM进程如果是被执行了<code>kill -9</code> 或 <code>Runtime.halt()</code>方法等强制关闭的场景下，</strong>钩子是不生效的。</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hook Method...&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    Runtime.getRuntime().halt(<span class="number">0</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p><strong>Runtime.halt( )方法分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">halt</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        sm.checkExit(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Shutdown.halt(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Shutdown.halt( )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The halt method is synchronized on the halt lock</span></span><br><span class="line"><span class="comment"> * to avoid corruption of the delete-on-shutdown file list.</span></span><br><span class="line"><span class="comment"> * It invokes the true native halt method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">halt</span><span class="params">(<span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (haltLock) &#123;</span><br><span class="line">        halt0(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">halt0</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p>底层直接调用了JNI方法实现JVM进程的强制关闭，整个链路中没有钩子任务的执行逻辑。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 钩子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Saas</title>
      <link href="/maple/2023/05/08/%E6%B5%85%E6%9E%90Saas/"/>
      <url>/maple/2023/05/08/%E6%B5%85%E6%9E%90Saas/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析Saas"><a href="#浅析Saas" class="headerlink" title="浅析Saas"></a>浅析Saas</h1><p>什么是SAAS平台？</p><p>　　SaaS是随着互联网技术的发展和应用软件的成熟，在21世纪开始兴起的一种完全创新的软件应用模式。</p><p>　　其全称是Software-as-a-Service，(软件即服务)，它是一种通过Internet提供软件的模式，厂商将应用软件统一部署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务，按定购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务。</p><p>　　用户不用再购买软件，而改用向提供商租用基于Web的软件，来管理企业经营活动，且无需对软件进行维护，服务提供商会全权管理和维护软件，软件厂商在向客户提供互联网应用的同时，也提供软件的离线操作和本地数据存储，让用户随时随地都可以使用其定购的软件和服务。</p><p>　　对于许多小型企业来说，SaaS是采用先进技术的最好途径，它消除了企业购买、构建和维护基础设施和应用程序的需要。</p><p>　　SaaS应用软件的价格通常为“全包”费用，囊括了通常的应用软件许可证费、软件维护费以及技术支持费，将其统一为每个用户的月度租用费。对于广大中小型企业来说，SaaS是采用先进技术实施信息化的最好途径。但SaaS绝不仅仅适用于中小型企业，所有规模的企业都可以从SaaS中获利。 </p><p>SAAS平台架构分为哪些？</p><p>　　1、呈现层</p><p>　　saas平台架构的呈现层可以使用的客户端可能都浏览器或本地客户端。如果是浏览器则需要Web界面技术、交互技术等技术(如：HTMl5技术、CSS3技术、Ajax技术等)的支持，如果是软件客户端则需要远程桌面技术、软件交互技术等技术支持。</p><p>　　2、调度层</p><p>　　saas平台架构的调度层体现分布式系统的特性之一。调度层首先负责识别并通过AAA认证每个用户请求，然后根据业务处理器的负载、业务特征进行合理的调度。通过应用这样的架构SaaS平台可以横向扩展。此外在存储、缓存等方面为了满足平台的横向扩展需求，调度层也必须具有良好的可扩展性。</p><p>　　3、业务层</p><p>　　saas平台架构的业务层负责接收调度层转发过来的请求，而且还要通过对接受到的请求执行真正的业务逻辑。一般来说业务逻辑的执行使用一台服务器就够了。因此业务层实际是由一排对等的服务器组成的，每台服务器都执行相同的业务逻辑。</p><p>　　4、数据层</p><p>　　saas平台架构的数据库集群用于处理存储关系性很强并且对事务性要求很高的业务数据，这类数据目前还要用传统的数据库集群技术来解决，saas平台架构的数据库集群主要是根据业务特征制定数据拆分方案。同时分布式数据库用于存放海量但关系性不强的数据(如：用户的操作日志等)。</p><p>todo…</p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.bilibili.com/read/cv18241782">一文看懂什么是SAAS平台 SAAS平台架构分为哪些？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Saas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析JWT</title>
      <link href="/maple/2023/05/05/JWT/"/>
      <url>/maple/2023/05/05/JWT/</url>
      
        <content type="html"><![CDATA[<h1 id="浅析JWT"><a href="#浅析JWT" class="headerlink" title="浅析JWT"></a>浅析JWT</h1><p>随着移动互联网的兴起，传统基于session/cookie的web网站认证方式转变为了基于OAuth2等开放授权协议的单点登录模式（SSO），相应的基于服务器session+浏览器cookie的Auth手段也发生了转变，Json Web Token的出现成为了当前的热门的Token Auth机制。</p><blockquote><p>Cookie和Session相关概念请见博文：<a href="/maple/2023/05/05/Cookie-Session/">Cookie-Session</a></p></blockquote><h2 id="Json-Web-Token（JWT"><a href="#Json-Web-Token（JWT" class="headerlink" title="Json Web Token（JWT)"></a>Json Web Token（JWT)</h2><p>Json web token (JWT) 是目前最流行的跨域认证解决方案，JWT是一个开放标准 <a href="https://tools.ietf.org/html/rfc7519">(RFC 7519)</a>，它定义了一种紧凑且独立的方式，可以在客户端与服务器之间作为JSON对象安全地传输信息。</p><blockquote><p>官方定义：JSON Web Token (JWT) is a compact URL-safe means of representing claims to be transferred between two parties</p></blockquote><img src="jwt1.png" style="zoom:80%;"><p>现在网上大多数介绍JWT的文章实际介绍的都是JWS（JSON Web Signature），这也往往导致了大家对于JWT的误解，但是JWT并不等于JWS，JWS只是JWT的一种实现，除了JWS外，JWE（JSON Web Encryption）也是JWT的一种实现。</p><p>下面就来详细介绍一下JWS与JWE的两种实现方式：</p><h3 id="JSON-Web-Signature（JWS）"><a href="#JSON-Web-Signature（JWS）" class="headerlink" title="JSON Web Signature（JWS）"></a>JSON Web Signature（JWS）</h3><p>JSON Web Signature 是一个有着简单的统一表达形式的字符串。</p><img src="jwt2.png" style="zoom:60%;"><h4 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h4><p>头部用于描述关于该JWT的最基本的信息，例如：Token类型以及签名所用的算法等。</p><blockquote><p>JSON内容要经Base64 编码生成字符串才能成为Header。</p></blockquote><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span><span class="string">&quot;jwt&quot;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span><span class="string">&quot;HS256&quot;</span> <span class="comment">//加密算法</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure><h4 id="载荷（PayLoad）"><a href="#载荷（PayLoad）" class="headerlink" title="载荷（PayLoad）"></a>载荷（PayLoad）</h4><p>payload的五个字段都是由JWT的标准所定义的。</p><ol><li>iss: 该JWT的签发者；</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方；</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的，即JWT生成的时间；</li></ol><p>还有一些其他的信息没有列举出来，也都是可以按需补充的。</p><blockquote><p>JSON内容要经Base64 编码生成字符串成为PayLoad。</p></blockquote><p><strong>示例</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Maple&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对其进行base64加密，得到JWT的第二部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ</span><br></pre></td></tr></table></figure><h4 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h4><p>这个部分是由base64加密后的header和base64加密后的payload，使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式，并使用密钥secret进行加密，生成签名。</p><p><strong>示例</strong></p><p>由上述base64加密的Header和PayLoad拼接并加密得到签名部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br></pre></td></tr></table></figure><p><strong>JWS的主要目的是保证了数据在传输过程中不被修改，验证数据的完整性。</strong></p><p>上述示例得到的完整的JWT整体格式为 <code>header.payload.signature</code> ，具体值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ.Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br></pre></td></tr></table></figure><h3 id="JSON-Web-Encryption（JWE）"><a href="#JSON-Web-Encryption（JWE）" class="headerlink" title="JSON Web Encryption（JWE）"></a>JSON Web Encryption（JWE）</h3><p>相对于JWS，JWE则同时保证了安全性与数据完整性。JWE由五部分组成：</p><img src="jwt3.png" style="zoom:80%;"><p>具体生成步骤为：</p><ol><li>JOSE含义与JWS头部相同。</li><li>生成一个随机的Content Encryption Key （CEK）。</li><li>使用RSAES-OAEP 加密算法，用公钥加密CEK，生成JWE Encrypted Key。</li><li>生成JWE初始化向量。</li><li>使用AES GCM加密算法对明文部分进行加密生成密文Ciphertext,算法会随之生成一个128位的认证标记Authentication Tag。</li><li>对五个部分分别进行base64编码。</li></ol><p>可见，JWE的计算过程相对繁琐，不够轻量级，因此适合数据传输而非token认证，但该协议也足够安全可靠，用简短字符串描述了传输内容，兼顾数据的安全性与完整性。</p><h2 id="JWT的使用"><a href="#JWT的使用" class="headerlink" title="JWT的使用"></a>JWT的使用</h2><blockquote><p>一般实际开发中说的JWT，实际上都是JWS，所以下述JWT默认就是JWS。</p></blockquote><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT?"></a>什么是JWT?</h3><p>json web token 通过<strong>数字签名</strong>的方法，以<strong>json对象</strong>为载体，在不同的服务器之间安全的传输信息。<br>简单来说：把信息进行安全的封装，以json的形式进行安全的网络传输。</p><h3 id="JWT的作用"><a href="#JWT的作用" class="headerlink" title="JWT的作用?"></a>JWT的作用?</h3><p>JWT最常见的场景就是<strong>授权认证</strong>，一旦用户进行了登录操作，服务端会返回一个JWT(token)给客户端，后续客户端的每个请求都在请求头中带上JWT(token)，系统在每次处理用户请求之前，都要先进行JWT安全校验，通过之后在进行处理。</p><p>用户在提交登录信息后，服务器校验数据后将通过密文的方式来生成一个字符串token返回给客户端，客户端在之后的请求会把token放在header里，在请求到达服务器后，服务器会检验和解密token，如果token被篡改或者失效将会拒绝请求，如果有效则服务器可以获得用户的相关信息并执行请求内容，最后将结果返回。</p><img src="jwt4.png" style="zoom:50%;"><h3 id="SpringCloud下如何使用JWT"><a href="#SpringCloud下如何使用JWT" class="headerlink" title="SpringCloud下如何使用JWT?"></a>SpringCloud下如何使用JWT?</h3><p>在微服务架构下,通常有单独一个服务Auth去管理相关认证，为了安全不会直接让用户访问某个服务，会开放一个入口服务作为网关gateway，所有请求首先访问gateway，由gateway将请求路由到各个服务，通常的做法在网关里进行请求拦截校验，来保证项目的安全性，下图是JWT在微服务中流程图（图中采用非对称加密算法，利用私钥在auth加密，公钥在网关gateway中解密，由此来减轻auth压力，此模型设计并不一定通用，架构设计主要根据实际场景和领域模型划分，可灵活设计并运用JWT）。</p><blockquote><p>针对非对称加密严格地说：公钥加密，私钥解密；私钥加签，公钥验签。</p></blockquote><img src="jwt5.png" style="zoom:80%;"><h2 id="关于JWT有效期与安全性"><a href="#关于JWT有效期与安全性" class="headerlink" title="关于JWT有效期与安全性"></a>关于JWT有效期与安全性</h2><p><strong>JWT如果使用不当，服务器如同裸奔~~~，在使用JWT是一定要注意。</strong></p><p>假如黑客监控电脑，抓包获取到JWT，伪造HTTP请求，对服务器是非常不安全的，常见的问题如下：</p><ul><li><strong>黑客修改HTTP中body的信息进行操作 - 篡改</strong>；<ul><li>修改body之后签名信息就不正确，然后就无法验证签名，说明数据被修改，数字签名的意义所在；</li></ul></li><li><strong>黑客伪造用户JWT进行访问和操作 - 伪造；</strong><ul><li>无法使用服务器的签名，所以在保证密钥不被泄露的情况下，不会被渗透；如果签名算法和秘钥泄露，那就是裸奔了；</li></ul></li><li><strong>黑客窃取JWT，模仿真实用户进行操作 - 冒充；</strong><ul><li>解决办法：<ul><li>对敏感api接口，采用https，https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。</li><li>或者在代码层面进行优化做安全检测：比如根据ip地址，设备码，一次性token机制，token时效期等措施来解决项目安全性问题等等</li></ul></li></ul></li></ul><h2 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此处只是一个Demo，在实际的开发中，还可以进行更个性化的封装，尤其是针对payload荷载部分，一般在开发中需要保存在JWT中的用户信息是一个POJO对象，而原生JWTBuilder中针对荷载部分的设置是使用 <code>claim()</code> 方法，用起来不是很方便，可以进行一个防腐层封装。</p><blockquote><p><strong>防腐层封装的个人思考</strong></p><p>JWT工具类的作用范围定位是全局，甚至是可以将其封装为一个基础的二方包，所以防腐层必须具有通用性，那么就不能使用POJO类型，因为无法确定需要支持的POJO的具体类型，可以考虑使用 Properties类型 、String类型、JSON串等。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.lang.Collections;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JWT工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;Maple&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     * 其中可选的参数是一些辅助性参数,在使用方可以用于一些校验.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> issuer    签发者|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject   JWT所面向的用户主体|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> audience  接收JWT的一方|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis 过期时间|可选</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claimMap  载荷集合,就是需要加密的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String issuer, String subject, String audience, String key, <span class="type">long</span> ttlMillis, HashMap&lt;String, Object&gt; claimMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装自定义秘钥</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generateKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JWT自带的构造器构造一个jwt</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 封装header属性</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;AES&quot;</span>) <span class="comment">// 加密算法类型</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>) <span class="comment">// token类型</span></span><br><span class="line">                <span class="comment">// 封装payload属</span></span><br><span class="line">                .setId(UUID.randomUUID().toString()) <span class="comment">// JWT id,唯一标识</span></span><br><span class="line">                <span class="comment">// .setIssuer(issuer) // 签发者</span></span><br><span class="line">                <span class="comment">// .setSubject(subject) // 面向的用户主体</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// JWT创建时间</span></span><br><span class="line">                .setExpiration(now) <span class="comment">// JWT过期时间</span></span><br><span class="line">                .setAudience(audience) <span class="comment">// 接收JWT的一方</span></span><br><span class="line">                <span class="comment">// 构造signature部分</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装payload里的信息 使用claim方法</span></span><br><span class="line">        <span class="keyword">if</span> (!Collections.isEmpty(claimMap)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : claimMap.entrySet()) &#123;</span><br><span class="line">                builder.claim(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置JWT的过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (ttlMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">            builder.setExpiration(exp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt 待解析的JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Clamins, 即payload部分.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWTClaims</span><span class="params">(String key, String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parseJWT(key, jwt);</span><br><span class="line">        <span class="keyword">return</span> claimsJws.getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 自定义秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt 待解析的JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Jws&lt;Claims&gt;,包含Header,Clamins,Signature三个部分.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title function_">parseJWT</span><span class="params">(String key, String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generateKey(key);</span><br><span class="line">        <span class="comment">// 通过这个签名key对token进行解析</span></span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt);</span><br><span class="line">        <span class="keyword">return</span> claimsJws;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义字符串生成加密的秘钥|用于后续HS256加密加签.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title function_">generateKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">stringKey</span> <span class="operator">=</span> KEY_PREFIX + key;</span><br><span class="line">        <span class="comment">// base64 两种写法</span></span><br><span class="line">        <span class="type">byte</span>[] keySecretBytes = Base64.decodeBase64(stringKey);</span><br><span class="line">        <span class="comment">// byte[] keySecretBytes = DatatypeConverter.parseBase64Binary(stringKey);</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(keySecretBytes, <span class="number">0</span>, keySecretBytes.length, SignatureAlgorithm.HS256.toString());</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Maple&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> createJWT(<span class="string">&quot;Maple&quot;</span>, <span class="string">&quot;Test&quot;</span>, <span class="string">&quot;Wuzi&quot;</span>, <span class="string">&quot;fjeoahgoeja&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>, map);</span><br><span class="line">  System.out.println(<span class="string">&quot;jwt = &quot;</span> + jwt);</span><br><span class="line">  Jws&lt;Claims&gt; claimsJws = parseJWT(<span class="string">&quot;fjeoahgoeja&quot;</span>, jwt);</span><br><span class="line">  System.out.println(claimsJws.getHeader().getAlgorithm());</span><br><span class="line">  System.out.println(claimsJws.getBody().getExpiration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jwt = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyOGYxNmE4YS1mMDM1LTRkYWQtYTFiNy01N2YwNzdmM2ZkZjUiLCJzdWIiOiJUZXN0IiwiaWF0IjoxNjgzMjcxOTE0LCJleHAiOjE2ODMyNzE5NzQsImF1ZCI6Ild1emkiLCJuYW1lIjoiTWFwbGUifQ.Lu1NgVnhdlOYFBrki6HPx15X6hl8tnGB4jGWRdondNQ</span><br><span class="line">HS256</span><br><span class="line">Fri May 05 15:32:54 CST 2023</span><br></pre></td></tr></table></figure><p><font color="#dd0000"><strong>JWT的生成特点：可以重复请求，每次请求都会生成一个新的JWT，旧JWT依旧有效。</strong></font></p><hr><p><strong>参考文档：</strong></p><p><a href="https://www.jianshu.com/p/50ade6f2e4fd">一篇文章带你分清楚JWT,JWS与JWE</a></p><p><a href="https://blog.csdn.net/han1725692339/article/details/126014021">JWT技术简介和使用</a></p><p><a href="https://blog.csdn.net/qq_40162735/article/details/105752127">JWT在微服务系统中的如何应用，如何保证安全性？</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> 令牌 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie &amp; Session</title>
      <link href="/maple/2023/05/05/Cookie-Session/"/>
      <url>/maple/2023/05/05/Cookie-Session/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h1><p>Cookie和Session都是用来在浏览器中跟踪用户身份的会话方式，因为B to S的请求访问都是HTTP请求，而HTTP请求是无状态的，服务器端无法辨识请求是来自哪个客户端。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是一段保存在客户端的<strong>字符串</strong>，能够用来将用户活动过程中的状态信息保存到客户端，服务器可以获得该信息以便进行处理，跟踪用户的状态，一般一个 cookie存储的数据不超过3K。</p><h3 id="Cookie的工作原理："><a href="#Cookie的工作原理：" class="headerlink" title="Cookie的工作原理："></a>Cookie的工作原理：</h3><ol><li>浏览器第一次发送请求到浏览器端；</li><li>服务器端创建一个字符串Cookie，该Cookie中包含用户的信息，然后将该Cookie返回给浏览器端；</li><li>浏览器端再次访问服务器端时会在请求头中携带从服务器端获取的Cookie字符串；</li><li>服务器端通过Cookie中携带的数据便可以区分不同的用户；</li></ol><p>访问百度网站中浏览器中的Cookie示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cookie</span>:<span class="variable constant_">BIDUPSID</span>=7CA7EB951E290B33CA40110D9ED9C0D1; <span class="variable constant_">PSTM</span>=<span class="number">1587792871</span>; <span class="variable constant_">BD_UPN</span>=<span class="number">123253</span>;__yjs_duid=1_9d2ad8f9e190a6d780bbc7d44cd4d11c1620624931104; <span class="variable constant_">BAIDUID</span>=<span class="title class_">BE455C</span>05128<span class="attr">F1594C731E5B0B822F103</span>:<span class="variable constant_">SL</span>=<span class="number">0</span>:<span class="variable constant_">NR</span>=<span class="number">10</span>:<span class="variable constant_">FG</span>=<span class="number">1</span>;...</span><br></pre></td></tr></table></figure><p>PS：字符串很长，后面的省略了。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session是存储在服务器（应用服务器）上的<strong>对象</strong>，该对象由服务器创建并维护，Session存储的数据大小没有限制，服务器会为客户端与服务器的每一次会话过程都创建并维护一个Session对象。</p><h3 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h3><ol><li>浏览器端第一次发送请求到服务器端，服务器端创建一个Session对象，同时会创建一个特殊的Cookie（是随机生成的一个标识Session对象的一个SessionId字符串），然后将该Cookie发送至浏览器端；</li><li>浏览器端发送第N（N&gt;1）次请求到服务器端，浏览器端访问服务器端的时候会在请求头中携带Cookie对象；</li><li>服务器端会根据Cookie的值去查询Session对象，从而区分不同的用户；</li></ol><p>简单的说，当你登陆一个网站的时候，如果web服务器端使用的是Session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话Sessionid（以Cookie的方式，Sessionid是服务器和客户端连接时候随机分配的），服务器根据当前Sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以客户端是无法伪造的。</p><p>如果浏览器使用的是Cookie，那么用户的所有数据都保存在浏览器端，比如：登陆以后，服务器设置了Cookie用户名，那么当再次请求服务器的时候，浏览器会将用户名一起发送给服务器，服务器会解析Cookie变量，所以只要不关闭浏览器，那么Cookie变量一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的Cookie变量，然后伪造一个数据包发送过去，那么服务器会认为你是合法的。所以，使用Cookie被攻击的可能性比较大。</p><p>如果Cookie设置了有效期，那么Cookie会保存到客户端的硬盘上，下次在访问网站的时候，浏览器先检查有没有Cookie，如果有的话，读取Cookie并发送给服务器。所以，如果你在个人PC上面保存了某个论坛Cookie，有效期是一年，如果有人入侵你的PC，将Cookie拷走，放在他的机器下面，那么他登陆该网站的时候就是用你的身份登陆的。当然，伪造的时候需要注意，直接Copy Cookie文件到 Cookie目录，浏览器是不认的，它有一个<code>index.dat</code> 文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 Cookie文件，并且要从保证时间上骗过浏览器。</p><p>两个都可以用来存用户数据，Session过期与否，取决于服务器的设定。Cookie过期与否，可以在Cookie生成的时候设置进去。</p><h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs. Session"></a>Cookie vs. Session</h2><h3 id="1、目标对象不同"><a href="#1、目标对象不同" class="headerlink" title="1、目标对象不同"></a>1、目标对象不同</h3><p><strong>Cookie</strong>：是针对每个网站的信息，每个网站只能对应一个，其他网站无法访问，这个文件保存在客户端，每次访问相应网站，浏览器都会查找该网站的 Cookies，如果有，则会将该文件发送出去。Cookies文件的内容大致上包括了诸如：用户名、密码、设置等信息。</p><p><strong>Session</strong>：是针对每个用户的，只有客户端才能访问，程序为该客户添加一个 Session。Session中主要保存用户的登录信息、操作信息等等。此 Session将在用户访问结束后自动消失。</p><h3 id="2、存储数据大小不同"><a href="#2、存储数据大小不同" class="headerlink" title="2、存储数据大小不同"></a>2、存储数据大小不同</h3><p><strong>Cookie</strong>：一个 Cookie存储的数据不超过3K。</p><p><strong>Session</strong>：Session存储在服务器上可以任意存储数据，当 Session存储数据太多时，服务器可选择进行清理。</p><h3 id="3、生命周期不同"><a href="#3、生命周期不同" class="headerlink" title="3、生命周期不同"></a>3、生命周期不同</h3><p><strong>Cookie</strong>：Cookie的生命周期当浏览器关闭的时候就消亡了，Cookie的生命周期是累计的，从创建时就开始计时，默认30min后Cookie生命周期结束，当然了，用户可以自定义有效时间。</p><p><strong>Session</strong>：Session的生命周期是间隔的，JSESSIONID的Cookie默认过期时间为-1，只需关闭浏览器当前窗口，该Session就会失效，因此Session不能长期有效。</p><h3 id="4、存储位置不同"><a href="#4、存储位置不同" class="headerlink" title="4、存储位置不同"></a>4、存储位置不同</h3><p><strong>Cookie</strong>：Cookie数据保存在客户端，不占用服务器资源。</p><p><strong>Session</strong>：Session数据保存在服务器端，如果数量过多很消耗大量内存空间。</p><h3 id="5、数据类型不同"><a href="#5、数据类型不同" class="headerlink" title="5、数据类型不同"></a>5、数据类型不同</h3><p>两者都是key-value结构，但针对value的类型是有差异的。</p><p><strong>Cookie</strong>：key是固定值：”Cookie”，value只能是ASCII字符串类型。</p><p><strong>Session</strong>：key是SessionId（名为JSESSIONID的一个Cookie），value是object类型。</p><h3 id="6、安全性不同"><a href="#6、安全性不同" class="headerlink" title="6、安全性不同"></a>6、安全性不同</h3><p>Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，如果主要考虑到安全应当使用Session。</p><h3 id="7、跨域支持"><a href="#7、跨域支持" class="headerlink" title="7、跨域支持"></a>7、跨域支持</h3><p>Cookie支持跨域访问；Session不支持跨域访问。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://worktile.com/kb/ask/28045.html">cookie与session区别</a></p><p><a href="https://blog.csdn.net/m0_65421722/article/details/127813102">Cookie和session的区别</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 2」-- Sentinel Dashboard</title>
      <link href="/maple/2023/04/29/Sentinel2-Sentinel-Dashboard/"/>
      <url>/maple/2023/04/29/Sentinel2-Sentinel-Dashboard/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel-Dashboard"><a href="#Sentinel-Dashboard" class="headerlink" title="Sentinel Dashboard"></a>Sentinel Dashboard</h1><p>Sentinel 控制台启动方式有两种：</p><ul><li>Sentinel官网提供了现成的sentinel-dashboard.jar包，down下来，通过<code>java -jar sentinel-dashboard.jar</code> 命令即可启动，默认端口为<code>8080；</code></li><li>下载Sentinel的源码，其中有Sentinel-Dashboard模块，使用Maven的<code>package</code> 命令打包，同样使用<code>java -jar xxx</code> 就可启动；</li></ul><p>启动之后，访问<code>localhost:8080</code>，进入Sentinel Dashboard界面，默认鉴权，账号和密码都为： sentinel</p><img src="dashboard1.png" style="zoom:40%;"><p>如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th><strong>配置项</strong></th><th><strong>默认值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>server.port</td><td>8080</td><td>服务端口</td></tr><tr><td>sentinel.dashboard.auth.username</td><td>sentinel</td><td>默认用户名</td></tr><tr><td>sentinel.dashboard.auth.password</td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar -Dserver.port=8090</span><br></pre></td></tr></table></figure><p>登录之后的主界面如下：</p><p><img src="dashboard2.png"></p><p>注：</p><ul><li>Sentinel 控制台需要有目标资源被调用，才会展示资源的相关配置模块，如果没有调用请求，控制台没有显示的。如上图中的<code>orderservice</code>就是因为已经有调用过该应用资源才会展示。</li><li>其中的流控规则-NACOS是利用Nacos作为注册中心对Sentinel的流控规则进行持久化的模块，需要对Sentinel源码进行修改。</li></ul><h2 id="控制台功能"><a href="#控制台功能" class="headerlink" title="控制台功能"></a>控制台功能</h2><p>根据上图可以清楚的看出Sentinel控制台提供的能力，本文结合个人实际开发中常用的一些功能模块进行介绍。</p><ul><li>实时监控</li><li>簇点链路</li><li>流控规则</li><li>降级规则</li><li>热点规则</li><li>授权规则</li></ul><h3 id="实时监控"><a href="#实时监控" class="headerlink" title="实时监控"></a>实时监控</h3><p>实时监控模块可以进行秒级的实时统计并展示。</p><p><img src="dashboard3.png"></p><h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>簇点链路就是项目内的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><p><img src="dashboard4.png"></p><h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><h4 id="普通流控设置"><a href="#普通流控设置" class="headerlink" title="普通流控设置"></a>普通流控设置</h4><p>可以为每个资源定义流控规则，在簇点链路界中点击目标资源后面的<code>+流控</code> 按钮，就会出现设置页面，如图：</p><img src="dashboard5.png" style="zoom:30%;"><ul><li>资源名：表示需要进行流控的目标资源名称，就是展示在簇点链路页面中所有资源的名称</li><li>针对来源：一般都是default</li><li>阈值类型：QPS or 线程数<ul><li>QPS是指对访问目标资源的QPS进行限制</li><li>线程数是指对访问目标资源的并发度进行限制</li></ul></li><li>单机阈值：单节点的访问限制值</li></ul><p>其含义是限制 <code>/order/&#123;orderId&#125;</code> 这个资源的单机QPS为5，即每秒只允许5次请求，超出的请求会被拦截并报错。</p><h4 id="流控高级选项"><a href="#流控高级选项" class="headerlink" title="流控高级选项"></a>流控高级选项</h4><p>限流规则中有两个高级选项，可以对流控模式和流控效果进行进一步的细化，如图：</p><img src="dashboard6.png" style="zoom:33%;"><h5 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h5><ul><li><p><strong>直接</strong>：统计当前资源的请求，触发阈值时对当前资源直接限流，默认模式；</p></li><li><p><strong>关联</strong>：统计与当前资源相关的另一个资源，当另一个资源触发阈值时，对当前资源限流；</p><ul><li>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。因此当修改订单业务触发阈值时，需要对查询订单业务限流。</li><li>满足下面条件可以使用关联模式：<ul><li>两个有竞争关系的资源；</li><li>一个优先级较高，一个优先级较低；<strong>当优先级高的资源达到阈值之后对优先级低的资源进行限流，高优先级的资源不受影响。</strong></li></ul></li></ul></li></ul><img src="dashboard7.png" style="zoom:35%;"><ul><li><strong>链路</strong>：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流；<ul><li>Sentinel默认只标记<code>Controller</code>层中的方法为资源，如果要标记其它方法，需要利用<code>@SentinelResource</code>注解，如：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryGoods</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO 逻辑处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Sentinel默认会将<code>Controller</code>方法做<code>context整</code>合，导致链路模式的流控失效，需要修改<code>application.yml</code>，添加配置：</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">   <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure><ul><li>使用场景：<ul><li>例如有两条请求链路：<code>/test1 -&gt; /common</code> 和  <code>test2 -&gt; /common</code> 如果只希望统计从<code>/test2</code>进入到<code>/common</code>的请求，则可以这样配置：</li></ul></li></ul><img src="dashboard8.png" style="zoom:40%;"><h5 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h5><p>流控效果是指请求达到流控阈值时采取的措施，包括三种：</p><ul><li><p><strong>快速失败</strong>：请求达到阈值后，新的请求会被立即拒绝并抛出<code>FlowException异常</code>。默认流控效果。</p></li><li><p><strong>warm up</strong>：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p><ul><li><p>warm up也叫预热模式，是应对服务冷启动的一种方案（整体实现的方案和Dubbo的服务预热很类似）。请求阈值初始值是<code> threshold / coldFactor</code>，持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3。</p><p>例如，设置QPS的threshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10。整个过程如图：</p><img src="dashboard9.png" style="zoom:45%;"></li></ul></li><li><p><strong>排队等待</strong>：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长。</p><ul><li><p>当请求超过QPS阈值时，快速失败 和 warm up 都会拒绝新的请求并抛出异常。而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>例如：QPS = 5，意味着理论上每200ms处理一个队列中的请求；timeout = 2000，意味着预期等待超过2000ms的请求会被拒绝并抛出异常。如果队列中已经存在了10个请求，那么后续的请求等待时间理论上就是 10 * 200 ms = 2000ms，已经到达timeout时间了，请求就会被拒绝。</p><img src="dashboard10.png" style="zoom:50%;"></li><li><p>排队等待的限流效果其实就是流量整形</p></li><li><img src="dashboard11.png" style="zoom:50%;"></li></ul></li></ul><h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h3><p><strong>热点参数限流对默认的SpringMVC资源无效，如果需要使用热点规则，需要使用 <code>@SentileResource</code> 注解进行单独标识。</strong></p><p>热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值。</p><img src="dashboard12.png" style="zoom:50%;"><p>如上图，有请求<code>goods/&#123;id&#125;</code>的资源，其中id是热点参数，其值有两种 1,3；如果需要对请求参数<code>id=1</code>进行限流，则需要进行热点参数限流：</p><img src="dashboard13.png" style="zoom: 33%;"><p>在热点参数限流的高级选项中，可以对部分参数设置例外配置：</p><img src="dashboard14.png" style="zoom:33%;"><p>结合上一个配置，这里的含义是对索引值为0号（即请求资源时的第一个参数）的long类型参数限流，每1秒相同参数的QPS不能超过5，有两个例外：</p><ul><li>如果参数值是100，则每1秒允许的QPS为10；</li><li>如果参数值是101，则每1秒允许的QPS为10</li></ul><h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><h3 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h3><hr><p><strong>参考文档：</strong></p>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Sentinel - 1」-- 初识Sentinel</title>
      <link href="/maple/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/"/>
      <url>/maple/2023/04/26/Sentinel1-%E5%88%9D%E8%AF%86Sentinel/</url>
      
        <content type="html"><![CDATA[<h1 id="初识Sentinel"><a href="#初识Sentinel" class="headerlink" title="初识Sentinel"></a>初识Sentinel</h1><h2 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h2><h3 id="认识Sentinel"><a href="#认识Sentinel" class="headerlink" title="认识Sentinel"></a>认识Sentinel</h3><blockquote><p>官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p></blockquote><p><strong>Sentinel 具有以下特征:</strong></p><ul><li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li><li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li><li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li><li><strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。**只要是通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。常见的，可以使用方法签名，URL，甚至服务名称作为资源名来标识资源。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>Sentinel可提供包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p><h2 id="Sentinel-功能和设计理念"><a href="#Sentinel-功能和设计理念" class="headerlink" title="Sentinel 功能和设计理念"></a>Sentinel 功能和设计理念</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><img src="sentinel1.png" style="zoom:40%;"><p>流量控制有以下几个角度:</p><ul><li><strong>资源的调用关系</strong>，例如：资源的调用链路，资源和资源之间的关系；</li><li><strong>运行指标</strong>，例如： QPS、线程池、系统负载等；</li><li><strong>控制的效果</strong>，例如：直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><h4 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h4><p>除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 <a href="https://github.com/Netflix/Hystrix/wiki#what-problem-does-hystrix-solve">Hystrix</a> 里面描述的问题是一样的。</p><img src="sentinel2.png" alt="sentinel2" style="zoom:40%;"><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，慢响应比例升高，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生服务雪崩。</p><blockquote><p><strong>服务雪崩</strong></p><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是服务雪崩。</p><p><strong>服务雪崩解决方案</strong></p><ul><li><strong>超时处理</strong>：设定资源请求的超时时间，请求时间超过阈值没有响应就返回错误信息，不会无休止等待。<ul><li>此种方式并不能从根本上解决问题，如果在超时之前有大量请求进来还是会造成请求堆积，仍然有节点崩溃的风险。而且超时时间的阈值不好确定，只能根据监控的RT统计数据给出一个相对合适的阈值。</li><li>个人理解：此方案只能适用于一些简单并且低流量的系统出现弱网或者网络抖动的场景；</li></ul></li><li><strong>线程隔离（也称为 舱壁模式）</strong>：常见的有两种实现为 <strong>线程池隔离</strong> 和 <strong>信号量隔离</strong>。<ul><li><strong>线程池隔离（Hystrix）</strong>：每个业务资源单独创建并分配一个线程池，将对业务资源的访问限制在线程池内，即使出现异常，最终也只是导致该线程池阻塞，不会影响其他业务资源。<ul><li>优点<ul><li>实现每个业务的完全隔离；</li><li>支持主动超时，即线程池中某个线程执行时间过长，可以主动关闭该线程；</li><li>支持异步调用，即利用线程池的异步特性实现异步调用；</li></ul></li><li>缺点：线程上下文的切换会消耗服务器的资源，极端情况下，服务器的CPU利用率飙升，但是处理能力却反而下降，因为服务器在忙着进行线程的上下文切换，而不是在执行业务。</li><li>场景：适合低扇出场景，即当前服务依赖的其他服务数量少，这样需要创建的线程池数量就少；</li></ul></li><li><strong>信号量隔离（Sentinel）</strong>：内部维护一个计数器，对每个调用的依赖服务的线程数进行统计，限制对依赖方的并发调用线程数；<ul><li>优点：轻量级，无额外开销；</li><li>缺点：<ul><li>不支持主动超时，信号量仅仅是一道控制开关的闸门，请求放行之后就无法控制了，请求的超时时间只能依赖RPC框架；</li><li>不支持异步调用，没有独立线程，无法实现异步调用；</li></ul></li><li>场景：适合高频调用、高扇出场景；</li></ul></li></ul></li><li><strong>熔断降级</strong>：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。<ul><li>内部会维护一个断路器，对单位时间内的业务执行异常比例、错误数量、慢调用比例等进行统计，并结合状态机模式实现断路器状态之间的切换，从而实现对目标场景的熔断降级。</li></ul></li><li><strong>流量控制</strong>：限制业务访问的QPS，避免服务因流量的突增而故障。<ul><li>是一种<strong>故障预防</strong>方案。</li></ul></li></ul></blockquote><h4 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h4><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>（也称为 舱壁模式）的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（Java的线程映射LWP，所以Java的线程切换意味着用户态到内核态的切换和操作系统的线程调度，是一种很重的操作，会影响服务器的性能），还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li><strong>通过并发线程数进行限制</strong></li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，例如：响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li><strong>通过响应时间对资源进行降级</strong></li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h3 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a>系统负载保护</h3><p>Sentinel 同时提供<a href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p><p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p><h2 id="Sentinel-是如何工作的"><a href="#Sentinel-是如何工作的" class="headerlink" title="Sentinel 是如何工作的"></a>Sentinel 是如何工作的</h2><p>Sentinel 的主要工作机制如下：</p><ul><li>对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。</li><li>根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便开发者自定义及改变规则。</li><li>Sentinel 提供实时的监控系统，方便开发者快速了解目前系统的状态。</li></ul><h2 id="服务保护框架对比"><a href="#服务保护框架对比" class="headerlink" title="服务保护框架对比"></a>服务保护框架对比</h2><p>常见的服务保护框架有：Sentinel 和 Hystrix（已经停止更新维护，从GitHub上看最后一次维护代码都是5、6年前了）</p><table><thead><tr><th>核心对比点</th><th><strong>Sentinel</strong></th><th><strong>Hystrix</strong></th></tr></thead><tbody><tr><td><font color="#dd0000"><strong>隔离策略</strong></font></td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td><font color="#dd0000"><strong>熔断降级策略</strong></font></td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td><font color="#dd0000"><strong>限流</strong></font></td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td><font color="#dd0000"><strong>流量整形</strong></font></td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td><font color="#dd0000"><strong>控制台</strong></font></td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><blockquote><p>流量整形：将波动的请求流量整形为均匀的流量，避免尖峰流量对服务器的冲击。</p></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://sentinelguard.io/zh-cn/docs/introduction.html">Sentinel官方文档</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 流量控制框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防盗链</title>
      <link href="/maple/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/"/>
      <url>/maple/2023/04/26/%E9%98%B2%E7%9B%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h1><h2 id="防盗链的定义"><a href="#防盗链的定义" class="headerlink" title="防盗链的定义"></a>防盗链的定义</h2><p><strong>防盗链</strong>其实就是在网络服务器端进行个性化编程，通过URL过滤技术实现对目标资源控制访问。</p><p><strong>比如：</strong></p><p><code>file.maple.com/test.jpg</code>这个图片地址，如果没有装防盗链，那么任意用户都能通过该URL轻而易举的在他的网站上引用这个图片。如果对<code>file.maple.com</code> 这个地址进行服务器端编程，如给URL拼接参数，得到<code>file.maple.com/test.jpg?authcode=xxx&amp;ip=127.0.0.1</code>，自动拼接了ip参数，然后在对URL路由时针对IP参数进行个性化判断，就能实现只有<code>127.0.0.1</code>来访问这个链接，而其它的IP地址则无法访问该链接。</p><h2 id="防盗链的产生"><a href="#防盗链的产生" class="headerlink" title="防盗链的产生"></a>防盗链的产生</h2><p>一般我们在浏览网页时，一个完整的页面并不是客户端通过一次HTTP请求就将全部资源从服务器上拉取下来的，而是会分成很多次HTTP请求。如果客户端所浏览的页面带有图片或其它功能性信息，那么客户端的第一个HTTP请求就是想资源服务器端请求这个页面的文本信息，然后通过客户端的浏览器对服务器返回的数据进行解析，如果发现其中包含图片地址URL，那么客户端的浏览器会自动针对该图片URL再一次发送HTTP请求去获取目标图片并将其放置到目标位置，就这样一个完整的网络页面内部经过多次HTTP请求才能完整的展现出来。</p><p>基于此机制，就会产生盗链的问题。</p><blockquote><p><strong>个人理解</strong></p><p>盗链：全称应该是 盗取网络链接地址。</p></blockquote><p>如果一个网站中没有其页面中的图片信息，那么它完全可以链接访问到其他网站的图片信息。这样，没有任何资源的网站利用了其他网站的资源来展示给浏览者，提高了自己站点的访问量，而大部分浏览者又不会很容易地发现内部资源的调用过程，这样显然对于那些被利用了资源的网站是不公平的。一些不良网站为了不增加成本而扩充自己站点内容，经常盗用其他网站的链接。</p><h2 id="防盗链的实现"><a href="#防盗链的实现" class="headerlink" title="防盗链的实现"></a>防盗链的实现</h2><p>要实现防盗链，首先要理解盗链的实现原理，提到防盗链的实现原理就不得不从HTTP协议说起，在HTTP协议中，有一个表头字段叫 <code>referer</code>，其采用URL的格式来表示从哪儿链接到当前的网页或文件。换句话说，通过referer，网站可以检测到目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示它的网页地址。有了<code>referer</code>跟踪来源就好办了，这时就可以通过技术手段来进行处理，一旦检测到来源不是期望的URL地址，那么就进行拦截或者返回降级页面和资源。 </p><p><strong>HTTP Headerss示例</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:authority: g.csdnimg.cn</span><br><span class="line">:method: GET</span><br><span class="line">:path: /static/logo/favicon32.ico</span><br><span class="line">:scheme: https</span><br><span class="line">accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">if-modified-since: Mon, 24 Apr 2023 09:23:28 GMT</span><br><span class="line">if-none-match: &quot;64464a90-10be&quot;</span><br><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?1</span><br><span class="line">sec-ch-ua-platform: &quot;Android&quot;</span><br><span class="line">sec-fetch-dest: image</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Mobile Safari/537.36</span><br></pre></td></tr></table></figure><p>其中refer为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">referer: https://blog.csdn.net/qq_44543508/article/details/123557819</span><br></pre></td></tr></table></figure><p>如果想对自己的网站进行防盗链保护，需要针对不同的情况进行区别对待。如果网站服务器用的是apache，那么使用apache自带Url Rewrite插件就可以很轻松实现各种防盗链，其原理是检查HTTP请求头中的refer属性值，如果refer的信息来自非目标站点则重定向到指定图片或网页上。还有很多其他的防盗链实现机制，总体上都换汤不换药，都是基于<code>refer</code>属性值进行个性化过滤。</p><hr><p><strong>参考文档：</strong></p><p><a href="http://www.zzbaike.com/wiki/%E9%98%B2%E7%9B%97%E9%93%BE">防盗链</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 防盗链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 协议</title>
      <link href="/maple/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/"/>
      <url>/maple/2023/04/25/Auth-2-0-%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2-0协议"><a href="#OAuth2-0协议" class="headerlink" title="OAuth2.0协议"></a><strong>OAuth2.0协议</strong></h1><h2 id="OAuth2-0-为何物"><a href="#OAuth2-0-为何物" class="headerlink" title="OAuth2.0 为何物"></a><strong>OAuth2.0 为何物</strong></h2><p>OAuth 简单理解就是一种授权机制，它是在客户端和资源所有者之间的授权层，用来分离两种不同的角色。在资源所有者同意并向客户端颁发令牌后，客户端携带令牌就可以访问资源所有者的资源。</p><blockquote><p>OAuth2.0 是OAuth 协议的一个版本，有2.0版本那就有1.0版本，有意思的是OAuth2.0 却不向下兼容OAuth1.0 ，相当于废弃了1.0版本。</p></blockquote><p>举个小栗子解释一下什么是 OAuth 授权？</p><p>订了个外卖，外卖小哥30秒火速到达了我家楼下，奈何有门禁进不来，可以输入密码进入，但出于安全考虑我并不想告诉他密码。此时外卖小哥看到门禁有一个高级按钮“一键获取授权”，只要我这边同意，他会获取到一个有效期 2小时的令牌（token）正常出入。</p><p>令牌（token）和 密码 的作用虽然相似都可以进入系统，但还有点不同。token 拥有权限范围，有时效性的，到期自动失效，而且修改无效。</p><p><strong>OAuth2.0中有四个重要角色：</strong></p><table><thead><tr><th align="center">角色</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">客户端</td><td align="center">本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，常见的就是用户常用的各种客户端，比如：Android客户端、Web客户端（浏览器端）、微信客户端等。</td></tr><tr><td align="center">资源拥有者</td><td align="center">通常为用户，也可以是应用程序，即该资源的拥有者。</td></tr><tr><td align="center">授权服务器（也称认证服务器）</td><td align="center">用于服务提供商对资源拥有的身份进行认证、对访问资源进行授权，认证成功后会给客户端发放令牌 （access_token），作为客户端访问资源服务器的凭据。本例为微信的认证服务器。</td></tr><tr><td align="center">资源服务器</td><td align="center">存储资源拥有者所拥有的资源的服务器，比如：微信侧存储的用户信息。</td></tr></tbody></table><p><strong>拿微信授权其他平台登录为例，该角色在流程中对应关系如下：</strong></p><img src="auth1.png" style="zoom: 30%;"><h2 id="OAuth2-0-授权方式"><a href="#OAuth2-0-授权方式" class="headerlink" title="OAuth2.0 授权方式"></a><strong>OAuth2.0 授权方式</strong></h2><p>OAuth2.0 的授权简单理解其实就是获取令牌（token）的过程，OAuth 协议定义了四种获得令牌的授权方式（authorization grant ）如下：</p><ul><li><strong>授权码（<strong><strong>authorization-code</strong></strong>）</strong></li><li><strong>隐藏式（<strong><strong>implicit</strong></strong>）</strong></li><li><strong>密码式（<strong><strong>password</strong></strong>）：</strong></li><li><strong>客户端凭证（<strong><strong>client credentials</strong></strong>）</strong></li></ul><p>但值得注意的是，不管我们使用哪一种授权方式，在三方应用申请令牌之前，都必须在系统中去申请身份唯一标识：客户端 ID（client ID）和 客户端密钥（client secret）。这样做可以保证 token 不被恶意使用。</p><p>下面我们会分析每种授权方式的原理，在进入正题前，先了解 OAuth2.0 授权过程中几个重要的参数：</p><ul><li>response_type：code 表示要求返回授权码，token 表示直接返回令牌；</li><li>client_id：客户端身份标识；</li><li>client_secret：客户端密钥；</li><li>redirect_uri：重定向地址（用户同意授权之后，三方应用将返回的信息带回时调用的重定向地址，passport-third中三方登录接口的cap地址）；</li><li>scope：表示授权的范围，read只读权限，all读写权限；</li><li>grant_type：表示授权的方式，AUTHORIZATION_CODE（授权码）、password（密码）、client_credentials（凭证式）、refresh_token 更新令牌；</li><li>state：应用程序传递的一个随机数，用来防止CSRF攻击；</li></ul><blockquote><p>CSRF攻击 | 跨站请求伪造</p><p><a href="https://zhuanlan.zhihu.com/p/22521378">CSRF是什么？</a></p></blockquote><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a><strong>授权码</strong></h3><p>OAuth2.0四种授权中授权码方式是最为复杂，但也是安全系数最高的，比较常用的一种方式。这种模式是<strong>四种模式中最安全的一种模式</strong>。一般用于Web服务器端应用或第三方的原生App调用资源服务的时候。适用于兼具前后端的Web项目，因为有些项目只有后端或只有前端，并不适用授权码模式。</p><p>下图我们以用WX登录掘金为例，详细看一下授权码方式的整体流程。</p><img src="auth2.png" style="zoom:80%;"><p>用户选择WX登录掘金，掘金会向WX发起授权请求，接下来 WX询问用户是否同意授权（常见的弹窗授权）。response_type 为 code 要求返回授权码，scope 参数表示本次授权范围为只读权限，redirect_uri 重定向地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=code&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  </span></span><br><span class="line">scope=read</span><br></pre></td></tr></table></figure><p>用户同意授权后，WX 根据 redirect_uri重定向并带上授权码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//juejin.im/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure><p>当掘金拿到授权码（code）时，带授权码和密匙等参数向WX申请令牌。grant_type表示本次授权为授权码方式 authorization_code ，获取令牌要带上客户端密匙 client_secret，和上一步得到的授权码 code。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token? </span></span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp; </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp; </span><br><span class="line">grant_type=authorization_code&amp; </span><br><span class="line">code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp; </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback</span></span><br></pre></td></tr></table></figure><p>最后 WX 收到请求后向 redirect_uri 地址发送 JSON 数据，其中的access_token 就是令牌。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;ACCESS_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;token_type&quot;</span><span class="punctuation">:</span><span class="string">&quot;bearer&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span><span class="number">2592000</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;refresh_token&quot;</span><span class="punctuation">:</span><span class="string">&quot;REFRESH_TOKEN&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;scope&quot;</span><span class="punctuation">:</span><span class="string">&quot;read&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  ...... </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Q：OAuth 2.0为什么不直接返回access_token?要设定为返回auth_code之后再去请求accessToken？</strong></p><p>主要出于安全方考虑，防止中间人攻击。假设第三方应用、授权服务不直接通信，中间隔了一层代理。且第三方应用采用HTTP协议，这样恶意代理就能窃取access token。因此，采用了通过code来交换access token的方式，来增加安全性。并且不能将access_token直接给到用户侧，相对于用户侧网络环境的复杂性，第三方应用自身服务端的网络环境相对更安全。</p><p>特别注意：对于授权码和access_token的篡改，在OAuth 1.0中是反复的对Code和Token进行签名，来保证Token不会被篡改，但是OAuth 2.0中却没有，因为OAuth 2.0是基于Https的，所以如果没有Https的支持OAuth 2.0可能还不如OAuth 1.0。在 OAuth 2.0 中，使用 HTTPS 可以说是必须的，而且 client 有义务验证证书的真假，防止中间人攻击，而 authorization server 和 resource server 都有义务申请可信任的第三方颁发的真实的 SSL 证书。</p></blockquote><h3 id="隐藏式（简化模式）"><a href="#隐藏式（简化模式）" class="headerlink" title="隐藏式（简化模式）"></a><strong>隐藏式（简化模式）</strong></h3><p>授权码模式：</p><img src="auth3.png" style="zoom:50%;"><p>简化版的授权码模式，跳过临时授权码的环节，只要用户一点击授权，就能直接返回access_token，而不是通过授权码code再次去获取。</p><img src="auth4.png" style="zoom:50%;"><blockquote><p>参数描述同授权码模式 ，注意response_type=token，说明是简化模式。</p></blockquote><p>上边提到有一些Web应用是没有后端的， 属于纯前端应用，无法用上边的授权码模式。令牌的申请与存储都需要在前端完成，跳过了授权码这一步。</p><p>前端应用直接获取 token，response_type 设置为 token，要求直接返回令牌，跳过授权码，WX授权通过后重定向到指定 redirect_uri 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/authorize?  </span></span><br><span class="line">response_type=token&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">redirect_uri=<span class="attr">http</span>:<span class="comment">//juejin.im/callback&amp;  scope=read</span></span><br></pre></td></tr></table></figure><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a><strong>密码式</strong></h3><img src="auth5.png" style="zoom: 25%;"><p>密码模式比较好理解，用户在掘金直接输入自己的WX用户名和密码，掘金拿着信息直接去WX申请令牌，请求响应的 JSON结果中返回 token。grant_type 为 password 表示密码式授权。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?  </span></span><br><span class="line">grant_type=password&amp;  </span><br><span class="line">username=<span class="variable constant_">USERNAME</span>&amp;  </span><br><span class="line">password=<span class="variable constant_">PASSWORD</span>&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span></span><br></pre></td></tr></table></figure><p>这种授权方式简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下，或者第一方原生APP或第一方单页面应用。</p><h3 id="客户端凭证式"><a href="#客户端凭证式" class="headerlink" title="客户端凭证式"></a><strong>客户端凭证式</strong></h3><img src="auth6.png" style="zoom:25%;"><p>凭证式和密码式很相似，主要适用于那些没有前端的命令行应用，可以用最简单的方式获取令牌，在请求响应的 JSON 结果中返回 token。</p><p>grant_type 为 client_credentials 表示凭证式授权，client_id 和 client_secret 用来识别身份。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/token?  </span></span><br><span class="line">grant_type=client_credentials&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span></span><br></pre></td></tr></table></figure><h2 id="令牌的使用与更新"><a href="#令牌的使用与更新" class="headerlink" title="令牌的使用与更新"></a><strong>令牌的使用与更新</strong></h2><h3 id="1、令牌怎么用？"><a href="#1、令牌怎么用？" class="headerlink" title="1、令牌怎么用？"></a><strong>1、令牌怎么用？</strong></h3><p>拿到令牌可以调用 WX API 请求数据了，那令牌该怎么用呢？</p><p>每个到达WX的请求都必须带上 token，将 token 放在 http 请求头部的一个Authorization字段里。</p><p>如果使用postman 模拟请求，要在Authorization -&gt; Bearer Token 放入 token，注意：低版本postman 没有这个选项。</p><p><img src="auth7.png"></p><h3 id="2、令牌过期怎么办？"><a href="#2、令牌过期怎么办？" class="headerlink" title="2、令牌过期怎么办？"></a><strong>2、令牌过期怎么办？</strong></h3><p>token是有时效性的，一旦过期就需要重新获取，但是重走一遍授权流程，不仅麻烦而且用户体验也不好，那如何让更新令牌变得优雅一点呢？</p><p>一般在颁发令牌时会一次发两个令牌，一个令牌用来请求API，另一个负责更新令牌 refresh_token。grant_type 为 refresh_token 请求为更新令牌，参数 refresh_token 是用于更新令牌的令牌。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//wx.com/oauth/token?  </span></span><br><span class="line">grant_type=refresh_token&amp;  </span><br><span class="line">client_id=<span class="variable constant_">CLIENT_ID</span>&amp;  </span><br><span class="line">client_secret=<span class="variable constant_">CLIENT_SECRET</span>&amp;  </span><br><span class="line">refresh_token=<span class="variable constant_">REFRESH_TOKEN</span></span><br></pre></td></tr></table></figure><h3 id="3、令牌的维护"><a href="#3、令牌的维护" class="headerlink" title="3、令牌的维护"></a>3、令牌的维护</h3><p>因为各大三方开放平台，比如：支付宝、微信等等，access_token的特点是重复请求获取会刷新，每次请求获取access_token得到的都是不同的值，所以一般实际开发中，针对access_token会集中进行维护和管理，避免在多个应用中使用时会出现重新请求获取access_token导致旧access_token过期，从而三方业务请求失败，这种场景就是常说的：共享token问题。在实际开发中应尽量避免，因为一旦发生排查起来会很困难。</p><hr><p><strong>参考文档：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/327856449">OAuth2.0 的四种授权方式，值得一看</a></p><p><a href="https://blog.csdn.net/weixin_45525272/article/details/125920928">OAuth2.0 四种授权模式（图解）</a></p><p><a href="https://www.cnblogs.com/yakniu/p/16387713.html">OAuth 2.0 授权认证详解</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 认证鉴权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位枚举</title>
      <link href="/maple/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"/>
      <url>/maple/2023/04/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="位枚举"><a href="#位枚举" class="headerlink" title="位枚举"></a>位枚举</h1><p>也称为 二进制枚举。</p><h2 id="什么是位枚举"><a href="#什么是位枚举" class="headerlink" title="什么是位枚举"></a>什么是位枚举</h2><p>位枚举也是一个枚举类，只不过其是利用二级制位运算来实现与枚举项的比较、包含、不包含等运算，其主要思想就是利用高性能的位运算操作来替换传统的大小比较，集合是否包含等方法，以此来进一步提高业务代码的性能。</p><p><strong>常见的使用场景：</strong></p><ul><li>标签字段</li><li>类型字段</li><li>等…</li></ul><p>位枚举并不复杂。下面以标签字段的应用场景分别使用传统的枚举操作和位枚举进行对比说明，加深对位枚举的理解和应用。</p><h2 id="传统枚举"><a href="#传统枚举" class="headerlink" title="传统枚举"></a>传统枚举</h2><p>枚举类定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标签枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderTagEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL_ORDER(<span class="number">1</span>, <span class="string">&quot;普通订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    SECKILL_ORDER(<span class="number">2</span>, <span class="string">&quot;秒杀订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    THIRD_SERVICE_ORDER(<span class="number">3</span>, <span class="string">&quot;三方服务订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    OrderTagEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderTagEnum <span class="title function_">getEnumByCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> tagEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库中的标签字段定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags<span class="type">varchar</span>(<span class="number">64</span>)<span class="keyword">null</span> comment <span class="string">&#x27;标签,List的json串&#x27;</span>,</span><br></pre></td></tr></table></figure><p>如此，当我们以传统形式的枚举去表示标签时，那么对应的数据库表中对应的字段存储的值形式会是下图这样的格式（在代码防腐层，保存前我们会将以<code>List&lt;Integer&gt;</code>集合形式存储的tags标签值转换为Json字符串），常用的序列化组件有：Jackson、Gson、Fastjson等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">tagsJson</span> <span class="operator">=</span> gson.toJson(Lists.newArrayList(OrderTagEnum.SECKILL_ORDER.getCode(), OrderTagEnum.THIRD_SERVICE_ORDER.getCode()));</span><br></pre></td></tr></table></figure><p>存储的结果如下图：</p><p><img src="enum1.png"></p><p>与保存时对应，当进行数据库查询时，我们去查询库表，同样在代码防腐层会进行发序列化处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">List&lt;Integer&gt; tagList = gson.fromJson(order.getTags(), <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;List&lt;Integer&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure><h3 id="传统枚举场景分析"><a href="#传统枚举场景分析" class="headerlink" title="传统枚举场景分析"></a>传统枚举场景分析</h3><h4 id="性能侧"><a href="#性能侧" class="headerlink" title="性能侧"></a>性能侧</h4><p>在以上使用传统枚举的过程中，保存数据库之前将标签字段序列化为Json串，查询数据库时再将Json串反序列化为List集合，在代码防腐层对标签字段的这两次序列化和反序列化操作，相比于标签字段直接存储，严格意义上来说是会存在一定的性能损耗，但是随着序列化组件性能的不断优化和服务器性能的提升，这两次序列化和反序列化操作对代码性能的影响可忽略不计，当然，这也不是位枚举的核心意义之所在。</p><h4 id="数据库侧"><a href="#数据库侧" class="headerlink" title="数据库侧"></a>数据库侧</h4><p><strong>增 | 改</strong> 都是针对数据库原数据新增和更新操作，剩下就是上述性能侧同样的问题。</p><p><font color="#dd0000"><strong>查 | 删</strong> </font>就会涉及到数据库原数据字段的业务操作，比如：查询、统计或者删除指定标签的记录，判断记录是否包含指定标签等场景。针对这些逻辑使用传统的枚举实现的步骤为：</p><ol><li><font color="\#00dd00">分页批量查询所有记录或者利用字符串模糊查询目标记录；</font></li><li>将tags字段反序列化为<code>List&lt;Integer&gt;</code>；</li><li><font color="\#00dd00">利用List集合的API方法，指定标签值；</font></li><li>进行后续逻辑处理；</li></ol><p>其中，<code>步骤1</code>和<code>步骤3</code>是整个业务链路中性能影响最明显的环节，同时，此环节也是<strong>位枚举的核心意义之所在</strong>。</p><h2 id="位枚举-1"><a href="#位枚举-1" class="headerlink" title="位枚举"></a>位枚举</h2><p>位枚举是指利用<strong>位运算实现的枚举类，枚举的code值必须是2的幂数，一般使用2^0，2^1，2^2，…依次递增</strong>。这样的话我们就可以利用位运算去快速的处理和枚举相关的业务。说到位运算大家第一反应应该都是<strong>速度嘎嘎快</strong>。</p><h3 id="位枚举的核心思想"><a href="#位枚举的核心思想" class="headerlink" title="位枚举的核心思想"></a>位枚举的核心思想</h3><ul><li><font color="#dd0000">枚举项的code值请以2的幂数递增，如: 1,2,4,8,16,32,64,128… </font></li><li><font color="#dd0000">任意两个整数m和n，如果m和n都是2的幂数，那么m和n进行按位<strong>或运算</strong>的结果就等于m和n的<strong>字面值相加</strong> </font> ，什么意思呢？<ul><li>即：m|n = m+n，如m=2，n=4，那么m|n = 6。此处等价于<strong>加法运算</strong>。</li></ul></li><li><font color="#dd0000">任意两个整数m和n，如果m和n都是2的幂数，p是m和n按位或的结果，那么就有p&amp;n=n，p&amp;m=m，类似于减法运算。 </font></li></ul><p><strong>位枚举定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标签位枚举.</span></span><br><span class="line"><span class="comment"> * ps: 枚举项的code值请以2的幂数递增，如: 1,2,4,8,16,32,64,128....</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Maple</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderTagEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    NORMAL_ORDER(<span class="number">1</span>, <span class="string">&quot;普通订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    SECKILL_ORDER(<span class="number">2</span>, <span class="string">&quot;秒杀订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    THIRD_SERVICE_ORDER(<span class="number">4</span>, <span class="string">&quot;三方服务订单&quot;</span>),</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    OrderTagEnum(<span class="type">int</span> code, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过枚举项值获取对应的枚举项</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderTagEnum <span class="title function_">getEnumByCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(code)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tagEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> tagEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断入参tag是否包含tagEnum枚举项.</span></span><br><span class="line"><span class="comment">     * 一个整数 &amp; 枚举项code = 枚举项code,表示该整数包含枚举项.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag     多个标签的code累加和.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagEnum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isHasTag</span><span class="params">(Integer tag, OrderTagEnum tagEnum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tag) || Objects.isNull(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (tagEnum.getCode() &amp; tag) == tagEnum.getCode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取tag包含的所有标签枚举集合.</span></span><br><span class="line"><span class="comment">     * 传入给定整数和任意枚举项进行按位与运算,结果等于枚举项本身，说明给定整数包含此枚举项.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag 多个标签的code累加和.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;OrderTagEnum&gt; <span class="title function_">getTagEnumList</span><span class="params">(Integer tag)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(tag)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;OrderTagEnum&gt; tagList = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : OrderTagEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((tagEnum.getCode() &amp; tag) == tagEnum.getCode()) &#123;</span><br><span class="line">                tagList.add(tagEnum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tagList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举项集合按位或运算 得到所有爱好的整数结果.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tagEnumList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">calculate</span><span class="params">(List&lt;OrderTagEnum&gt; tagEnumList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tagEnumList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderTagEnum tagEnum : tagEnumList) &#123;</span><br><span class="line">            result |= tagEnum.getCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的数据库标签字段也修改为Long类型，而不再是Json字符串：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags<span class="type">bigint</span><span class="keyword">null</span> comment <span class="string">&#x27;标签&#x27;</span>,</span><br></pre></td></tr></table></figure><p>数据库标签字段存储变成了：</p><p><img src="enum2.png"></p><h3 id="位枚举场景分析"><a href="#位枚举场景分析" class="headerlink" title="位枚举场景分析"></a>位枚举场景分析</h3><p><strong>增 | 改</strong> 都是针对数据库原数据增加或者更新操作，代码防腐层不再需要序列化和反序列化操作。</p><p><font color="#dd0000"><strong>查 | 删</strong> </font> 同样是查询、统计或者删除指定标签的记录，判断记录是否包含指定标签等场景。步骤就变成了业务代码的位运算和SQL脚本的位运算。</p><p>如：查询三方服务标签和秒杀标签的记录。</p><p> 秒杀标签code | 三方服务标签code : 2 | 4 = 6，调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long tagValue = OrderTagEnum.calculate(Arrays.asList(OrderTagEnum.NORMAL_ORDER,OrderTagEnum.THIRD_SERVICE_ORDER));</span><br></pre></td></tr></table></figure><p>到SQL层面，入参#{tagValue}就为6，SQL层使用位与运算，就可以查询到所有包含三方服务标签和秒杀标签的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cloud_order.tb_order</span><br><span class="line"><span class="keyword">where</span> #&#123;tagValue&#125; <span class="operator">=</span>  tags <span class="operator">&amp;</span> #&#123;tagValue&#125;;</span><br></pre></td></tr></table></figure><p>tagValue为6时的结果：</p><p><img src="enum3.png"></p><p>查询到结果之后，在代码层调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderTagEnum&gt; tagList = OrderTagEnum.getTagEnumList(tagValue);</span><br></pre></td></tr></table></figure><p>得到目标值tagValue包含的所有标签枚举项列表。</p><blockquote><p>一般情况下，位枚举相关业务涉及到数据库的操作时，通常也需要结合SQL的位运算来支撑位枚举。</p></blockquote><hr><p><strong>参考文档：</strong></p><p><a href="https://baijiahao.baidu.com/s?id=1746867064605404073&wfr=spider&for=pc">位枚举应用</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
