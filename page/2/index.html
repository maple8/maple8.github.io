<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Maple's  Blog</title><meta name="author" content="Maple"><meta name="copyright" content="Maple"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一 切 都 是 最 好 的 安 排 !">
<meta property="og:type" content="website">
<meta property="og:title" content="Maple&#39;s  Blog">
<meta property="og:url" content="https://maple8.github.io/page/2/index.html">
<meta property="og:site_name" content="Maple&#39;s  Blog">
<meta property="og:description" content="一 切 都 是 最 好 的 安 排 !">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://maple8.github.io/img/avatar1.jpeg">
<meta property="article:author" content="Maple">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://maple8.github.io/img/avatar1.jpeg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://maple8.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":800},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":22,"languages":{"author":"作者: Maple","link":"链接: ","source":"来源: Maple's  Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Maple\'s  Blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-05-06 16:15:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/maple_background.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar1.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-blog"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-mug-hot"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 摄影</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-running"></i><span> 体育</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/yuqiu/"><i class="fa-fw fas fa-volleyball-ball"></i><span> 羽毛球</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 笔者</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background: linear-gradient(to right, #1fa2ff, #12d8fa, #a6ffcb)"><nav id="nav"><span id="blog-info"><a href="/" title="Maple's  Blog"><span class="site-name">Maple's  Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-blog"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-mug-hot"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 摄影</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-running"></i><span> 体育</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/yuqiu/"><i class="fa-fw fas fa-volleyball-ball"></i><span> 羽毛球</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Maple's  Blog</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://maple8.github.io/" target="_blank" title="Old Version Blog"><i class="fas fa-blog"></i></a><a class="social-icon" href="https://gitee.com/maple_eitba" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:maple_eitba@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=790379323&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/26/Lombok/" title="Lombok"><img class="post-bg" src="/top_img/lombok.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lombok"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/26/Lombok/" title="Lombok">Lombok</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-26T09:05:21.000Z" title="发表于 2023-06-26 17:05:21">2023-06-26</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-10T16:18:31.866Z" title="更新于 2023-11-11 00:18:31">2023-11-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Lombok/">Lombok</a></span></div><div class="content">1. Lombok简介
官方介绍： Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.
官网地址：Project Lombok

意思：Lombok是一个java库，它可以自动插入编辑器和构建工具中，以提升java性能。不需要另外编写getter或equals方法，使用一个注解，你的类就有一个功能齐全的生成器，自动记录变量，等等。
简而言之：Lombok能以简单的注解形式来简化java代码，提高开发人员的效率。
2. Lombok使用使用Lombok需要的开发环境为：Java + Maven + In ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/06/22/%E5%88%86%E9%94%80/" title="分销业务场景"><img class="post-bg" src="https://img.iisp.com/image/20160629/20160629135639_27910.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分销业务场景"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/22/%E5%88%86%E9%94%80/" title="分销业务场景">分销业务场景</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-22T03:45:29.000Z" title="发表于 2023-06-22 11:45:29">2023-06-22</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-18T03:36:15.335Z" title="更新于 2024-03-18 11:36:15">2024-03-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84/">业务架构</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E9%94%80/">分销</a></span></div><div class="content">分销一、什么是分销在西方经济学中，分销的含义是建立销售渠道的意思。分销渠道又叫营销渠道，是指某种商品或服务从生产者向消费者转移的过程中，获取这种商品或服务的所有权，帮助所有权转移的所有企业和个人。
分销，简单的说，就是让更多的人帮助企业卖货，企业通过裂变分销，实现分销渠道裂变从而达到销售商品的目的。企业为了销售商品，主要的任务是把自己的商品销售出去来获取更多的利润。

传统的销售渠道就是公司招聘销售员，由销售员进行推销产品，另外也会通过互联网进行一些宣传，总而言之一切都是为了把货卖出去。而分销模式是通过分销员向自己身边的朋友以及家人宣传和推广商品并且成交订单，分销员就可以获得一定比例的返佣。


分销的三级代理模式：


二、分销模式的应用分销模式主要是商家在销售商品或服务时，通过其用户的粉丝效应或者朋友交际圈来扩大销售覆盖人群最终实现商品的销售，在电商、保险、信用卡、社区团购较为常见。我们平常在进行商品下单的时候，常需要我们填些推荐码时，或者通过专属的分享链接进行下单，例如我们常见的有淘宝联盟、直播电商平台中主播挂的购物链接等等，这都是属于分销模式。
分销模式最主要的特点为：下级的收 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/08/Sentinel7-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96/" title="「Sentinel - 7」-- 规则配置持久化"><img class="post-bg" src="https://img2.baidu.com/it/u=3576658838,828136920&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=288" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Sentinel - 7」-- 规则配置持久化"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/08/Sentinel7-%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96/" title="「Sentinel - 7」-- 规则配置持久化">「Sentinel - 7」-- 规则配置持久化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-08T14:30:22.000Z" title="发表于 2023-06-08 22:30:22">2023-06-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-12T01:36:08.105Z" title="更新于 2023-06-12 09:36:08">2023-06-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6/">流量控制框架</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Sentinel/">Sentinel</a></span></div><div class="content">规则配置持久化规则Sentinel 的理念是开发者只需要关注资源的定义，当资源定义成功后可以动态增加各种流控降级规则。Sentinel 提供两种方式修改规则：

通过 API 直接修改 (loadRules)
通过 DataSource 适配不同数据源修改

通过 API 修改比较直观，可以通过以下几个 API 修改不同的规则：
12FlowRuleManager.loadRules(List&lt;FlowRule&gt; rules); // 修改流控规则DegradeRuleManager.loadRules(List&lt;DegradeRule&gt; rules); // 修改降级规则

手动修改规则（硬编码方式）一般仅用于测试和演示，生产上一般通过动态规则源的方式来动态管理规则。
规则管理模式Sentinel的控制台规则管理有三种模式：Sentinel的规则默认是保存在内存中，Sentinel重启之后规则就会丢失



推送模式
说明
优点
缺点



原始模式
API 将规则推送至客户端并直接更新到内存中，扩展写数据源（WritableDataSource），默认就是这 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/06/07/Sentinel6-%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%9D%E6%8A%A4/" title="「Sentinel - 6」-- 系统自适应保护 &amp; 来源控制"><img class="post-bg" src="https://img2.baidu.com/it/u=3576658838,828136920&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=288" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Sentinel - 6」-- 系统自适应保护 &amp; 来源控制"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/07/Sentinel6-%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E4%BF%9D%E6%8A%A4/" title="「Sentinel - 6」-- 系统自适应保护 &amp; 来源控制">「Sentinel - 6」-- 系统自适应保护 &amp; 来源控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T09:40:33.000Z" title="发表于 2023-06-07 17:40:33">2023-06-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T09:44:58.166Z" title="更新于 2023-06-07 17:44:58">2023-06-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6/">流量控制框架</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Sentinel/">Sentinel</a></span></div><div class="content">系统自适应保护Sentinel 系统自适应保护从整体维度对应用入口流量进行控制，结合应用的 Load、总体平均 RT、入口 QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。
背景在开始之前，先回顾一下 Sentinel 做系统自适应保护的目的：

保证系统不被拖垮
在系统稳定的前提下，保持系统的吞吐量

长期以来，系统自适应保护的思路是根据硬指标，即系统的负载 (load1) 来做系统过载保护。当系统负载高于某个阈值，就禁止或者减少流量的进入；当 load 开始好转，则恢复流量的进入。这个思路给我们带来了不可避免的两个问题：

load 是一个“果”，如果根据 load 的情况来调节流量的通过率，那么就始终有延迟性。也就意味着通过率的任何调整，都会过一段时间才能看到效果。当前通过率是使 load 恶化的一个动作，那么也至少要过 1 秒之后才能观测到；同理，如果当前通过率调整是让 load 好转的一个动作，也需要 1 秒之后才能继续调整，这样就浪费了系统的处理能力。所以我们看到的曲线，总是会有抖动。
恢 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/07/Sentinel5-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/" title="「Sentinel - 5」-- 熔断降级"><img class="post-bg" src="https://img2.baidu.com/it/u=3576658838,828136920&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=288" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Sentinel - 5」-- 熔断降级"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/07/Sentinel5-%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/" title="「Sentinel - 5」-- 熔断降级">「Sentinel - 5」-- 熔断降级</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T09:14:40.000Z" title="发表于 2023-06-07 17:14:40">2023-06-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T09:39:43.688Z" title="更新于 2023-06-07 17:39:43">2023-06-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6/">流量控制框架</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Sentinel/">Sentinel</a></span></div><div class="content">熔断降级概述除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。


现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。

注意：本文档针对 Sentinel 1.8.0 及以上版本。1.8.0 版本对熔断降级特性进行了全新的改进升级，请使用最新版本以更好地利用熔断降 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/06/07/Sentinel4-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/" title="「Sentinel - 4」-- 热点参数限流"><img class="post-bg" src="https://img2.baidu.com/it/u=3576658838,828136920&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=288" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Sentinel - 4」-- 热点参数限流"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/07/Sentinel4-%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81/" title="「Sentinel - 4」-- 热点参数限流">「Sentinel - 4」-- 热点参数限流</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T08:12:29.000Z" title="发表于 2023-06-07 16:12:29">2023-06-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T09:12:53.923Z" title="更新于 2023-06-07 17:12:53">2023-06-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6/">流量控制框架</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Sentinel/">Sentinel</a></span></div><div class="content">热点参数限流热点参数规则热点参数规则（ParamFlowRule）类似于流量控制规则（FlowRule）：



属性
说明
默认值



resource
资源名，必填



count
限流阈值，必填



grade
限流模式
QPS 模式


durationInSec
统计窗口时间长度（单位为秒），1.6.0 版本开始支持
1s


controlBehavior
流控效果（支持快速失败和匀速排队模式），1.6.0 版本开始支持
快速失败


maxQueueingTimeMs
最大排队等待时长（仅在匀速排队模式生效），1.6.0 版本开始支持
0ms


paramIdx
热点参数的索引，必填，对应 SphU.entry(xxx, args) 中的参数索引位置



paramFlowItemList
参数例外项，可以针对指定的参数值单独设置限流阈值，不受前面 count 阈值的限制。仅支持基本类型和字符串类型



clusterMode
是否是集群参数流控规则
false


clusterConfig
集群流控相关配置



我们可以通过 ParamFlowRuleM ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/06/07/Sentinel3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" title="「Sentinel - 3 」-- 流量控制&amp;规则"><img class="post-bg" src="https://img2.baidu.com/it/u=3576658838,828136920&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=288" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Sentinel - 3 」-- 流量控制&amp;规则"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/07/Sentinel3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/" title="「Sentinel - 3 」-- 流量控制&amp;规则">「Sentinel - 3 」-- 流量控制&amp;规则</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T07:42:11.000Z" title="发表于 2023-06-07 15:42:11">2023-06-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T10:12:06.204Z" title="更新于 2023-06-07 18:12:06">2023-06-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6/">流量控制框架</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Sentinel/">Sentinel</a></span></div><div class="content">流量控制&amp;规则流量控制规则 (FlowRule)流量规则的定义重要属性：



Field
说明
默认值



resource
资源名，资源名是限流规则的作用对象



count
限流阈值



grade
限流阈值类型，QPS 或线程数模式
QPS 模式


limitApp
流控针对的调用来源
default，代表不区分调用来源


strategy
调用关系限流策略：直接、链路、关联
根据资源本身（直接）


controlBehavior
流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流
直接拒绝


同一个资源可以同时有多个限流规则。
通过代码定义流量控制规则理解上面规则的定义之后，我们可以通过调用 FlowRuleManager.loadRules() 方法来用硬编码的方式定义流量控制规则，比如：
1234567891011private static void initFlowQpsRule() &#123;    List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;();    Flow ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/06/07/Sentinel2-Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="「Sentinel - 2」-- Sentinel基本使用"><img class="post-bg" src="https://img2.baidu.com/it/u=3576658838,828136920&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=PNG?w=500&amp;h=288" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Sentinel - 2」-- Sentinel基本使用"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/06/07/Sentinel2-Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="「Sentinel - 2」-- Sentinel基本使用">「Sentinel - 2」-- Sentinel基本使用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-07T07:22:36.000Z" title="发表于 2023-06-07 15:22:36">2023-06-07</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T07:43:11.423Z" title="更新于 2023-06-07 15:43:11">2023-06-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%A1%86%E6%9E%B6/">流量控制框架</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Sentinel/">Sentinel</a></span></div><div class="content">Sentinel基本使用简介Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。
我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:

定义资源
定义规则
检验规则是否生效

先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。

对于主流的框架，我们提供适配，只需要按照适配中的说明配置，Sentinel 就会默认定义提供的服务，方法等为资源。

定义资源方式一：主流框架的默认适配为了减少开发的复杂程度，我们对大部分的主流框架，例如 Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux、Reactor 等都做了适配。您只需要引入对应的依赖即可方便地整合 Sentinel。可以参见：主流框架的适配。

我们 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/29/Vim/" title="Vim基础"><img class="post-bg" src="/top_img/vim.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vim基础"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/29/Vim/" title="Vim基础">Vim基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-29T03:24:11.000Z" title="发表于 2023-05-29 11:24:11">2023-05-29</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-30T10:19:46.918Z" title="更新于 2023-05-30 18:19:46">2023-05-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/vim/">vim</a></span></div><div class="content">Vim基础Vim的操作模式Vim有四种操作模式，分别为：

正常模式(normal-mode)
插入模式(insert-mode)
命令模式(command-mode)
可视模式(visual-mode)

①  正常模式正常模式主要用来浏览和修改文本内容的。
一般的打开Vim之后默认的都是正常模式。在任何模式下，只要按下 Esc 键就可以返回正常模式。
② 插入模式插入模式是用来向文本中添加内容的。
i：表示进入插入模式，并在光标所在字符前开始输入；
a：表示进入插入模式，并在光标所在字符后开始输入；
o (字母o)：表示进入插入模式并在光标所在行的下一新行开始输入；
s：表示进入插入模式，并删除光标所在的字符；
I：在行首开始输入文字并进入插入模式。此行首指第一个非空白字符处。如果行首有空格，则在    空格之后输入文字并进入插入模式；
A：在行尾开始输入文字并进入插入模式。这个好用，您不必管光标在此行的什麽地方，只要按 A 就会在行尾等着您输入文字；
O (大写字母O)：在光标所在行的上面单独开一新行来输入文字并进入插入模式；
S：删除光标所在行并进入插入模式；
③ 命令模式命令 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="「设计模式」- 单例模式"><img class="post-bg" src="/top_img/designpattern.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「设计模式」- 单例模式"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" title="「设计模式」- 单例模式">「设计模式」- 单例模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-23T05:38:52.000Z" title="发表于 2023-05-23 13:38:52">2023-05-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-18T03:28:06.478Z" title="更新于 2024-03-18 11:28:06">2024-03-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/OOA-OOD/">OOA&amp;OOD</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a></span></div><div class="content">单例模式饿汉式在类加载的时候直接将Singleton对象提前创建好，等需要用的时候调用getSingleton()方法获取即可。
提前创建，是一种空间换时间的方式，无法实现延迟加载。
12345678910111213141516171819/** * 饿汉式 * 特点: * 1. 空间换时间 -- 一上来就创建对象(慢),后面直接用就好; * 2. 线程安全; */class Singleton &#123;    // 私有构造方法,其他类不能访问该构造方法，即无法通过构造器来实例化对象    private Singleton() &#123;    &#125;    // 私有当前类的实例对象,让外部对象无法直接对其进行访问    private static final Singleton s = new Singleton();    // 对外提供公共的访问方法    public static Singleton getS() &#123;        return s;    &#125;&#125;


JDK源码中的典型实现： java.lang.Runtim ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/23/%E6%B5%85%E6%9E%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/" title="浅析面向对象和面向过程"><img class="post-bg" src="/top_img/oo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅析面向对象和面向过程"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/23/%E6%B5%85%E6%9E%90%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/" title="浅析面向对象和面向过程">浅析面向对象和面向过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-23T03:01:49.000Z" title="发表于 2023-05-23 11:01:49">2023-05-23</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-23T03:36:55.814Z" title="更新于 2023-05-23 11:36:55">2023-05-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/">面向对象，面向过程</a></span></div><div class="content">浅析面向对象和面向过程面向过程和面向对象都是对软件分析、设计和开发的一种思想，它指导着开发者以不同的方式去分析、设计和开发软件。 
早期先有面向过程思想，随着软件规模的扩大，问题复杂性的提高，面向过程的不足也越来越明显，随之应运而生的就是面向对象思想，并成为目前开发者们使用的主流思想。两者都贯穿于软件分析、设计和开发各个阶段，根据面向对象思想的使用场景，又可以分别称为 面向对象分析（OOA）、面向对象设计（OOD）和面向对象编程（OOP）。

C语言是一种典型的面向过程语言，Java是一种典型的面向对象语言。

面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 这种适合简单的任务，不需要过多协作的情况下。比如，如何开车？我们很容易就列出实现步骤：
点火 –&gt; 挂挡 –&gt; 给油 –&gt; 走你
面向过程适合简单、不需要太多模块协作的事务，重点关注如何一步一步地执行。
但是当我们思考比较复杂的设计任务时，比如“如何造车？”，就会发现列出1234这样的步骤，是不可能的。因为造车太复杂，需要很多部门协作才能完成。此时面向对象思想就非 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/05/18/%E6%B5%85%E6%9E%90%E6%95%B0%E4%BB%93/" title="浅析数仓"><img class="post-bg" src="https://pic3.zhimg.com/v2-0bd9c012ab45707a8da186a7a2146636_r.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅析数仓"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/18/%E6%B5%85%E6%9E%90%E6%95%B0%E4%BB%93/" title="浅析数仓">浅析数仓</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-18T03:06:05.000Z" title="发表于 2023-05-18 11:06:05">2023-05-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-19T02:15:00.029Z" title="更新于 2023-05-19 10:15:00">2023-05-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E4%BB%93/">数仓</a></span></div><div class="content">浅析数仓随着互联网及物联网等技术发展，越来越多的数据被生成，如何有效利用这些数据就成为了企业决胜的法宝了。大型公司会基于数据做出BI、推荐系统、决策支持、统计分析、报表等业务。
OLTP VS OLAP1970年随着关系数据库理论的提出，诞生了一系列经典的RDBMS，如MySQL、Oracle、SQL Server、DB2等。这些RDBMS为社会信息化的发展做出的重大贡献。然而随着数据库使用范围的不断扩大，它被逐步划分为操作型数据库OLTP（在线事务处理）跟分析型数据库OLAP（在线分析处理）。
OLTP操作型数据库OLTP（On-Line Transaction Processing 在线事务处理）也可以称面向交易的处理系统，它是针对具体业务在数据库联机的日常操作，通常对记录进行CRUD。OLTP模式下用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题。传统的数据库系统作为数据管理的主要手段，主要用于操作型处理。
OLAP分析型数据库OLAP（On-Line Analytical Processing）叫在线分析处理，主要用于历史数据分析。这类数据库作为公司的单 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA/" title="浅析CAP理论&amp;Base理论"><img class="post-bg" src="/top_img/capbase.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅析CAP理论&amp;Base理论"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/16/%E6%B5%85%E6%9E%90CAP%E7%90%86%E8%AE%BA-Base%E7%90%86%E8%AE%BA/" title="浅析CAP理论&amp;Base理论">浅析CAP理论&amp;Base理论</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-16T07:20:25.000Z" title="发表于 2023-05-16 15:20:25">2023-05-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T07:43:09.735Z" title="更新于 2023-05-16 15:43:09">2023-05-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CAP/">CAP</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Base/">Base</a></span></div><div class="content">浅析CAP理论&amp;Base理论CAP理论CAP理论是分布式应用的理论基础，虽然所有的分布式系统在设计时都会向其看齐，但事实上的所有分布式系统都不可能同时满足CAP三种特性：
一致性 [C: Consistency]在分布式环境中，一致性是指数据在多个副本（分布式节点）之间能否保持数据强一致的特性。在一致性的要求下，当一个系统在数据一致状态下执行更新操作后，应该保证系统的数据仍然处于一致状态。
可用性 [A: Available]可用性是指系统提供的服务必须一直处于可用的状态，对用户的每一个请求操作总是能够在有限时间内返回结果。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。
分区容错性 [P: Partition Tolerance]分布式系统在遇到任何网络分区故障的时候，仍然能够保证对外提供满足一致性或者可用性的服务，除非是整个网络环境都发生了故障。分区容错性要求应用虽然是一个分布式系统，但看上去是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/05/16/Spring-Cloud-2-2-Eureka%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="「Spring Cloud-2-2」-- Eureka内部机制及源码分析"><img class="post-bg" src="/top_img/Eureka.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Spring Cloud-2-2」-- Eureka内部机制及源码分析"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/16/Spring-Cloud-2-2-Eureka%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="「Spring Cloud-2-2」-- Eureka内部机制及源码分析">「Spring Cloud-2-2」-- Eureka内部机制及源码分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T16:55:03.000Z" title="发表于 2023-05-16 00:55:03">2023-05-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-19T08:12:33.157Z" title="更新于 2023-05-19 16:12:33">2023-05-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Spring-Cloud/">Spring Cloud</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Eureka/">Eureka</a></span></div><div class="content">Eureka 内部机制及源码分析Eureka 运作原理Eureka-server 对外提供的是 restful 风格的服务，以http动词的形式对url资源进行操作：get、 post、 put、 delete，只要利用这些restful接口我们就能对项目实现注册和发现，只不过eureka已经帮我们使用java语言封装好了client端的代码，让开发者只需要在项目中依赖Eureka Client就能实现注册和发现。
只要能发起 Http 请求，那就可以向Eureka Server进行服务注册和发现，不管是什么语言。
服务注册当Eureka Client项目启动时，就会向Eureka Server发送自己的元数据（原始数据），如：运行的 ip、端口 port、健康的状态监控等。使用的是HTTP/ResuFul 请求风格。Eureka Server会在自己内部保留这些元数据（JVM内存中），形成一个服务列表。注册过程中为避免网络问题，会尝试3次。Eureka提供的是ResutFul风格的HTTP请求，Eureka封装的Java客户端底层使用的是Jersey框架进行HTTP请求。
注册调用链 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/16/Spring%20Cloud2-Eureka/" title="「Spring Cloud-2-1」-- Eureka Quick Start"><img class="post-bg" src="/top_img/Eureka.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Spring Cloud-2-1」-- Eureka Quick Start"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/16/Spring%20Cloud2-Eureka/" title="「Spring Cloud-2-1」-- Eureka Quick Start">「Spring Cloud-2-1」-- Eureka Quick Start</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T16:55:03.000Z" title="发表于 2023-05-16 00:55:03">2023-05-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-19T07:54:45.145Z" title="更新于 2023-05-19 15:54:45">2023-05-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Spring-Cloud/">Spring Cloud</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Eureka/">Eureka</a></span></div><div class="content">Spring Cloud EurekaEureka是服务注册发现中心。Eureka 来源于古希腊词汇，意为“发现了”。在软件领域， Eureka是Netflix公司开源的一个服务注册与发现的组件，和Netflix公司其它的一些服务组件(例如：负载均衡、 熔断器、网关等) 一起被Spring Cloud社区整合为Spring Cloud Netflix模块。 Eureka是Netflix贡献给Spring Cloud的一个开源框架。
同为注册中心，相比动物管理员Zookeeper，Spring Cloud Eureka有什么区别呢？
核心点在于分布式微服务中的CAP定理！

问：为什么 Zookeeper 不适合做注册中心?
Zookeeper 注重数据的一致性，Eureka 则侧重服务的可用性。

在 Zookeeper中，若Leader挂了，则Zookeeper集群整体不对外提供服务了，直到重新选举出一个新的Leader出来(选举时间大约120s 左右)，才能继续对外提供服务。
Eureka注重服务的可用性，当Eureka集群只要有一台活着，它就能对外提供服务。

Zookeeper ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/05/16/Spring%20Cloud1-%E5%88%86%E5%B8%83%E5%BC%8Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="「Spring Cloud - 1」-- 浅析分布式架构和微服务架构"><img class="post-bg" src="https://img0.baidu.com/it/u=171555148,2578235690&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=800&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Spring Cloud - 1」-- 浅析分布式架构和微服务架构"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/16/Spring%20Cloud1-%E5%88%86%E5%B8%83%E5%BC%8Fvs%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="「Spring Cloud - 1」-- 浅析分布式架构和微服务架构">「Spring Cloud - 1」-- 浅析分布式架构和微服务架构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T16:53:29.000Z" title="发表于 2023-05-16 00:53:29">2023-05-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-23T03:37:31.658Z" title="更新于 2023-05-23 11:37:31">2023-05-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Spring-Cloud/">Spring Cloud</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1/">分布式，微服务</a></span></div><div class="content">浅析分布式架构和微服务架构分布式架构在《分布式系统原理与范型》一书中有如下定义：

“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；

分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储等任务。其目的是利用更多的机器，处理更多的数据。
分布式系统（distributed system）是建立在网络之上的软件系统。
首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、提升CPU核数）无法明显改善时，应用程序也无法进一步优化的场景，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。
因此，随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需一个治理系统确保架构有条不 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/15/Spring%20Cloud3-Ribbon/" title="Ribbon"><img class="post-bg" src="/top_img/ribbon.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ribbon"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/15/Spring%20Cloud3-Ribbon/" title="Ribbon">Ribbon</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T15:58:24.000Z" title="发表于 2023-05-15 23:58:24">2023-05-15</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T06:32:25.365Z" title="更新于 2023-05-16 14:32:25">2023-05-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Spring-Cloud/">Spring Cloud</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Ribbon/">Ribbon</a></span></div><div class="content">轮训算法的实现
%取模运算的结果得到一个整型的周期函数，让得到的结果总是小于除数的。

1 % 2 = 1
2 % 2 = 0
3 % 2 = 1
4 % 2 =0
…

这样就得到一个[0,1]区间的一个周期函数。
CAS在Java层面是无锁的状态，但是在JVM层面还是有锁的，总线锁或者缓存锁。
基于CAS的自旋锁，如果有线程同时操作可能会导致短暂的CPU飙升，还有总所周知的ABA问题。
</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/05/15/Java-SPI/" title="Java SPI"><img class="post-bg" src="/top_img/spi.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java SPI"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/15/Java-SPI/" title="Java SPI">Java SPI</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-15T02:13:13.000Z" title="发表于 2023-05-15 10:13:13">2023-05-15</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-18T02:18:56.143Z" title="更新于 2024-04-18 10:18:56">2024-04-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/SPI/">SPI</a></span></div><div class="content">Java SPISPI（Service Provider Interface），是一种服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，其核心是基于“面向接口编程＋策略模式＋配置文件”组合实现的动态加载机制。

SPI是一种机制，Java SPI只是它的其中一种实现。

SPI整体机制如图：


当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类的全路径名。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行反射加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。
SPI和API的区别在现今的微服务的框架下，我们最常见的是提供API服务，也就是接口和实现都部署在同一个集群中，向外通过Http/Rpc协议进行暴露，外部调用方通过引入j ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2023/05/11/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="跨域问题及解决方案"><img class="post-bg" src="https://www.leixue.com/uploads/2019/03/Cross-Domain.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="跨域问题及解决方案"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/11/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" title="跨域问题及解决方案">跨域问题及解决方案</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-11T02:50:43.000Z" title="发表于 2023-05-11 10:50:43">2023-05-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-11T08:12:13.200Z" title="更新于 2023-05-11 16:12:13">2023-05-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%B7%A8%E5%9F%9F/">跨域</a></span></div><div class="content">跨域问题什么是跨域问题？出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面的URL具有相同的协议（protocol），主机/域名（host）和端口号（port）。
URI、URL和URN的区别当我们打开浏览器，要访问一个网站或者一个ftp服务器的时候，输入一串字符串， 比如：https://blog.csdn.net/或者：ftp://192.168.0.111/，这样我们就可以得到一个html格式的页面或者一个文件。那么这个地址是什么意思呢？就必须要从URI、URL、URN讲起。
定义
URI = Uniform Resource Identifier 统一资源标志符
URL = Uniform Resource Locator 统一资源定位符
URN = Uniform Res ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2023/05/10/%E6%99%AE%E9%80%9AToken%E4%BB%A4%E7%89%8C-vs-JWT%E4%BB%A4%E7%89%8C/" title="普通Token令牌 vs. JWT令牌"><img class="post-bg" src="https://img2.baidu.com/it/u=1844709176,4224449684&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=500&amp;h=220" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="普通Token令牌 vs. JWT令牌"></a></div><div class="recent-post-info"><a class="article-title" href="/2023/05/10/%E6%99%AE%E9%80%9AToken%E4%BB%A4%E7%89%8C-vs-JWT%E4%BB%A4%E7%89%8C/" title="普通Token令牌 vs. JWT令牌">普通Token令牌 vs. JWT令牌</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-10T07:33:26.000Z" title="发表于 2023-05-10 15:33:26">2023-05-10</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-11T08:57:05.529Z" title="更新于 2023-05-11 16:57:05">2023-05-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83/">认证鉴权</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/JWT/">JWT</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E4%BB%A4%E7%89%8C/">令牌</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/Token/">Token</a></span></div><div class="content">普通Token令牌 vs. JWT令牌
SpringSecurityOauth2令牌参考： SpringSecurityOauth2令牌

令牌分类常见的令牌有两种：普通令牌Token 和 JWT令牌

JWT令牌请见博文：浅析JWT

普通令牌唯一标识存储在数据库或内存中的用户信息，在认证时，SpringSecurity服务端会拿着普通令牌去数据库中查询用户信息来实现认证鉴权。
JWT令牌JWT令牌本身就存储着用户信息，在认证时，SpringSecurity从JWT令牌中按照约定的加密算法，解析出用户信息即可实现认证，不需要借助数据库等进行存储，进一步提高了认证鉴权的性能。
普通Token令牌普通令牌是SpringSecurityOauth2给客户端颁发的一个无含义的令牌，在令牌发布时，SpringSecurityOauth2将用户信息存储到程序指定的存储位置，并用普通令牌唯一标识这个存储信息，当用户再次携带令牌访问时，SpringSecurityOauth2会根据令牌查询用户信息，进而实现权限角色的限制。
普通令牌需要一个存储用户信息的地方，这个地方可以本地内存，也可以是数据库（R ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar1.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Maple</div><div class="author-info__description">一 切 都 是 最 好 的 安 排 !</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://maple8.github.io/" target="_blank" title="Old Version Blog"><i class="fas fa-blog"></i></a><a class="social-icon" href="https://gitee.com/maple_eitba" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:maple_eitba@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=790379323&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">原创&引用博客,记录并分享学习经验...</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/04/18/Git%E5%91%BD%E4%BB%A4/" title="Git命令"><img src="https://static.is26.com/wp-image/2013/09/git_wallpaper_clean_by_black_pixel-d5wmjnw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git命令"/></a><div class="content"><a class="title" href="/2024/04/18/Git%E5%91%BD%E4%BB%A4/" title="Git命令">Git命令</a><time datetime="2024-04-18T02:20:39.000Z" title="发表于 2024-04-18 10:20:39">2024-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/UML%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/" title="UML类间关系"><img src="https://p3.itc.cn/images01/20201026/7b654ea012344b228921f291cf3bedc4.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UML类间关系"/></a><div class="content"><a class="title" href="/2024/03/18/UML%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB/" title="UML类间关系">UML类间关系</a><time datetime="2024-03-18T03:25:47.000Z" title="发表于 2024-03-18 11:25:47">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/15/Java%E6%B3%A8%E8%A7%A3/" title="Java注解"><img src="/img/codeonce.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java注解"/></a><div class="content"><a class="title" href="/2024/03/15/Java%E6%B3%A8%E8%A7%A3/" title="Java注解">Java注解</a><time datetime="2024-03-15T09:14:08.000Z" title="发表于 2024-03-15 17:14:08">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/15/MySQL%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E5%A4%84%E7%90%86/" title="MySQL重复插入处理"><img src="https://mobiledev.tw/wp-content/uploads/2015/11/hour-of-code-logo-2-1024x528.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL重复插入处理"/></a><div class="content"><a class="title" href="/2024/03/15/MySQL%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5%E5%A4%84%E7%90%86/" title="MySQL重复插入处理">MySQL重复插入处理</a><time datetime="2024-03-15T08:47:45.000Z" title="发表于 2024-03-15 16:47:45">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/14/Mybatis-Generator%E9%85%8D%E7%BD%AE/" title="Mybatis Generator配置"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis Generator配置"/></a><div class="content"><a class="title" href="/2024/03/14/Mybatis-Generator%E9%85%8D%E7%BD%AE/" title="Mybatis Generator配置">Mybatis Generator配置</a><time datetime="2024-03-14T02:50:29.000Z" title="发表于 2024-03-14 10:50:29">2024-03-14</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Git/"><span class="card-category-list-name">Git</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">10</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/OOA-OOD/"><span class="card-category-list-name">OOA&OOD</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Spring-Cloud/"><span class="card-category-list-name">Spring Cloud</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84/"><span class="card-category-list-name">业务架构</span><span class="card-category-list-count">9</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"><span class="card-category-list-name">大数据</span><span class="card-category-list-count">2</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/OAuth2-0/" style="font-size: 1.15em; color: rgb(95, 52, 121)">OAuth2.0</a><a href="/tags/Cookie/" style="font-size: 1.15em; color: rgb(33, 138, 112)">Cookie</a><a href="/tags/Session/" style="font-size: 1.15em; color: rgb(155, 164, 63)">Session</a><a href="/tags/JVM/" style="font-size: 1.15em; color: rgb(104, 98, 100)">JVM</a><a href="/tags/JWT/" style="font-size: 1.3em; color: rgb(32, 11, 129)">JWT</a><a href="/tags/%E4%BB%A4%E7%89%8C/" style="font-size: 1.3em; color: rgb(174, 144, 4)">令牌</a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.15em; color: rgb(55, 167, 148)">注解</a><a href="/tags/SPI/" style="font-size: 1.15em; color: rgb(115, 102, 70)">SPI</a><a href="/tags/Lombok/" style="font-size: 1.15em; color: rgb(146, 172, 26)">Lombok</a><a href="/tags/MySQL/" style="font-size: 1.15em; color: rgb(130, 60, 112)">MySQL</a><a href="/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 1.15em; color: rgb(108, 38, 30)">隐式类型转换</a><a href="/tags/MBG/" style="font-size: 1.15em; color: rgb(130, 154, 34)">MBG</a><a href="/tags/Sentinel/" style="font-size: 1.45em; color: rgb(154, 17, 189)">Sentinel</a><a href="/tags/Ribbon/" style="font-size: 1.15em; color: rgb(129, 18, 199)">Ribbon</a><a href="/tags/Eureka/" style="font-size: 1.3em; color: rgb(130, 99, 58)">Eureka</a><a href="/tags/ThreadLocal/" style="font-size: 1.15em; color: rgb(158, 149, 152)">ThreadLocal</a><a href="/tags/UML/" style="font-size: 1.15em; color: rgb(71, 41, 5)">UML</a><a href="/tags/%E6%9E%9A%E4%B8%BE/" style="font-size: 1.15em; color: rgb(198, 127, 7)">枚举</a><a href="/tags/vim/" style="font-size: 1.15em; color: rgb(154, 35, 34)">vim</a><a href="/tags/%E5%88%86%E9%94%80/" style="font-size: 1.15em; color: rgb(65, 8, 4)">分销</a><a href="/tags/CAP/" style="font-size: 1.15em; color: rgb(78, 150, 36)">CAP</a><a href="/tags/Base/" style="font-size: 1.15em; color: rgb(42, 179, 99)">Base</a><a href="/tags/Saas/" style="font-size: 1.15em; color: rgb(100, 13, 55)">Saas</a><a href="/tags/%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE/" style="font-size: 1.15em; color: rgb(194, 30, 73)">异构数据</a><a href="/tags/%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB/" style="font-size: 1.15em; color: rgb(14, 126, 121)">故障转移</a><a href="/tags/%E6%95%B0%E4%BB%93/" style="font-size: 1.15em; color: rgb(125, 149, 23)">数仓</a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/" style="font-size: 1.15em; color: rgb(124, 37, 5)">面向对象，面向过程</a><a href="/tags/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1/" style="font-size: 1.15em; color: rgb(76, 65, 125)">用户中心设计</a><a href="/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/" style="font-size: 1.3em; color: rgb(52, 91, 145)">状态机</a><a href="/tags/%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F/" style="font-size: 1.15em; color: rgb(99, 132, 37)">订单系统</a><a href="/tags/%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6/" style="font-size: 1.15em; color: rgb(79, 78, 190)">接口超时</a><a href="/tags/%E8%B7%A8%E5%9F%9F/" style="font-size: 1.15em; color: rgb(53, 120, 136)">跨域</a><a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 1.15em; color: rgb(55, 117, 33)">单例模式</a><a href="/tags/%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/" style="font-size: 1.15em; color: rgb(96, 5, 75)">钩子方法</a><a href="/tags/%E9%98%B2%E7%9B%97%E9%93%BE/" style="font-size: 1.15em; color: rgb(141, 191, 143)">防盗链</a><a href="/tags/Token/" style="font-size: 1.15em; color: rgb(111, 200, 29)">Token</a><a href="/tags/Maven/" style="font-size: 1.15em; color: rgb(74, 140, 71)">Maven</a><a href="/tags/Git/" style="font-size: 1.15em; color: rgb(195, 120, 121)">Git</a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 1.15em; color: rgb(152, 126, 145)">分布式，微服务</a><a href="/tags/%E5%AF%B9%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9API/" style="font-size: 1.15em; color: rgb(30, 168, 186)">对接第三方API</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">12</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><span class="card-archive-list-count">16</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">48</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">121.4k</div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Maple</div><div class="footer_custom_text">一 切 都 是 最 好 的 安 排 !</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (true) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  if (true) {
    typedJSFn.init(["越 努 力 , 越 幸 运","一 切 都 是 最 好 的 安 排 !"])
  } else {
    document.getElementById("subtitle").innerHTML = '越 努 力 , 越 幸 运'
  }
}
typedJSFn.run(subtitleType)</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>